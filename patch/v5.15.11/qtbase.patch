diff --git a/config.tests/arch/write_info.pri b/config.tests/arch/write_info.pri
index 5b43ce1cd5..e0518dd242 100644
--- a/config.tests/arch/write_info.pri
+++ b/config.tests/arch/write_info.pri
@@ -3,6 +3,9 @@ targetinfofile ~= s/pro$/target.txt/
 
 win32 {
     ext = .exe
+} else:android|openharmony {
+    file_prefix = lib
+    ext = .so
 } else:wasm {
     ext = .wasm
 }
diff --git a/mkspecs/common/oh-base-head.conf b/mkspecs/common/oh-base-head.conf
new file mode 100644
index 0000000000..d7be212137
--- /dev/null
+++ b/mkspecs/common/oh-base-head.conf
@@ -0,0 +1,24 @@
+load(device_config)
+
+SDK_ROOT = $$(OHOS_SDK_PATH)
+
+isEmpty(NDK_TOOLCHAIN_PREFIX) {    
+    equals(OHOS_ARCH, arm64-v8a): NDK_TOOLCHAIN_PREFIX = aarch64-linux-ohos
+    else: equals(OHOS_ARCH, armeabi-v7a): NDK_TOOLCHAIN_PREFIX = arm-linux-ohos
+    else: equals(OHOS_ARCH, x86_64): NDK_TOOLCHAIN_PREFIX = x86_64-linux-ohos
+    else: NDK_TOOLCHAIN_PREFIX = arm-linux-ohos
+}
+
+QMAKE_CFLAGS = -D__MUSL__
+QMAKE_CXXFLAGS = -D__MUSL__
+QMAKE_CFLAGS += -DOPENHARMONY
+QMAKE_CXXFLAGS += -DOPENHARMONY
+
+CROSS_COMPILE = $$shell_path($$SDK_ROOT/native/llvm/bin/)
+
+QMAKE_PCH_OUTPUT_EXT    = .gch
+
+QMAKE_CFLAGS_PRECOMPILE       = -x c-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}
+QMAKE_CFLAGS_USE_PRECOMPILE   = -include ${QMAKE_PCH_OUTPUT_BASE}
+QMAKE_CXXFLAGS_PRECOMPILE     = -x c++-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}
+QMAKE_CXXFLAGS_USE_PRECOMPILE = $$QMAKE_CFLAGS_USE_PRECOMPILE
diff --git a/mkspecs/common/oh-base-tail.conf b/mkspecs/common/oh-base-tail.conf
new file mode 100644
index 0000000000..a9b28bfefd
--- /dev/null
+++ b/mkspecs/common/oh-base-tail.conf
@@ -0,0 +1,76 @@
+equals(OHOS_ARCH, armeabi-v7a): \
+    QMAKE_CFLAGS += -march=armv7a -msoft-float -mfpu=vfp -fno-builtin-memmove
+else: equals(OHOS_ARCH, arm64-v8a): \
+    QMAKE_CFLAGS += -march=armv8a -msoft-float -mfpu=vfp -fno-builtin-memmove
+else: equals(OHOS_ARCH, x86_64): \
+    QMAKE_CFLAGS += -march=x86_64
+else: \
+    QMAKE_CFLAGS += -march=armv7a -msoft-float -mfpu=vfp -fno-builtin-memmove
+
+
+equals(OHOS_ARCH, armeabi-v7a) | equals(OHOS_ARCH, armeabi) {
+    CONFIG += optimize_size
+    QMAKE_CFLAGS_DEBUG = -g -marm -O0
+}
+
+QMAKE_CFLAGS_SHLIB      = -fPIC
+QMAKE_CFLAGS_YACC       = -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD     = -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+QMAKE_CFLAGS_NEON       = -mfpu=neon
+
+QMAKE_CFLAGS_GNUC99     = -std=gnu99
+QMAKE_CFLAGS_GNUC11     = -std=gnu11
+QMAKE_CXXFLAGS_CXX11    = -std=c++11
+QMAKE_CXXFLAGS_CXX14    = -std=c++14
+QMAKE_CXXFLAGS_CXX1Z    = -std=c++1z
+QMAKE_CXXFLAGS_GNUCXX11 = -std=gnu++11
+QMAKE_CXXFLAGS_GNUCXX14 = -std=gnu++14
+QMAKE_CXXFLAGS_GNUCXX1Z = -std=gnu++1z
+
+QMAKE_CXXFLAGS          = $$QMAKE_CFLAGS
+QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF = $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE += $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO
+QMAKE_CXXFLAGS_DEBUG   += $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB    = $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC     = $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD   = $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+# modifications to linux.conf
+QMAKE_AR                = $${CROSS_COMPILE}llvm-ar cqs
+QMAKE_OBJCOPY           = $${CROSS_COMPILE}llvm-objcopy
+QMAKE_NM                = $${CROSS_COMPILE}llvm-nm -P
+
+QMAKE_STRIP             =
+
+QMAKE_RANLIB            = $${CROSS_COMPILE}llvm-ranlib
+
+QMAKE_INCDIR_POST       = $$shell_path($$SDK_ROOT/native/sysroot/usr/include/$${NDK_TOOLCHAIN_PREFIX})
+QMAKE_LIBDIR_POST       = $$shell_path($$SDK_ROOT/native/sysroot/usr/lib/$${NDK_TOOLCHAIN_PREFIX})
+QMAKE_INCDIR_X11        =
+QMAKE_LIBDIR_X11        =
+QMAKE_INCDIR_OPENGL     =
+QMAKE_LIBDIR_OPENGL     =
+
+QMAKE_LINK_SHLIB        = $$QMAKE_LINK
+QMAKE_LFLAGS            = --sysroot=$$shell_path($$SDK_ROOT/native/sysroot)
+#QMAKE_LFLAGS_APP        = -Wl,--no-undefined -Wl,-z,noexecstack -shared
+#QMAKE_LFLAGS_SHLIB      = -Wl,--no-undefined -Wl,-z,noexecstack -shared
+QMAKE_LFLAGS_PLUGIN     = $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_NOUNDEF    = -Wl,--no-undefined
+QMAKE_LFLAGS_RPATH      = -Wl,-rpath=
+QMAKE_LFLAGS_RPATHLINK  = -Wl,-rpath-link=
+
+#QMAKE_LIBS_PRIVATE      = -lc++ -lz -lm -ldl -lc -lhilog_ndk.z
+QMAKE_LIBS_X11          =
+QMAKE_LIBS_THREAD       =
+QMAKE_LIBS_EGL          = -lEGL
+QMAKE_LIBS_OPENGL       =
+QMAKE_LIBS_OPENGL_ES2   = -lGLESv3
+
+!exists($$SDK_ROOT): error("You need to set the OHOS_SDK_PATH environment variable to point to your Harmony NDK.")
+
+load(qt_config)
diff --git a/mkspecs/features/openharmony/openharmony.prf b/mkspecs/features/openharmony/openharmony.prf
new file mode 100644
index 0000000000..14524b35ee
--- /dev/null
+++ b/mkspecs/features/openharmony/openharmony.prf
@@ -0,0 +1,4 @@
+contains(TEMPLATE, ".*app") {
+    !contains(TARGET, ".so"): TARGET = lib$${TARGET}.so
+    QMAKE_LFLAGS += -Wl,-soname,$$shell_quote($$TARGET)
+}
diff --git a/mkspecs/features/qt_plugin.prf b/mkspecs/features/qt_plugin.prf
index 573d717eea..94b8dd5666 100644
--- a/mkspecs/features/qt_plugin.prf
+++ b/mkspecs/features/qt_plugin.prf
@@ -91,8 +91,19 @@ CONFIG(static, static|shared)|prefix_build {
 target.path = $$[QT_INSTALL_PLUGINS]/$$PLUGIN_TYPE
 INSTALLS += target
 
-qt_libinfix_plugins: TARGET = $$TARGET$$QT_LIBINFIX
-TARGET = $$qt5LibraryTarget($$TARGET, "plugins/$$PLUGIN_TYPE/")
+defineReplace(qt5OpenHarmonyPluginTarget) {
+    LIBRARY_NAME_PREFIX = $$2
+    LIBRARY_NAME_PREFIX = $$replace(LIBRARY_NAME_PREFIX, "//", "/")
+    LIBRARY_NAME_PREFIX = $$replace(LIBRARY_NAME_PREFIX, "/", "_")
+    LIBRARY_NAME = $$LIBRARY_NAME_PREFIX$$qtLibraryTarget($$1)
+    unset(LIBRARY_NAME_PREFIX)
+   return($$LIBRARY_NAME)
+}
+
+
+TARGET = $$qt5OpenHarmonyPluginTarget($$TARGET, "plugins/$$PLUGIN_TYPE/")
+#qt_libinfix_plugins: TARGET = $$TARGET$$QT_LIBINFIX
+#TARGET = $$qt5LibraryTarget($$TARGET, "plugins/$$PLUGIN_TYPE/")
 
 CONFIG += create_cmake
 
diff --git a/mkspecs/oh-clang/qmake.conf b/mkspecs/oh-clang/qmake.conf
new file mode 100644
index 0000000000..03139d2b22
--- /dev/null
+++ b/mkspecs/oh-clang/qmake.conf
@@ -0,0 +1,39 @@
+# qmake configuration for building with oh-clang
+MAKEFILE_GENERATOR      = UNIX
+QMAKE_PLATFORM          = openharmony
+QMAKE_COMPILER          = gcc clang llvm
+
+CONFIG                 += unversioned_soname unversioned_libname plugin_with_soname
+
+include(../common/linux.conf)
+include(../common/gcc-base-unix.conf)
+include(../common/clang.conf)
+include(../common/oh-base-head.conf)
+
+NDK_LLVM_PATH = $$SDK_ROOT/native/llvm
+QMAKE_CC      = $${CROSS_COMPILE}clang
+QMAKE_CXX     = $${CROSS_COMPILE}clang++
+
+equals(OHOS_ARCH, armeabi-v7a): \
+        QMAKE_CFLAGS += -target arm-linux-ohos
+else:equals(OHOS_ARCH,arm64-v8a): \
+        QMAKE_CFLAGS += -target aarch64-linux-ohos
+else:equals(OHOS_ARCH,x86-64): \
+        QMAKE_CFLAGS += -target x86_64-linux-ohos
+
+#QMAKE_CFLAGS+=--gcc-toolchain=$$NDK_LLVM_PATH
+QMAKE_LINK += -Wl,--exclude-libs,$$shell_path($$SDK_ROOT/native/llvm/lib/$$NDK_TOOLCHAIN_PREFIX/libunwind.a)
+
+QMAKE_CFLAGS += --sysroot=$$shell_path($$SDK_ROOT/native/sysroot) \
+                -isystem=$$shell_path($$SDK_ROOT/native/sysroot) \
+                -isystem=$$shell_path($$SDK_ROOT/native/sysroot/usr/include) \
+                -isystem=$$shell_path($$SDK_ROOT/native/llvm/include/libcxx-ohos/include/c++/v1)
+
+
+QMAKE_CLFAGS += -g -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -fno-addrsig -Wa,--noexecstack -Wformat -Werror=format-security
+
+QMAKE_LINK    = $$QMAKE_CXX $$QMAKE_CFLAGS
+
+QMAKE_CFLAGS_OPTIMIZE_SIZE = -Oz
+
+include(../common/oh-base-tail.conf)
diff --git a/mkspecs/oh-clang/qplatformdefs.h b/mkspecs/oh-clang/qplatformdefs.h
new file mode 100644
index 0000000000..f405c91ecb
--- /dev/null
+++ b/mkspecs/oh-clang/qplatformdefs.h
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the qmake spec of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QPLATFORMDEFS_H
+#define QPLATFORMDEFS_H
+
+// Get Qt defines/settings
+
+#include "qglobal.h"
+
+// Set any POSIX/XOPEN defines at the top of this file to turn on specific APIs
+
+// 1) need to reset default environment if _BSD_SOURCE is defined
+// 2) need to specify POSIX thread interfaces explicitly in glibc 2.0
+// 3) it seems older glibc need this to include the X/Open stuff
+
+#include <unistd.h>
+
+// We are hot - unistd.h should have turned on the specific APIs we requested
+
+#include <features.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <pwd.h>
+#include <signal.h>
+#include <dlfcn.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/ipc.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#ifndef _GNU_SOURCE
+#  define _GNU_SOURCE
+#endif
+
+#ifdef QT_LARGEFILE_SUPPORT
+#define QT_STATBUF              struct stat64
+#define QT_STATBUF4TSTAT        struct stat64
+#define QT_STAT                 ::stat64
+#define QT_FSTAT                ::fstat64
+#define QT_LSTAT                ::lstat64
+#define QT_OPEN                 ::open64
+#define QT_TRUNCATE             ::truncate64
+#define QT_FTRUNCATE            ::ftruncate64
+#define QT_LSEEK                ::lseek64
+#else
+#define QT_STATBUF              struct stat
+#define QT_STATBUF4TSTAT        struct stat
+#define QT_STAT                 ::stat
+#define QT_FSTAT                ::fstat
+#define QT_LSTAT                ::lstat
+#define QT_OPEN                 ::open
+#define QT_TRUNCATE             ::truncate
+#define QT_FTRUNCATE            ::ftruncate
+#define QT_LSEEK                ::lseek
+#endif
+
+#ifdef QT_LARGEFILE_SUPPORT
+#define QT_FOPEN                ::fopen64
+#define QT_FSEEK                ::fseeko64
+#define QT_FTELL                ::ftello64
+#define QT_FGETPOS              ::fgetpos64
+#define QT_FSETPOS              ::fsetpos64
+#define QT_MMAP                 ::mmap64
+#define QT_FPOS_T               fpos64_t
+#define QT_OFF_T                off64_t
+#else
+#define QT_FOPEN                ::fopen
+#define QT_FSEEK                ::fseek
+#define QT_FTELL                ::ftell
+#define QT_FGETPOS              ::fgetpos
+#define QT_FSETPOS              ::fsetpos
+#define QT_MMAP                 ::mmap
+#define QT_FPOS_T               fpos_t
+#define QT_OFF_T                long
+#endif
+
+#define QT_STAT_REG             S_IFREG
+#define QT_STAT_DIR             S_IFDIR
+#define QT_STAT_MASK            S_IFMT
+#define QT_STAT_LNK             S_IFLNK
+#define QT_SOCKET_CONNECT       ::connect
+#define QT_SOCKET_BIND          ::bind
+#define QT_FILENO               fileno
+#define QT_CLOSE                ::close
+#define QT_READ                 ::read
+#define QT_WRITE                ::write
+#define QT_ACCESS               ::access
+#define QT_GETCWD               ::getcwd
+#define QT_CHDIR                ::chdir
+#define QT_MKDIR                ::mkdir
+#define QT_RMDIR                ::rmdir
+#define QT_OPEN_LARGEFILE       O_LARGEFILE
+#define QT_OPEN_RDONLY          O_RDONLY
+#define QT_OPEN_WRONLY          O_WRONLY
+#define QT_OPEN_RDWR            O_RDWR
+#define QT_OPEN_CREAT           O_CREAT
+#define QT_OPEN_TRUNC           O_TRUNC
+#define QT_OPEN_APPEND          O_APPEND
+#define QT_OPEN_EXCL            O_EXCL
+
+// Directory iteration
+#define QT_DIR                  DIR
+
+#define QT_OPENDIR              ::opendir
+#define QT_CLOSEDIR             ::closedir
+
+#if defined(QT_LARGEFILE_SUPPORT) \
+        && defined(QT_USE_XOPEN_LFS_EXTENSIONS) \
+        && !defined(QT_NO_READDIR64)
+#define QT_DIRENT               struct dirent64
+#define QT_READDIR              ::readdir64
+#define QT_READDIR_R            ::readdir64_r
+#else
+#define QT_DIRENT               struct dirent
+#define QT_READDIR              ::readdir
+#define QT_READDIR_R            ::readdir_r
+#endif
+
+#define QT_SOCKET_CONNECT       ::connect
+#define QT_SOCKET_BIND          ::bind
+
+
+#define QT_SIGNAL_RETTYPE       void
+#define QT_SIGNAL_ARGS          int
+#define QT_SIGNAL_IGNORE        SIG_IGN
+
+#define QT_SOCKLEN_T            socklen_t
+
+#if defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500)
+#define QT_SNPRINTF             ::snprintf
+#define QT_VSNPRINTF            ::vsnprintf
+#endif
+
+#endif // QPLATFORMDEFS_H
diff --git a/src/corelib/global/qlogging.cpp b/src/corelib/global/qlogging.cpp
index 292116cc47..540d6f00a1 100644
--- a/src/corelib/global/qlogging.cpp
+++ b/src/corelib/global/qlogging.cpp
@@ -1668,6 +1668,36 @@ static bool android_default_message_handler(QtMsgType type,
 }
 #endif //Q_OS_ANDROID
 
+#ifdef Q_OS_OPENHARMONY
+#include <hilog/log.h>
+#define APP_LOG_DOMAIN 0xf000
+#define APP_LOG_TAG "QtForOpenHarmony"
+
+static bool openharmony_default_message_handler(QtMsgType type,
+                                                const QMessageLogContext &context,
+                                                const QString &message)
+{
+    if (shouldLogToStderr())
+        return false; // Leave logging up to stderr handler
+
+    QString formattedMessage = qFormatLogMessage(type, context, message);
+
+    LogLevel priority = LOG_INFO;
+    switch (type) {
+    //LOG_DEBUG unable to print, temporarily use LOG_ INFO replace.
+    case QtDebugMsg: priority = LOG_INFO; break;
+    case QtInfoMsg: priority = LOG_INFO; break;
+    case QtWarningMsg: priority = LOG_WARN; break;
+    case QtCriticalMsg: priority = LOG_ERROR; break;
+    case QtFatalMsg: priority = LOG_FATAL; break;
+    };
+
+    OH_LOG_Print(LOG_APP, priority, APP_LOG_DOMAIN, APP_LOG_TAG, "%{public}s %{public}s\n", qPrintable(QCoreApplication::applicationName()), qPrintable(formattedMessage));
+
+    return true; // Prevent further output to stderr
+}
+#endif
+
 #ifdef Q_OS_WIN
 static void win_outputDebugString_helper(const QString &message)
 {
@@ -1779,6 +1809,8 @@ static void qDefaultMessageHandler(QtMsgType type, const QMessageLogContext &con
     handledStderr |= AppleUnifiedLogger::messageHandler(type, context, message);
 # elif defined Q_OS_WASM
     handledStderr |= wasm_default_message_handler(type, context, message);
+#elif defined Q_OS_OPENHARMONY
+    handledStderr |= openharmony_default_message_handler(type, context, message);
 # endif
 #endif
 
diff --git a/src/corelib/global/qsystemdetection.h b/src/corelib/global/qsystemdetection.h
index ad5d30d544..72a026b182 100644
--- a/src/corelib/global/qsystemdetection.h
+++ b/src/corelib/global/qsystemdetection.h
@@ -118,6 +118,9 @@
 #elif defined(__ANDROID__) || defined(ANDROID)
 #  define Q_OS_ANDROID
 #  define Q_OS_LINUX
+#elif defined(__OHOS__) || defined(OPENHARMONY)
+#  define Q_OS_OPENHARMONY
+#  define Q_OS_LINUX
 #elif defined(__CYGWIN__)
 #  define Q_OS_CYGWIN
 #elif !defined(SAG_COM) && (!defined(WINAPI_FAMILY) || WINAPI_FAMILY==WINAPI_FAMILY_DESKTOP_APP) && (defined(WIN64) || defined(_WIN64) || defined(__WIN64__))
diff --git a/src/corelib/io/qfileselector.cpp b/src/corelib/io/qfileselector.cpp
index ee378f6434..1798a905c6 100644
--- a/src/corelib/io/qfileselector.cpp
+++ b/src/corelib/io/qfileselector.cpp
@@ -199,6 +199,9 @@ static bool isLocalScheme(const QString &file)
     bool local = file == QLatin1String("qrc");
 #ifdef Q_OS_ANDROID
     local |= file == QLatin1String("assets");
+#endif
+#ifdef Q_OS_OPENHARMONY
+    local |= file == QLatin1String("rawfile");
 #endif
     return local;
 }
@@ -223,6 +226,10 @@ QUrl QFileSelector::select(const QUrl &filePath) const
         if (filePath.scheme() == QLatin1String("assets"))
             scheme = QLatin1String("assets:");
 #endif
+#ifdef Q_OS_OPENHARMONY
+        if (filePath.scheme() == QLatin1String("rawfile"))
+            scheme = QLatin1String("rawfile:");
+#endif
 
         QString equivalentPath = scheme + filePath.path();
         QString selectedPath = d->select(equivalentPath);
diff --git a/src/corelib/io/qurl.cpp b/src/corelib/io/qurl.cpp
index 50512a4a73..3d6226cd2c 100644
--- a/src/corelib/io/qurl.cpp
+++ b/src/corelib/io/qurl.cpp
@@ -445,6 +445,11 @@ static inline QString webDavScheme()
     return QStringLiteral("webdavs");
 }
 
+static inline QString harmonyFileScheme()
+{
+    return QStringLiteral("datashare");
+}
+
 static inline QString webDavSslTag()
 {
     return QStringLiteral("@SSL");
@@ -1018,6 +1023,9 @@ inline bool QUrlPrivate::setScheme(const QString &value, int len, bool doSetErro
     if (scheme == fileScheme()
 #ifdef Q_OS_WIN
         || scheme == webDavScheme()
+#endif
+#ifdef Q_OS_OPENHARMONY
+        || scheme == harmonyFileScheme()
 #endif
        ) {
         flags |= IsLocalFile;
diff --git a/src/corelib/kernel/kernel.pri b/src/corelib/kernel/kernel.pri
index 749672c899..602dce2d9f 100644
--- a/src/corelib/kernel/kernel.pri
+++ b/src/corelib/kernel/kernel.pri
@@ -212,4 +212,24 @@ android:!android-embedded {
                    kernel/qjni_p.h
 }
 
+openharmony {
+    SOURCES += kernel/qopenharmonyload.cpp \
+            kernel/qopenharmonyjsobject.cpp  \
+            kernel/qopenharmonyjsobjectloader.cpp  \
+            kernel/qopenharmonyjsobjectpool.cpp \
+            kernel/qopenharmonyjsenvironment.cpp \
+            kernel/qopenharmonyjsfunction.cpp \
+            kernel/qopenharmonyhelpers.cpp
+
+    HEADERS += kernel/qopenharmonyjsobject.h \
+            kernel/qopenharmonyjsobjectloader.h  \
+            kernel/qopenharmonyjsobjectpool.h \
+            kernel/qopenharmonyjsenvironment.h \
+            kernel/qopenharmonydefines.h \
+            kernel/qopenharmonyjsfunction.h \
+            kernel/qopenharmonyhelpers_p.h
+
+    LIBS += -lace_napi.z -luv -lc++ -lz -lm -ldl -lc -lhilog_ndk.z
+}
+
 !darwin:!unix:!win32: SOURCES += kernel/qelapsedtimer_generic.cpp
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index d671f70bd3..cebbec8e29 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -2335,7 +2335,7 @@ QString QCoreApplication::applicationFilePath()
     }
 #endif
 #if defined( Q_OS_UNIX )
-#  if defined(Q_OS_LINUX) && (!defined(Q_OS_ANDROID) || defined(Q_OS_ANDROID_EMBEDDED))
+#  if defined(Q_OS_LINUX) && !defined(Q_OS_OPENHARMONY) && (!defined(Q_OS_ANDROID) || defined(Q_OS_ANDROID_EMBEDDED))
     // Try looking for a /proc/<pid>/exe symlink first which points to
     // the absolute path of the executable
     QFileInfo pfi(QString::fromLatin1("/proc/%1/exe").arg(getpid()));
diff --git a/src/corelib/kernel/qopenharmonydefines.h b/src/corelib/kernel/qopenharmonydefines.h
new file mode 100644
index 0000000000..7480dc1c20
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonydefines.h
@@ -0,0 +1,107 @@
+#ifndef QOPENHARMONYDEFINES_H
+#define QOPENHARMONYDEFINES_H
+#include <hilog/log.h>
+
+#define QPA_LOG_DOMAIN 0xff11
+#define QPA_LOG_TAG "QtForOpenHarmony"
+#define LOGI(...) ((void)OH_LOG_Print(LOG_APP, LOG_INFO, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGD(...) ((void)OH_LOG_Print(LOG_APP, LOG_DEBUG, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGW(...) ((void)OH_LOG_Print(LOG_APP, LOG_WARN, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGE(...) ((void)OH_LOG_Print(LOG_APP, LOG_ERROR, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+
+#define NAPI_RETVAL_NOTHING
+
+#define GET_AND_THROW_LAST_ERROR(env, status, function)                                                     \
+    do {                                                                                                    \
+        const napi_extended_error_info* errorInfo = nullptr;                                                \
+        napi_get_last_error_info((env), &errorInfo);                                                        \
+        bool isPending = false;                                                                             \
+        napi_is_exception_pending((env), &isPending);                                                       \
+        if (!isPending && errorInfo != nullptr) {                                                           \
+            const char* errorMessage =                                                                      \
+                errorInfo->error_message != nullptr ? errorInfo->error_message : function;                  \
+                LOGE("call method %{public}s failed, the error code is %{public}d", errorMessage, status);  \
+        }                                                                                                   \
+    } while (0)
+
+#define NAPI_ASSERT_BASE(env, assertion, message, retVal)                                    \
+    do {                                                                                     \
+        if (!(assertion)) {                                                                  \
+            napi_throw_error((env), nullptr, "assertion (" #assertion ") failed: " message); \
+            return retVal;                                                                   \
+        }                                                                                    \
+    } while (0)
+
+#define NAPI_ASSERT(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, nullptr)
+
+#define NAPI_ASSERT_RETURN_VOID(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_BASE(env, theCall, retVal)                   \
+    do {                                                       \
+        napi_status status = (theCall);                        \
+        if (status != napi_ok) {                               \
+            GET_AND_THROW_LAST_ERROR((env), status, #theCall); \
+            return retVal;                                     \
+        }                                                      \
+    } while (0)
+
+#define NAPI_CALL_BASE_NO_THROW(env, theCall, retVal) \
+    do {                                     \
+        if ((theCall) != napi_ok) {          \
+            return retVal;                   \
+        }                                    \
+    } while (0)
+
+#define NAPI_CALL(env, theCall) NAPI_CALL_BASE(env, theCall, nullptr)
+
+#define NAPI_CALL_RETURN_VOID(env, theCall) NAPI_CALL_BASE(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_RETURN_VOID_NO_THROW(env, theCall) NAPI_CALL_BASE_NO_THROW(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define DECLARE_NAPI_PROPERTY(name, val)                                       \
+    {                                                                          \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_STATIC_PROPERTY(name, val)                               \
+    {                                                                         \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION_WITH_DATA(name, func, data)                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, data    \
+    }
+
+#define DECLARE_NAPI_STATIC_FUNCTION(name, func)                                 \
+    {                                                                            \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER(name, getter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, (getter), nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_SETTER(name, setter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, nullptr, (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER_SETTER(name, getter, setter)                             \
+    {                                                                                \
+        (name), nullptr, nullptr, (getter), (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+
+#endif // QOPENHARMONYDEFINES_H
diff --git a/src/corelib/kernel/qopenharmonyhelpers.cpp b/src/corelib/kernel/qopenharmonyhelpers.cpp
new file mode 100644
index 0000000000..6ac33f6a4a
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyhelpers.cpp
@@ -0,0 +1,129 @@
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsenvironment.h"
+#include "qmutex.h"
+#include "qlist.h"
+#include "qsemaphore.h"
+#include "qsharedpointer.h"
+#include "qvector.h"
+#include "qthread.h"
+#include "qcoreapplication.h"
+#include <QtCore/qrunnable.h>
+
+#include <deque>
+#include <memory>
+
+QT_BEGIN_NAMESPACE
+
+namespace QtHarmonyPrivate {
+    ResumePauseListener::~ResumePauseListener() {}
+    void ResumePauseListener::handlePause() {}
+    void ResumePauseListener::handleResume() {}
+
+    napi_value variant_to_napi_value(const QVariant &value)
+    {
+        napi_value ret = nullptr;
+        QVariant::Type t = value.type();
+        switch (t) {
+        case QVariant::Int:
+            ret = qJs::createInt32(value.toInt());
+            break;
+        case QVariant::String:
+            ret = qJs::createString(value.toString());
+            break;
+        case QVariant::StringList:
+            ret = qJs::createStringArray(value.toStringList());
+            break;
+        case QVariant::Bool:
+            ret = qJs::createBool(value.toBool());
+            break;
+        case QVariant::LongLong:
+            ret = qJs::createInt64(value.toLongLong());
+            break;
+        case QVariant::ByteArray:
+            ret = qJs::createArrayBuffer(value.toByteArray());
+            break;
+        case QVariant::Map:
+            ret = qJs::createObject(value.toMap());
+            break;
+        default:
+            //Todo other type
+            break;
+        }
+        return ret;
+    }
+
+    QVariant napi_value_to_variant(napi_value value, int t)
+    {
+        QVariant ret;
+        switch (t) {
+        case QMetaType::Int:
+            ret = qJs::getInt32(value);
+            break;
+        case QMetaType::QString:
+            ret = qJs::getString(value);
+            break;
+        case QMetaType::QStringList:
+            ret = qJs::getStringList(value);
+            break;
+        case QMetaType::Bool:
+            ret = qJs::getBool(value);
+            break;
+        case QMetaType::LongLong:
+            ret = QVariant::fromValue(qJs::getInt64(value));
+            break;
+        case QMetaType::QByteArray:
+            ret = QVariant::fromValue(qJs::getByteArray(value));
+            break;
+        case QMetaType::QByteArrayList:
+            ret = QVariant::fromValue(qJs::getByteArrayList(value));
+            break;
+        default:
+            //Todo other type
+            break;
+        }
+        return ret;
+    }
+
+
+}
+
+namespace {
+class ResumePauseListeners
+{
+public:
+    QMutex mutex;
+    QList<QtHarmonyPrivate::ResumePauseListener *> listeners;
+};
+}
+
+Q_GLOBAL_STATIC(ResumePauseListeners, g_resumePauseListeners)
+
+void QtHarmonyPrivate::registerResumePauseListener(ResumePauseListener *listener)
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    g_resumePauseListeners()->listeners.append(listener);
+}
+
+void QtHarmonyPrivate::unregisterResumePauseListener(ResumePauseListener *listener)
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    g_resumePauseListeners()->listeners.removeAll(listener);
+}
+
+void QtHarmonyPrivate::handlePause()
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    const QList<QtHarmonyPrivate::ResumePauseListener *> &listeners = g_resumePauseListeners()->listeners;
+    for (int i=0; i<listeners.size(); ++i)
+        listeners.at(i)->handlePause();
+}
+
+void QtHarmonyPrivate::handleResume()
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    const QList<QtHarmonyPrivate::ResumePauseListener *> &listeners = g_resumePauseListeners()->listeners;
+    for (int i=0; i<listeners.size(); ++i)
+        listeners.at(i)->handleResume();
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qopenharmonyhelpers_p.h b/src/corelib/kernel/qopenharmonyhelpers_p.h
new file mode 100644
index 0000000000..0c0bd12c64
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyhelpers_p.h
@@ -0,0 +1,43 @@
+#ifndef QOPENHARMONYHELPERS_H
+#define QOPENHARMONYHELPERS_H
+
+
+#include <functional>
+#include <QtCore/private/qglobal_p.h>
+#include <QHash>
+#include <QMetaType>
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+
+QT_BEGIN_NAMESPACE
+
+
+namespace QtHarmonyPrivate
+{
+    class Q_CORE_EXPORT ResumePauseListener
+    {
+    public:
+        virtual ~ResumePauseListener();
+        virtual void handlePause();
+        virtual void handleResume();
+    };
+
+
+    enum class PermissionsResult {
+        Granted,
+        Denied
+    };
+
+    Q_CORE_EXPORT void handlePause();
+    Q_CORE_EXPORT void handleResume();
+    Q_CORE_EXPORT void registerResumePauseListener(ResumePauseListener *listener);
+    Q_CORE_EXPORT void unregisterResumePauseListener(ResumePauseListener *listener);
+
+    Q_CORE_EXPORT napi_value variant_to_napi_value(const QVariant &value);
+
+    Q_CORE_EXPORT QVariant napi_value_to_variant(napi_value value, int t);
+}
+
+QT_END_NAMESPACE
+
+#endif // QJNIHELPERS_H
diff --git a/src/corelib/kernel/qopenharmonyjsenvironment.cpp b/src/corelib/kernel/qopenharmonyjsenvironment.cpp
new file mode 100644
index 0000000000..08f3e533ae
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsenvironment.cpp
@@ -0,0 +1,440 @@
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsfunction.h"
+
+static napi_threadsafe_function g_threadsafe_call_js_function = nullptr;
+static napi_threadsafe_function g_threadsafe_remove_object_function = nullptr;
+napi_env QOpenHarmonyJsEnvironment::m_env = nullptr;
+
+
+static void callJsFunction(napi_env env, napi_value js_cb, void* context, void* data) {
+    Q_UNUSED(env);
+    Q_UNUSED(context);
+    QOpenHarmonyJsFunction *function = (QOpenHarmonyJsFunction*)data;
+    if (function == nullptr)
+        return;
+
+    napi_value jsObject = function->attachedObject(js_cb);
+    napi_valuetype type;
+    napi_typeof(env, jsObject, &type);
+    if (type != napi_object) {
+        qWarning() << "get attached js object failed:" << function->name();
+        function->cancel();
+    }
+
+    napi_value objectFunction = qJs::function(jsObject, function->name());
+
+    function->call(jsObject, objectFunction);
+}
+
+napi_value QOpenHarmonyJsEnvironment::initJsObjectLoader(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
+
+    if (argc != 1) {
+        return createBool(false);
+    }
+
+    napi_value function = args[0];
+
+    napi_value name;
+    napi_create_string_utf8(env, "JsObjectLoader", NAPI_AUTO_LENGTH, &name);
+    napi_create_threadsafe_function(env, function, nullptr, name, 0, 1, nullptr,
+                                                          nullptr, nullptr, callJsFunction, &g_threadsafe_call_js_function);
+    if (g_threadsafe_call_js_function == nullptr)
+        return createBool(false);
+    return createBool(true);
+}
+
+
+static void callRemoveObjectFunction(napi_env env, napi_value js_cb, void* context, void* data) {
+    Q_UNUSED(env);
+    Q_UNUSED(context);
+    const char *objectName = (const char *)(data);
+
+    napi_value undefined = nullptr;
+    napi_get_undefined(qJs::env(), &undefined);
+    napi_value argv[1] = {qJs::createString(objectName)};
+    qJs::callFunction(undefined, js_cb, 1, argv);
+}
+
+napi_value QOpenHarmonyJsEnvironment::initRemoveObject(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
+
+    if (argc != 1) {
+        return createBool(false);
+    }
+
+    napi_value function = args[0];
+
+    napi_value name;
+    napi_create_string_utf8(env, "RemoveObject", NAPI_AUTO_LENGTH, &name);
+    napi_create_threadsafe_function(env, function, nullptr, name, 0, 1, nullptr,
+                                                          nullptr, nullptr, callRemoveObjectFunction, &g_threadsafe_remove_object_function);
+    if (g_threadsafe_remove_object_function == nullptr)
+        return createBool(false);
+    return createBool(true);
+}
+
+void QOpenHarmonyJsEnvironment::init(napi_env env)
+{
+    m_env = env;
+}
+
+void QOpenHarmonyJsEnvironment::throwError(const QString &errorMessage)
+{
+    QByteArray _data = errorMessage.toUtf8();
+    napi_throw_type_error(m_env, NULL, _data.constData());
+}
+
+napi_value QOpenHarmonyJsEnvironment::createString(const QString &value)
+{
+    QByteArray text = value.toUtf8();
+    const char *textData = text.constData();
+    return createString(textData);
+}
+
+napi_value QOpenHarmonyJsEnvironment::createStringArray(const QStringList &strList)
+{
+    napi_value result = nullptr;
+    if (napi_ok == napi_create_array(m_env, &result)) {
+        for (int k = 0; k < strList.count(); ++k) {
+            napi_set_element(m_env, result, k, createString(strList.at(k)));
+        }
+    }
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createArrayBuffer(const QByteArray &buffer)
+{
+    napi_value result = nullptr;
+    void *data = nullptr;
+    NAPI_CALL_BASE(m_env, napi_create_arraybuffer(m_env, buffer.length(), &data, &result), nullptr);
+    memcpy(data, buffer.data(), buffer.length());
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createObject(const QVariantMap &map)
+{
+    napi_value result = nullptr;
+    NAPI_CALL_BASE(m_env, napi_create_object(m_env, &result), nullptr);
+    for (auto i = map.cbegin(); i != map.cend(); ++i){
+        napi_value name = createString(i.key());
+        napi_value v = QtHarmonyPrivate::variant_to_napi_value(i.value());
+        napi_set_property(m_env, result, name, v);
+    }
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::globalObject() {
+    napi_value _global;
+    NAPI_CALL(m_env, napi_get_global(m_env, &_global));
+    return _global;
+}
+
+napi_value QOpenHarmonyJsEnvironment::callFunction(napi_value object, napi_value function, int argc, const napi_value *argv)
+{
+    napi_value return_value;
+    NAPI_CALL(m_env, napi_call_function(m_env, object, function, argc, argv, &return_value));
+    return return_value;
+}
+
+void QOpenHarmonyJsEnvironment::callThreadSafeFunction(QOpenHarmonyJsFunction *func)
+{
+    napi_acquire_threadsafe_function(g_threadsafe_call_js_function);
+    napi_call_threadsafe_function(g_threadsafe_call_js_function, func, napi_tsfn_blocking);
+}
+
+void QOpenHarmonyJsEnvironment::threadSafeRemoveObject(const QString &objectName)
+{
+    napi_acquire_threadsafe_function(g_threadsafe_remove_object_function);
+    QByteArray dataArray = objectName.toLatin1();
+    char *_data = dataArray.data();
+    napi_call_threadsafe_function(g_threadsafe_remove_object_function, (void *)_data, napi_tsfn_blocking);
+}
+
+QString QOpenHarmonyJsEnvironment::getString(napi_value value)
+{
+    size_t strLen = 0;
+    NAPI_CALL_BASE(m_env, napi_get_value_string_utf8(m_env, value, nullptr, -1, &strLen), QString());
+    size_t bufLen = strLen + 1;
+    std::unique_ptr<char[]> strBuffer = std::make_unique<char[]>(bufLen);
+    NAPI_CALL_BASE(m_env, napi_get_value_string_utf8(m_env, value, strBuffer.get(), bufLen, &strLen), QString());
+    QString str = QString::fromUtf8(strBuffer.get());
+    return str;
+}
+
+QList<int> QOpenHarmonyJsEnvironment::getNumbers(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QList<int>());
+    if (!result)
+        return QList<int>();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QList<int>());
+    QList<int> ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getInt32(temp);
+    }
+    return ret;
+}
+
+QList<double> QOpenHarmonyJsEnvironment::getRealNumbers(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QList<double>());
+    if (!result)
+        return QList<double>();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QList<double>());
+    QList<double> ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getDouble(temp);
+    }
+    return ret;
+}
+
+QStringList QOpenHarmonyJsEnvironment::getStringList(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QStringList());
+    if (!result)
+        return QStringList();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QStringList());
+    QStringList ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getString(temp);
+    }
+    return ret;
+}
+
+QByteArray QOpenHarmonyJsEnvironment::getByteArray(napi_value value)
+{
+    bool isArraryBuffer = false;
+    NAPI_CALL_BASE(m_env, napi_is_arraybuffer(m_env, value, &isArraryBuffer), QByteArray());
+    if (!isArraryBuffer) {
+        return QByteArray();
+    }
+    void *data = nullptr;
+    size_t lenght = 0;
+    NAPI_CALL_BASE(m_env, napi_get_arraybuffer_info(m_env, value, &data, &lenght), QByteArray());
+    QByteArray result = QByteArray((char*)(data), lenght);
+    return result;
+}
+
+QByteArrayList QOpenHarmonyJsEnvironment::getByteArrayList(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QByteArrayList());
+    if (!result)
+        return QByteArrayList();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QByteArrayList());
+    QByteArrayList ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getByteArray(temp);
+    }
+    return ret;
+}
+
+
+//QVariantMap QOpenHarmonyJsEnvironment::getMap(napi_value value)
+//{
+//    napi_value names;
+//    NAPI_CALL_BASE(m_env, napi_get_property_names(m_env, value, &names), QVariantMap());
+//    QByteArrayList nameList = getByteArrayList(names);
+//    if (nameList.isEmpty())
+//        return QVariantMap();
+//    QVariantMap ret;
+//    for (int i = 0; i < nameList.count(); ++i) {
+//        napi_value result = nullptr;
+//        QByteArray name = nameList.at(i);
+//        napi_get_named_property(m_env, value, name.constData(), &result);
+////        napi_valuetype valueType;
+////        napi_typeof(m_env, value, &valueType);
+////        if (valueType == napi_number)
+////            return 0;
+//    }
+//    return ret;
+//}
+
+bool QOpenHarmonyJsEnvironment::getBool(napi_value value)
+{
+    bool result;
+    NAPI_CALL_BASE(m_env, napi_get_value_bool(m_env, value, &result), false);
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::objectPropertyValue(napi_value object, const QString &name)
+{
+    napi_value result = nullptr;
+    QByteArray data = name.toUtf8();
+    NAPI_CALL(m_env, napi_get_named_property(m_env, object, data.constData(), &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createString(const char *value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_create_string_utf8(m_env, value, NAPI_AUTO_LENGTH, &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createBool(bool value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_get_boolean(m_env, value, &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createInt32(int value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_create_int32(m_env, value, &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createInt64(qlonglong value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_create_int64(m_env, value, &result));
+    return result;
+}
+
+int64_t QOpenHarmonyJsEnvironment::getInt64(napi_value value)
+{
+    int64_t result;
+    NAPI_CALL_BASE(m_env, napi_get_value_int64(m_env, value, &result), 0);
+    return result;
+}
+
+int32_t QOpenHarmonyJsEnvironment::getInt32(napi_value value)
+{
+    int32_t result;
+    NAPI_CALL_BASE(m_env, napi_get_value_int32(m_env, value, &result), 0);
+    return result;
+}
+
+double QOpenHarmonyJsEnvironment::getDouble(napi_value value)
+{
+//    napi_valuetype valueType;
+//    napi_typeof(m_env, value, &valueType);
+//    if (valueType != napi_number)
+//        return 0;
+    double result;
+    NAPI_CALL_BASE(m_env, napi_get_value_double(m_env, value, &result), 0);
+    return result;
+}
+
+template<>
+void QOpenHarmonyJsEnvironment::getObjectPropertyValue<void>(napi_value object, const QString &propertyName)
+{
+
+}
+
+template<>
+QByteArray QOpenHarmonyJsEnvironment::getObjectPropertyValue<QByteArray>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getByteArray(value);
+}
+
+template<>
+QString QOpenHarmonyJsEnvironment::getObjectPropertyValue<QString>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getString(value);
+}
+
+template<>
+bool QOpenHarmonyJsEnvironment::getObjectPropertyValue<bool>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getBool(value);
+}
+
+template<>
+int64_t QOpenHarmonyJsEnvironment::getObjectPropertyValue<int64_t>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getInt64(value);
+}
+
+template<>
+int32_t QOpenHarmonyJsEnvironment::getObjectPropertyValue<int32_t>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getInt32(value);
+}
+
+template<>
+double QOpenHarmonyJsEnvironment::getObjectPropertyValue<double>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getDouble(value);
+}
+
+template<>
+void *QOpenHarmonyJsEnvironment::getValue<void *>(napi_value value)
+{
+    return value;
+}
+
+template<>
+QByteArray QOpenHarmonyJsEnvironment::getValue<QByteArray>(napi_value value)
+{
+    return getByteArray(value);
+}
+
+template<>
+QString QOpenHarmonyJsEnvironment::getValue<QString>(napi_value value)
+{
+    return getString(value);
+}
+
+template<>
+bool QOpenHarmonyJsEnvironment::getValue<bool>(napi_value value)
+{
+    return getBool(value);
+}
+
+template<>
+int64_t QOpenHarmonyJsEnvironment::getValue<int64_t>(napi_value value)
+{
+    return getInt64(value);
+}
+
+template<>
+int32_t QOpenHarmonyJsEnvironment::getValue<int32_t>(napi_value value)
+{
+    return getInt32(value);
+}
+
+template<>
+double QOpenHarmonyJsEnvironment::getValue<double>(napi_value value)
+{
+    return getDouble(value);
+}
diff --git a/src/corelib/kernel/qopenharmonyjsenvironment.h b/src/corelib/kernel/qopenharmonyjsenvironment.h
new file mode 100644
index 0000000000..6aa55a9ade
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsenvironment.h
@@ -0,0 +1,119 @@
+#ifndef QOPENHARMONYJSENVIRONMENT_H
+#define QOPENHARMONYJSENVIRONMENT_H
+
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+
+QT_BEGIN_NAMESPACE
+#define qJs QOpenHarmonyJsEnvironment
+class QOpenHarmonyJsFunction;
+
+class Q_CORE_EXPORT QOpenHarmonyJsEnvironment
+{
+public:
+    QOpenHarmonyJsEnvironment();
+    ~QOpenHarmonyJsEnvironment();
+
+    static void init(napi_env env);
+
+    static void throwError(const QString &errorMessage);
+
+    static napi_env env() { return m_env; }
+
+    static napi_value createString(const char *value);
+
+    static napi_value createString(const QString &value);
+
+    static napi_value createBool(bool value);
+
+    static napi_value createInt32(int value);
+
+    static napi_value createInt64(qlonglong value);
+
+    static napi_value createStringArray(const QStringList &strList);
+
+    static napi_value createArrayBuffer(const QByteArray &buffer);
+
+    static napi_value createObject(const QVariantMap &map);
+
+    static napi_value globalObject();
+
+    static napi_value globalThis()
+    {
+        return objectPropertyValue(globalObject(), QLatin1String("globalThis"));
+    }
+
+    static napi_value jsObject(const QString &name)
+    {
+        return objectPropertyValue(globalThis(), name);
+    }
+
+    static napi_value function(napi_value jsObject, const QString &functionName)
+    {
+        return objectPropertyValue(jsObject, functionName);
+    }
+
+    template<typename T>
+    static T getObjectPropertyValue(napi_value object, const QString &propertyName);
+
+    template<typename T>
+    static T getValue(napi_value value);
+
+    static napi_value callFunction(napi_value object, napi_value function, int argc = 0, const napi_value *argv = nullptr);
+
+    static void callThreadSafeFunction(QOpenHarmonyJsFunction *func);
+    static void threadSafeRemoveObject(const QString &objectName);
+
+    static QString getString(napi_value value);
+
+    static QList<int> getNumbers(napi_value value);
+    static QList<double> getRealNumbers(napi_value value);
+
+    static QStringList getStringList(napi_value value);
+
+    static QByteArray getByteArray(napi_value value);
+
+    static QByteArrayList getByteArrayList(napi_value value);
+
+    static bool getBool(napi_value value);
+
+    static int64_t getInt64(napi_value value);
+
+    static int32_t getInt32(napi_value value);
+
+    static double getDouble(napi_value value);
+
+    static napi_value objectPropertyValue(napi_value object, const QString &propertyName);
+
+    static napi_value initJsObjectLoader(napi_env env, napi_callback_info info);
+    static napi_value initRemoveObject(napi_env env, napi_callback_info info);
+private:
+    static napi_env m_env;
+};
+
+template<>
+inline QList<int> QOpenHarmonyJsEnvironment::getValue<QList<int>>(napi_value value)
+{
+    return getNumbers(value);
+}
+
+template<>
+inline QList<double> QOpenHarmonyJsEnvironment::getValue(napi_value value)
+{
+    return getRealNumbers(value);
+}
+
+template<>
+inline QByteArrayList QOpenHarmonyJsEnvironment::getValue<QByteArrayList>(napi_value value)
+{
+    return getByteArrayList(value);
+}
+
+template<>
+inline QStringList QOpenHarmonyJsEnvironment::getValue<QStringList>(napi_value value)
+{
+    return getStringList(value);
+}
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYJSENVIRONMENT_H
diff --git a/src/corelib/kernel/qopenharmonyjsfunction.cpp b/src/corelib/kernel/qopenharmonyjsfunction.cpp
new file mode 100644
index 0000000000..fef0a00e55
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsfunction.cpp
@@ -0,0 +1,199 @@
+#include "qopenharmonyjsfunction.h"
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsobject.h"
+
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qmetaobject.h>
+#include <QtCore/qthread.h>
+#include <QtCore/qelapsedtimer.h>
+#include <QtCore/qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsFunctionPrivate
+{
+public:
+    QOpenHarmonyJsFunctionPrivate();
+    void init(napi_value function, const QString &functionName);
+    QString jsObject() const;
+    const QVariantList &args() const;
+    static napi_value then(napi_env, napi_callback_info info);
+
+    void setResult(napi_value result);
+    void wait(int timeout = 5000);
+
+    bool hasResult() const;
+
+    QOpenHarmonyJsFunction *q_ptr;
+    QString m_name;
+    QVariantList m_args;
+    QOpenHarmonyJsObject *m_jsObject;
+    QVariant m_result;
+    int m_resultType;
+    QBasicAtomicInt m_bResultReceived; // bool
+};
+
+QOpenHarmonyJsFunctionPrivate::QOpenHarmonyJsFunctionPrivate() 
+    : m_resultType(QVariant::Invalid)
+{
+    m_bResultReceived.storeRelease(false);
+}
+
+
+const QVariantList &QOpenHarmonyJsFunctionPrivate::args() const
+{
+    return m_args;
+}
+
+QString QOpenHarmonyJsFunctionPrivate::jsObject() const
+{
+    return m_jsObject->name();
+}
+
+void QOpenHarmonyJsFunctionPrivate::wait(int timeout)
+{    
+    QElapsedTimer start;
+    start.start();
+    while (!m_bResultReceived.loadAcquire()) {
+        if (start.elapsed() > timeout)
+            break;
+    }
+    if (!m_bResultReceived.loadAcquire()) {
+        qWarning() << QString("Wait js method %1 result failded").arg(m_name);
+    }
+}
+
+bool QOpenHarmonyJsFunctionPrivate::hasResult() const
+{
+    return m_resultType != QVariant::Invalid;
+}
+
+napi_value QOpenHarmonyJsFunctionPrivate::then(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value argv[1] = {nullptr};
+    void *data = nullptr;
+    napi_get_cb_info(env, info, &argc, argv, nullptr, &data);
+    QOpenHarmonyJsFunctionPrivate *function = reinterpret_cast<QOpenHarmonyJsFunctionPrivate *>(data);
+    if (function != nullptr)
+        function->setResult(argv[0]);
+    return argv[0];
+}
+
+void QOpenHarmonyJsFunctionPrivate::setResult(napi_value result)
+{
+    m_result = QtHarmonyPrivate::napi_value_to_variant(result, m_resultType);
+    if (m_result.type() == QVariant::ByteArray) {
+        qDebug() << QString("Get js method %1 result from callback QByteArrary length: %2").arg(m_name).arg(m_result.toByteArray().length());
+    } else {
+        qDebug() << QString("Get js method %1 result from callback:").arg(m_name) << m_result;
+    }
+    m_bResultReceived.storeRelease(true);
+}
+
+QOpenHarmonyJsFunction::QOpenHarmonyJsFunction(const QOpenHarmonyJsObject *jsObject, const QString &functionName)
+{
+    d_ptr.reset(new QOpenHarmonyJsFunctionPrivate);
+    d_ptr->q_ptr = this;
+    d_ptr->m_jsObject = const_cast<QOpenHarmonyJsObject *>(jsObject);
+    d_ptr->m_name = functionName;
+}
+
+void QOpenHarmonyJsFunction::call(napi_value jsObject, napi_value function)
+{
+    Q_D(QOpenHarmonyJsFunction);
+    const QVariantList &args = d->args();
+
+    napi_value result = nullptr;
+    if (args.isEmpty()) {
+        result = qJs::callFunction(jsObject, function);
+    }
+    else {
+        size_t argc = static_cast<size_t>(args.count());
+        QScopedArrayPointer<napi_value> argv(new napi_value[argc]);
+        for (int i = 0; i < args.count(); ++i) {
+            argv[i] = nullptr;
+            argv[i] = QtHarmonyPrivate::variant_to_napi_value(args.at(i));
+        }
+        result = qJs::callFunction(jsObject, function, argc, argv.get());
+    }
+    if (!d->hasResult())
+        return;
+    bool is_promise = false;
+    napi_is_promise(qJs::env(), result, &is_promise);
+    napi_valuetype type;
+    napi_typeof(qJs::env(), result, &type);
+    qDebug() << "the result type is" << type << "the result is promise:" << is_promise;
+    if (is_promise) {
+        napi_value then = qJs::objectPropertyValue(result, "then");
+        napi_value func = nullptr;
+        napi_create_function(qJs::env(), "thenResult", 1, QOpenHarmonyJsFunctionPrivate::then, d, &func);
+        napi_value _argv[1] = {func};
+        //trigger then method
+        result = qJs::callFunction(result, then, 1, _argv);
+    } else {
+        d->setResult(result);
+    }
+}
+
+QOpenHarmonyJsFunction::~QOpenHarmonyJsFunction()
+{
+
+}
+
+void QOpenHarmonyJsFunction::call(const QVariantList &args)
+{    
+    d_ptr->m_bResultReceived.storeRelease(false);
+    d_ptr->m_args = args;
+    bool printArgs = !args.isEmpty();
+    for (int i = 0 ;i < args.count(); ++i) {
+        if (args.at(i).type() == QMetaType::QByteArray) {
+            printArgs = false;
+            break;
+        }
+    }
+    if (printArgs) {
+        qDebug() << QString("call js function: %1").arg(d_ptr->m_name) << args;
+    } else {
+        qDebug() << QString("call js function: %1").arg(d_ptr->m_name);
+    }
+
+    qJs::callThreadSafeFunction(this);
+    if (!d_ptr->hasResult()) {
+        // 
+        return;
+    }
+    d_ptr->wait();
+}
+
+QVariant QOpenHarmonyJsFunction::jsResult() const
+{
+    return d_ptr->m_result;
+}
+
+napi_value QOpenHarmonyJsFunction::attachedObject(napi_value objectLoader) const
+{
+    Q_D(const QOpenHarmonyJsFunction);
+    return d->m_jsObject->jsObject(objectLoader);
+}
+
+QString QOpenHarmonyJsFunction::name() const
+{
+    Q_D(const QOpenHarmonyJsFunction);
+    return d->m_name;
+}
+
+void QOpenHarmonyJsFunction::cancel()
+{
+    Q_D(QOpenHarmonyJsFunction);
+    d->m_bResultReceived.storeRelease(true);
+}
+
+void QOpenHarmonyJsFunction::setResultType(int t)
+{
+    d_ptr->m_resultType = t;
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qopenharmonyjsfunction.h b/src/corelib/kernel/qopenharmonyjsfunction.h
new file mode 100644
index 0000000000..01a0e09651
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsfunction.h
@@ -0,0 +1,79 @@
+#ifndef QOPENHARMONYJSFUNCTION_H
+#define QOPENHARMONYJSFUNCTION_H
+
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qeventloop.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qopenharmonyjsenvironment.h>
+#include <QtCore/qobject.h>
+#include <QtCore/qtimer.h>
+#include <QDebug>
+QT_BEGIN_NAMESPACE
+class QOpenHarmonyJsObject;
+class QOpenHarmonyJsFunctionPrivate;
+
+class Q_CORE_EXPORT QOpenHarmonyJsFunction
+{
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsFunction)
+public:
+    ~QOpenHarmonyJsFunction();
+
+    template<typename RET, typename... Args>
+    void call(Args&&... args)
+    {
+        QVariantList params;
+        setResultType(qMetaTypeId<RET>());
+        call(packParams(params, std::forward<Args>(args)...));
+    }
+
+    template<typename... Args>
+    void call(Args&&... args)
+    {
+        QVariantList params;
+        call(packParams(params, std::forward<Args>(args)...));
+    }
+
+    void call(const QVariantList &args);
+
+    template<typename RETURN_TYPE>
+    RETURN_TYPE result() const;
+
+    QVariant jsResult() const;
+
+    napi_value attachedObject(napi_value objectLoader) const;
+    QString name() const;
+    void cancel();
+    void call(napi_value jsObject, napi_value function);
+private:
+    template<typename Arg0, typename... Args>
+    const QVariantList &packParams(QVariantList& paramList, Arg0&& arg, Args&&... args)
+    {
+        QVariant v;
+        v.setValue(std::forward<Arg0>(arg));
+        paramList.push_back(v);
+        packParams(paramList, std::forward<Args>(args)...);
+        return paramList;
+    }
+
+    const QVariantList& packParams(QVariantList& paramList)
+    {
+        return paramList;
+    }
+
+    void setResultType(int t);
+
+    friend class QOpenHarmonyJsObject;
+    QOpenHarmonyJsFunction(const QOpenHarmonyJsObject *jsObject, const QString &functionName);
+
+    QScopedPointer<QOpenHarmonyJsFunctionPrivate> d_ptr;
+};
+
+template<typename RET>
+RET QOpenHarmonyJsFunction::result() const
+{
+    return jsResult().value<RET>();
+}
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYJSFUNCTION_H
diff --git a/src/corelib/kernel/qopenharmonyjsobject.cpp b/src/corelib/kernel/qopenharmonyjsobject.cpp
new file mode 100644
index 0000000000..9bebe7af3d
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobject.cpp
@@ -0,0 +1,101 @@
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyjsfunction.h"
+#include "qopenharmonyjsobjectpool.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsenvironment.h"
+
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectPrivate
+{
+    QOpenHarmonyJsObject *q_ptr;
+    Q_DECLARE_PUBLIC(QOpenHarmonyJsObject)
+public:
+    QOpenHarmonyJsObjectPrivate(const QString &objectType, const QString &objectName, const QVariantList &constructArgs);
+    virtual ~QOpenHarmonyJsObjectPrivate();
+    QOpenHarmonyJsFunction *createJsFunction(const QString &jsFunction);
+
+    QString m_objectType;
+    QString m_objectName;
+    QVariantList m_constructArgs;
+    QHash<QString, QOpenHarmonyJsFunction *> m_functions;
+};
+
+QOpenHarmonyJsObject::QOpenHarmonyJsObject(const QString &objectType, const QString &objectName, const QVariantList &constructArgs)
+    : d_ptr(new QOpenHarmonyJsObjectPrivate(objectType, objectName, constructArgs))
+{
+    d_ptr->q_ptr = this;
+}
+
+QOpenHarmonyJsObject::~QOpenHarmonyJsObject()
+{
+
+}
+
+bool QOpenHarmonyJsObject::isValid() const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    return !d->m_objectName.isEmpty();
+}
+
+QOpenHarmonyJsFunction *QOpenHarmonyJsObject::getJsFunction(const QString &name) const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    if (d->m_functions.contains(name))
+        return d->m_functions.value(name);
+    QOpenHarmonyJsFunction *function = new QOpenHarmonyJsFunction(this, name);
+    const_cast<QOpenHarmonyJsObjectPrivate *>(d)->m_functions.insert(name, function);
+    return function;
+}
+
+const QString QOpenHarmonyJsObject::name() const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    return d->m_objectName;
+}
+
+void QOpenHarmonyJsObject::removeSelf()
+{
+    Q_D(QOpenHarmonyJsObject);
+    qJs::threadSafeRemoveObject(d->m_objectName);
+    delete this;
+}
+
+napi_value QOpenHarmonyJsObject::jsObject(napi_value objectLoader) const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    size_t argc = 1 + 1 + static_cast<size_t>(d->m_constructArgs.count());
+    QScopedArrayPointer<napi_value> argv(new napi_value[argc]);
+    argv[0] = qJs::createString(d->m_objectType);
+    argv[1] = qJs::createString(d->m_objectName);
+    if (!d->m_constructArgs.isEmpty()) {
+        for (int i = 0; i < d->m_constructArgs.count(); ++i) {
+            argv[i + 2] = nullptr;
+            argv[i + 2] = QtHarmonyPrivate::variant_to_napi_value(d->m_constructArgs.at(i));
+        }
+    }
+    napi_value undefined = nullptr;
+    napi_get_undefined(qJs::env(), &undefined);
+    return qJs::callFunction(undefined, objectLoader, argc, argv.get());
+}
+
+
+QOpenHarmonyJsObjectPrivate::QOpenHarmonyJsObjectPrivate(const QString &objectType, const QString &objectName, const QVariantList &constructArgs)
+    : m_objectType(objectType)
+    , m_objectName(objectName)
+    , m_constructArgs(constructArgs)
+{
+
+}
+
+QOpenHarmonyJsObjectPrivate::~QOpenHarmonyJsObjectPrivate()
+{
+    qDeleteAll(m_functions);
+    m_functions.clear();
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/corelib/kernel/qopenharmonyjsobject.h b/src/corelib/kernel/qopenharmonyjsobject.h
new file mode 100644
index 0000000000..a33a46cc6b
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobject.h
@@ -0,0 +1,67 @@
+#ifndef QOPENHARMONYJSOBJECT_H
+#define QOPENHARMONYJSOBJECT_H
+
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qeventloop.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qopenharmonyjsfunction.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qscopedpointer.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectPrivate;
+
+class Q_CORE_EXPORT QOpenHarmonyJsObject
+{
+    friend class QOpenHarmonyJsObjectPool;
+    friend class QOpenHarmonyJsFunction;
+    friend class QSharedPointer<QOpenHarmonyJsObject>;
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsObject)
+public:
+    virtual ~QOpenHarmonyJsObject();
+
+    bool isValid() const;
+
+    template<typename RET, typename... Args>
+    RET call(const QString &jsFunction, Args&&... args);
+
+    template<typename... Args>
+    void call(const QString &jsFunction, Args&&... args)
+    {
+        QOpenHarmonyJsFunction *f = getJsFunction(jsFunction);
+        if (f == nullptr)
+            return;
+        f->call(std::forward<Args>(args)...);
+    }
+
+    QOpenHarmonyJsFunction *getJsFunction(const QString &name) const;
+
+    const QString name() const;
+
+    void removeSelf();
+private:
+    Q_DISABLE_COPY(QOpenHarmonyJsObject)
+    QOpenHarmonyJsObject(const QString &objectType, const QString &objectName = QString(), const QVariantList &constructArgs = QVariantList());
+    void initFunctions(const QStringList &functions);
+
+    napi_value jsObject(napi_value objectLoader) const;
+
+    QScopedPointer<QOpenHarmonyJsObjectPrivate> d_ptr;
+};
+
+template<typename RET, typename... Args>
+RET QOpenHarmonyJsObject::call(const QString &jsFunction, Args&&... args)
+{
+    QOpenHarmonyJsFunction *f = getJsFunction(jsFunction);
+    if (f == nullptr)
+        return RET();
+
+    f->call<RET>(std::forward<Args>(args)...);
+    return f->result<RET>();
+}
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/corelib/kernel/qopenharmonyjsobjectloader.cpp b/src/corelib/kernel/qopenharmonyjsobjectloader.cpp
new file mode 100644
index 0000000000..80173b713f
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectloader.cpp
@@ -0,0 +1,54 @@
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonyjsobjectpool.h"
+
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qmap.h>
+
+Q_GLOBAL_STATIC(QOpenHarmonyJsObjectLoader, loader)
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectLoaderPrivate
+{
+    Q_DECLARE_PUBLIC(QOpenHarmonyJsObjectLoader)
+public:
+    QOpenHarmonyJsObjectLoader *q_ptr;
+};
+
+QOpenHarmonyJsObjectLoader::QOpenHarmonyJsObjectLoader()
+{
+    d_ptr.reset(new QOpenHarmonyJsObjectLoaderPrivate);
+    d_ptr->q_ptr = this;
+}
+
+QOpenHarmonyJsObjectLoader::~QOpenHarmonyJsObjectLoader()
+{
+
+}
+
+QOpenHarmonyJsObjectLoader *QOpenHarmonyJsObjectLoader::instance()
+{
+    return loader();
+}
+
+QSharedPointer<QOpenHarmonyJsObject> QOpenHarmonyJsObjectLoader::create(const QString &objectType, const QString &objectName, const QVariantList &params)
+{
+    qDebug() << "request js object: " << objectType << objectName;
+    if (objectType.isEmpty())
+        return QSharedPointer<QOpenHarmonyJsObject>();
+
+    QString _objectName = objectName;
+    if (_objectName.isEmpty())
+        _objectName = objectType;
+    return qJsObjectPool->findOrCreate(objectType, _objectName, params);
+}
+
+void QOpenHarmonyJsObjectLoader::remove(const QString &name)
+{
+    qJsObjectPool->remove(name);
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/corelib/kernel/qopenharmonyjsobjectloader.h b/src/corelib/kernel/qopenharmonyjsobjectloader.h
new file mode 100644
index 0000000000..98f74e4f99
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectloader.h
@@ -0,0 +1,33 @@
+#ifndef QOPENHARMONYJSOBJECTLOADER_H
+#define QOPENHARMONYJSOBJECTLOADER_H
+
+#include <QtCore/qstring.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qsharedpointer.h>
+
+QT_BEGIN_NAMESPACE
+
+#define qJsObjectLoader QOpenHarmonyJsObjectLoader::instance()
+
+class QOpenHarmonyJsObject;
+class QOpenHarmonyJsObjectLoaderPrivate;
+
+class Q_CORE_EXPORT QOpenHarmonyJsObjectLoader
+{
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsObjectLoader)
+public:
+    QOpenHarmonyJsObjectLoader();
+    virtual ~QOpenHarmonyJsObjectLoader();
+
+    static QOpenHarmonyJsObjectLoader *instance();
+
+    QSharedPointer<QOpenHarmonyJsObject> create(const QString &objectType, const QString &objectName = QString(), const QVariantList &params = QVariantList());
+
+    void remove(const QString &name);
+private:
+    QScopedPointer<QOpenHarmonyJsObjectLoaderPrivate> d_ptr;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/corelib/kernel/qopenharmonyjsobjectpool.cpp b/src/corelib/kernel/qopenharmonyjsobjectpool.cpp
new file mode 100644
index 0000000000..233fa09a2f
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectpool.cpp
@@ -0,0 +1,63 @@
+#include "qopenharmonyjsobjectpool.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyjsfunction.h"
+#include "qopenharmonyjsobject.h"
+
+
+Q_GLOBAL_STATIC(QOpenHarmonyJsObjectPool, pool)
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectPoolPrivate
+{
+    Q_DECLARE_PUBLIC(QOpenHarmonyJsObjectPool)
+
+    QOpenHarmonyJsObjectPool *q_ptr;
+
+    QHash<QString, QSharedPointer<QOpenHarmonyJsObject>> m_jsObjects;
+
+    QSharedPointer<QOpenHarmonyJsObject> add(const QString &objectType, const QString &objectName, const QVariantList &constructArgs);
+};
+
+QOpenHarmonyJsObjectPool::QOpenHarmonyJsObjectPool()
+    : d_ptr(new QOpenHarmonyJsObjectPoolPrivate)
+{
+    d_ptr->q_ptr = this;
+}
+
+QOpenHarmonyJsObjectPool::~QOpenHarmonyJsObjectPool()
+{
+
+}
+
+QOpenHarmonyJsObjectPool *QOpenHarmonyJsObjectPool::instance()
+{
+    return pool();
+}
+
+QSharedPointer<QOpenHarmonyJsObject> QOpenHarmonyJsObjectPoolPrivate::add(const QString &objectType, const QString &objectName, const QVariantList &constructArgs)
+{
+    QSharedPointer<QOpenHarmonyJsObject> object = QSharedPointer<QOpenHarmonyJsObject>::create(objectType, objectName, constructArgs);
+    m_jsObjects.insert(objectName, object);
+    return object;
+}
+
+bool QOpenHarmonyJsObjectPool::remove(const QString &name)
+{
+    Q_D(QOpenHarmonyJsObjectPool);
+    if (d->m_jsObjects.contains(name)) {
+         QSharedPointer<QOpenHarmonyJsObject> object = d->m_jsObjects.take(name);
+         object->removeSelf();
+    }
+}
+
+QSharedPointer<QOpenHarmonyJsObject> QOpenHarmonyJsObjectPool::findOrCreate(const QString &objectType, const QString &objectName, const QVariantList &constructArgs)
+{
+    Q_D(QOpenHarmonyJsObjectPool);
+    QSharedPointer<QOpenHarmonyJsObject> result = d->m_jsObjects.value(objectName);
+    if (result.isNull())
+        return d->add(objectType, objectType, constructArgs);
+    return result;
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qopenharmonyjsobjectpool.h b/src/corelib/kernel/qopenharmonyjsobjectpool.h
new file mode 100644
index 0000000000..b11ba62617
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectpool.h
@@ -0,0 +1,37 @@
+#ifndef QOPENHARMONYJSOBJECTPOOL_H
+#define QOPENHARMONYJSOBJECTPOOL_H
+
+#include <napi/native_api.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qsharedpointer.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qeventloop.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qopenharmonyjsfunction.h>
+#include <QtCore/qtimer.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObject;
+
+class QOpenHarmonyJsObjectPoolPrivate;
+
+#define qJsObjectPool QOpenHarmonyJsObjectPool::instance()
+
+class QOpenHarmonyJsObjectPool
+{
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsObjectPool)
+public:
+    QOpenHarmonyJsObjectPool();
+    virtual ~QOpenHarmonyJsObjectPool();
+
+    static QOpenHarmonyJsObjectPool *instance();
+
+    bool remove(const QString &name);
+
+    QSharedPointer<QOpenHarmonyJsObject> findOrCreate(const QString &objectType, const QString &objectName = QString(), const QVariantList &constructArgs = QVariantList());
+private:
+    QScopedPointer<QOpenHarmonyJsObjectPoolPrivate> d_ptr;
+};
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/corelib/kernel/qopenharmonyload.cpp b/src/corelib/kernel/qopenharmonyload.cpp
new file mode 100644
index 0000000000..304bfb9923
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyload.cpp
@@ -0,0 +1,50 @@
+#include <napi/native_api.h>
+#include <hilog/log.h>
+
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyjsobjectpool.h"
+
+/*
+ * function for module exports
+ */
+EXTERN_C_START
+static napi_value Init(napi_env env, napi_value exports)
+{
+    static bool initialized = false;
+    if (initialized)
+        return exports;
+
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("initJsObjectLoader", QOpenHarmonyJsEnvironment::initJsObjectLoader),
+        DECLARE_NAPI_FUNCTION("initRemoveObjectFunction", QOpenHarmonyJsEnvironment::initRemoveObject),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+
+    initialized = true;
+    LOGI("init in qt core");
+    qJs::init(env);
+    return exports;
+}
+EXTERN_C_END
+
+/*
+ * Napi Module define
+ */
+static napi_module openharmonyQtCoreModule = {
+    .nm_version = 1,
+    .nm_flags = 0,
+    .nm_filename = nullptr,
+    .nm_register_func = Init,
+    .nm_modname = "Qt5Core",
+    .nm_priv = ((void*)0),
+    .reserved = { 0 },
+};
+/*
+ * Module register function
+ */
+extern "C" __attribute__((constructor)) void RegisterModule(void)
+{
+    napi_module_register(&openharmonyQtCoreModule);
+}
diff --git a/src/corelib/plugin/qfactoryloader.cpp b/src/corelib/plugin/qfactoryloader.cpp
index 582f48e93e..d9032f61ed 100644
--- a/src/corelib/plugin/qfactoryloader.cpp
+++ b/src/corelib/plugin/qfactoryloader.cpp
@@ -196,10 +196,10 @@ void QFactoryLoader::update()
             continue;
         d->loadedPaths << pluginDir;
 
-#ifdef Q_OS_ANDROID
+#if defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
         QString path = pluginDir;
 #else
-        QString path = pluginDir + d->suffix;
+        QString path = pluginDir + d->suffix;        
 #endif
 
         if (qt_debug_component())
@@ -211,10 +211,10 @@ void QFactoryLoader::update()
         QStringList plugins = QDir(path).entryList(
 #if defined(Q_OS_WIN)
                     QStringList(QStringLiteral("*.dll")),
-#elif defined(Q_OS_ANDROID)
+#elif defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
                     QStringList(QLatin1String("libplugins_%1_*.so").arg(d->suffix)),
 #endif
-                    QDir::Files);
+                    QDir::Files);        
         QLibraryPrivate *library = nullptr;
 
         for (int j = 0; j < plugins.count(); ++j) {
@@ -349,9 +349,9 @@ QFactoryLoader::QFactoryLoader(const char *iid,
 #if QT_CONFIG(library)
     d->cs = cs;
     d->suffix = suffix;
-# ifdef Q_OS_ANDROID
+#if defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
     if (!d->suffix.isEmpty() && d->suffix.at(0) == QLatin1Char('/'))
-        d->suffix.remove(0, 1);
+        d->suffix.remove(0, 1);    
 # endif
 
     QMutexLocker locker(qt_factoryloader_mutex());
diff --git a/src/corelib/thread/qthread_unix.cpp b/src/corelib/thread/qthread_unix.cpp
index a27782d37c..f900b4eb5c 100644
--- a/src/corelib/thread/qthread_unix.cpp
+++ b/src/corelib/thread/qthread_unix.cpp
@@ -302,7 +302,7 @@ void terminate_on_exception(T &&t)
 
 void *QThreadPrivate::start(void *arg)
 {
-#if !defined(Q_OS_ANDROID)
+#if !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
     pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, nullptr);
 #endif
     pthread_cleanup_push(QThreadPrivate::finish, arg);
@@ -343,7 +343,7 @@ void *QThreadPrivate::start(void *arg)
 #endif
 
         emit thr->started(QThread::QPrivateSignal());
-#if !defined(Q_OS_ANDROID)
+#if !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
         pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, nullptr);
         pthread_testcancel();
 #endif
@@ -721,7 +721,7 @@ void QThread::start(Priority priority)
 
 void QThread::terminate()
 {
-#if !defined(Q_OS_ANDROID)
+#if !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
     Q_D(QThread);
     QMutexLocker locker(&d->mutex);
 
@@ -764,7 +764,7 @@ void QThread::setTerminationEnabled(bool enabled)
                "Current thread was not started with QThread.");
 
     Q_UNUSED(thr)
-#if defined(Q_OS_ANDROID)
+#if defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
     Q_UNUSED(enabled);
 #else
     pthread_setcancelstate(enabled ? PTHREAD_CANCEL_ENABLE : PTHREAD_CANCEL_DISABLE, nullptr);
diff --git a/src/gui/configure.json b/src/gui/configure.json
index 1f08795c57..a14a499e4a 100644
--- a/src/gui/configure.json
+++ b/src/gui/configure.json
@@ -1306,7 +1306,7 @@
             "label": "OpenGL ES 2.0",
             "enable": "input.opengl == 'es2' || input.angle == 'yes'",
             "disable": "input.opengl == 'desktop' || input.opengl == 'dynamic' || input.opengl == 'no'",
-            "condition": "(config.win32 && !features.opengl-dynamic) || (!config.watchos && !features.opengl-desktop && libs.opengl_es2)",
+            "condition": "config.openharmony || (config.win32 && !features.opengl-dynamic) || (!config.watchos && !features.opengl-desktop && libs.opengl_es2)",
             "output": [
                 "publicFeature",
                 "publicQtConfig",
@@ -1316,7 +1316,7 @@
         },
         "opengles3": {
             "label": "OpenGL ES 3.0",
-            "condition": "features.opengles2 && !features.angle && tests.opengles3",
+            "condition": "features.opengles2 && !features.angle",
             "output": [
                 "publicFeature",
                 { "type": "define", "name": "QT_OPENGL_ES_3" }
diff --git a/src/gui/configure.pri b/src/gui/configure.pri
index 490ef0df28..537fd3ff69 100644
--- a/src/gui/configure.pri
+++ b/src/gui/configure.pri
@@ -70,6 +70,7 @@ defineTest(qtConfTest_qpaDefaultPlatform) {
     else: integrity: name = integrityfb
     else: haiku: name = haiku
     else: wasm: name = wasm
+    else: openharmony: name = openharmony
     else: name = xcb
 
     $${1}.value = $$name
diff --git a/src/gui/kernel/qguiapplication.cpp b/src/gui/kernel/qguiapplication.cpp
index c7ff2a6dac..bccadc3084 100644
--- a/src/gui/kernel/qguiapplication.cpp
+++ b/src/gui/kernel/qguiapplication.cpp
@@ -1220,7 +1220,7 @@ static void init_platform(const QString &pluginNamesWithArguments, const QString
         arguments.append(QLibraryInfo::platformPluginArguments(argumentsKey));
 
         // Create the platform integration.
-        QGuiApplicationPrivate::platform_integration = QPlatformIntegrationFactory::create(name, arguments, argc, argv, platformPluginPath);
+        QGuiApplicationPrivate::platform_integration = QPlatformIntegrationFactory::create(name, arguments, argc, argv, platformPluginPath);        
         if (Q_UNLIKELY(!QGuiApplicationPrivate::platform_integration)) {
             if (availablePlugins.contains(name)) {
                 qCInfo(lcQpaPluginLoading).nospace().noquote()
diff --git a/src/gui/kernel/qplatformintegrationfactory.cpp b/src/gui/kernel/qplatformintegrationfactory.cpp
index 3fcf9014a7..f478f0178c 100644
--- a/src/gui/kernel/qplatformintegrationfactory.cpp
+++ b/src/gui/kernel/qplatformintegrationfactory.cpp
@@ -67,7 +67,7 @@ QPlatformIntegration *QPlatformIntegrationFactory::create(const QString &platfor
     }
 #else
     Q_UNUSED(platformPluginPath);
-#endif
+#endif    
     return qLoadPlugin<QPlatformIntegration, QPlatformIntegrationPlugin>(loader(), platform, paramList, argc, argv);
 }
 
diff --git a/src/gui/kernel/qscreen.cpp b/src/gui/kernel/qscreen.cpp
index 990272b0c2..b1b539bfb3 100644
--- a/src/gui/kernel/qscreen.cpp
+++ b/src/gui/kernel/qscreen.cpp
@@ -427,7 +427,11 @@ QRect QScreen::geometry() const
 QRect QScreen::availableGeometry() const
 {
     Q_D(const QScreen);
+#ifdef Q_OS_OPENHARMONY
+    return d->platformScreen->availableGeometry();
+#else
     return d->availableGeometry;
+#endif
 }
 
 /*!
diff --git a/src/network/access/qnetworkaccessfilebackend.cpp b/src/network/access/qnetworkaccessfilebackend.cpp
index 507417f86c..a29678555e 100644
--- a/src/network/access/qnetworkaccessfilebackend.cpp
+++ b/src/network/access/qnetworkaccessfilebackend.cpp
@@ -57,6 +57,9 @@ QStringList QNetworkAccessFileBackendFactory::supportedSchemes() const
             << QStringLiteral("qrc");
 #if defined(Q_OS_ANDROID)
     schemes << QStringLiteral("assets");
+#endif
+#if defined(Q_OS_OPENHARMONY)
+    schemes << QStringLiteral("rawfile");
 #endif
     return schemes;
 }
@@ -80,6 +83,9 @@ QNetworkAccessFileBackendFactory::create(QNetworkAccessManager::Operation op,
     if (url.scheme().compare(QLatin1String("qrc"), Qt::CaseInsensitive) == 0
 #if defined(Q_OS_ANDROID)
             || url.scheme().compare(QLatin1String("assets"), Qt::CaseInsensitive) == 0
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            || url.scheme().compare(QLatin1String("rawfile"), Qt::CaseInsensitive) == 0
 #endif
             || url.isLocalFile()) {
         return new QNetworkAccessFileBackend;
@@ -136,6 +142,11 @@ void QNetworkAccessFileBackend::open()
             if (url.scheme() == QLatin1String("assets"))
                 fileName = QLatin1String("assets:") + url.path();
             else
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            if (url.scheme() == QLatin1String("rawfile"))
+                fileName = QLatin1String("rawfile:") + url.path();
+            else
 #endif
                 fileName = url.toString(QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemoveQuery);
         }
diff --git a/src/network/access/qnetworkaccessmanager.cpp b/src/network/access/qnetworkaccessmanager.cpp
index a10fe9e3fe..7c363279a2 100644
--- a/src/network/access/qnetworkaccessmanager.cpp
+++ b/src/network/access/qnetworkaccessmanager.cpp
@@ -1419,6 +1419,9 @@ QNetworkReply *QNetworkAccessManager::createRequest(QNetworkAccessManager::Opera
         if (isLocalFile
 #ifdef Q_OS_ANDROID
             || scheme == QLatin1String("assets")
+#endif
+#ifdef Q_OS_OPENHARMONY
+            || scheme == QLatin1String("rawfile")
 #endif
             || scheme == QLatin1String("qrc")) {
             return new QNetworkReplyFileImpl(this, req, op);
diff --git a/src/network/access/qnetworkreplyfileimpl.cpp b/src/network/access/qnetworkreplyfileimpl.cpp
index 6e69b4c4d3..ff8ff19361 100644
--- a/src/network/access/qnetworkreplyfileimpl.cpp
+++ b/src/network/access/qnetworkreplyfileimpl.cpp
@@ -110,6 +110,11 @@ QNetworkReplyFileImpl::QNetworkReplyFileImpl(QNetworkAccessManager *manager, con
             if (scheme == QLatin1String("assets"))
                 fileName = QLatin1String("assets:") + url.path();
             else
+#endif
+#if defined(Q_OS_OPENHARMONY)
+                if (scheme == QLatin1String("rawfile"))
+                    fileName = QLatin1String("rawfile:") + url.path();
+                else
 #endif
                 fileName = url.toString(QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemoveQuery);
         }
diff --git a/src/openharmony/entryability/EntryAbility.ts b/src/openharmony/entryability/EntryAbility.ts
new file mode 100644
index 0000000000..6a4626655c
--- /dev/null
+++ b/src/openharmony/entryability/EntryAbility.ts
@@ -0,0 +1,44 @@
+import hilog from '@ohos.hilog';
+import UIAbility from '@ohos.app.ability.UIAbility';
+import Window from '@ohos.window'
+import JsApplication  from '../native/QtCore/JsApplication'
+import JsDataStore from '../native/QtCore/JsDataStore'
+import JSLogger from '../native/QtCore/JsLogger'
+
+export default class EntryAbility extends UIAbility {
+
+    onCreate(want, launchParam) {
+        JsDataStore.setContext(this.context);
+        JsDataStore.setElementName({
+            bundleName: want.bundleName,
+            abilityName: want.abilityName,
+            moduleName: want.moduleName
+        });
+    }
+
+    onDestroy() {
+        JSLogger.info('%{public}s', 'Ability onDestroy');
+        JsApplication.quit();
+    }
+
+    onWindowStageCreate(windowStage: Window.WindowStage) {
+        // Main window is created, set main page for this ability
+        JSLogger.info('%{public}s', 'Ability onWindowStageCreate');
+        JsApplication.run(windowStage);
+    }
+
+    onWindowStageDestroy() {
+        // Main window is destroyed, release UI related resources
+        JSLogger.info('%{public}s', 'Ability onWindowStageDestroy');
+    }
+
+    onForeground() {
+        // Ability has brought to foreground
+        JSLogger.info('%{public}s', 'Ability onForeground');
+    }
+
+    onBackground() {
+        // Ability has back to background
+        JSLogger.info('%{public}s', 'Ability onBackground');
+    }
+};
diff --git a/src/openharmony/native/QtCore/JsApplication.ts b/src/openharmony/native/QtCore/JsApplication.ts
new file mode 100644
index 0000000000..acd7a78e95
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsApplication.ts
@@ -0,0 +1,152 @@
+import window from '@ohos.window';
+import display from '@ohos.display';
+import fs from '@ohos.file.fs';
+import resourceManager from '@ohos.resourceManager';
+import JsDataStore from './JsDataStore';
+import { QtQPA } from './JsQtPlatform';
+import JsLogger from './JsLogger';
+import { JsWindowManager } from './JsWindowManager';
+
+class JsApplication {
+  private mainWindow: window.Window = null;
+  private mainWindowName: string = "opemharmony_qt_mainwindow";
+  private qpa: any = QtQPA;
+
+  getMainWindow(): window.Window {
+    return this.mainWindow;
+  }
+
+  getMainWindowName(): string {
+    return this.mainWindowName;
+  }
+
+  addWindow(name: string, window: window.Window): void {
+    let obj  = JsDataStore.getJsObjectLoader().createObject("JsWindowManager", "JsWindowManager");
+    (obj as JsWindowManager).addWindow(name, window);
+  }
+
+  async run(windowStage: window.WindowStage) {
+    let qtMajorVersion: number = this.qpa.qtMajorVersion();
+    let QtCoreModule: any = null;
+    if (qtMajorVersion == 5)
+      QtCoreModule = await import ("libQt5Core.so");
+    else if (qtMajorVersion == 6)
+    QtCoreModule = await import ("libQt6Core.so");
+    if (QtCoreModule == null) {
+      JsLogger.fatal("Cannot load QtCore module");
+      return;
+    }
+    JsDataStore.setQtMajorVersion(qtMajorVersion);
+    let QtCore = QtCoreModule.default;
+    QtCore.initJsObjectLoader((type: string, name: string, ...args: any[])=>{
+      return JsDataStore.getJsObjectLoader().createObject(type, name, ...args);
+    });
+    QtCore.initRemoveObjectFunction((name: string)=>{
+      return JsDataStore.getJsObjectLoader().deleteObject(name);
+    });
+    JsDataStore.addQtNativeModule("QPA", this.qpa);
+    JsDataStore.addQtNativeModule("QtCore", QtCore);
+    this.mainWindow = windowStage.getMainWindowSync();
+    let localStore = new LocalStorage({"name": this.mainWindowName});
+    await windowStage.loadContent('pages/Index', localStore);
+    this.addWindow(this.mainWindowName, this.mainWindow);
+    let d = display.getDefaultDisplaySync();
+    let area = await this.mainWindow.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM);
+    if (this.qpa != null) {
+      this.qpa.setDeviceType(JsDataStore.deviceType());
+      // this.qpa.setDisplayMetrics(d.width, d.height, d.densityDPI, d.scaledDensity, d.xDPI, d.yDPI,
+      //   d.width - area.leftRect.width - area.rightRect.width, d.height - 72 - 144);
+
+      this.qpa.setDisplayMetrics(d.width, d.height, d.densityDPI, d.scaledDensity, d.xDPI, d.yDPI,
+        d.width - area.leftRect.width - area.rightRect.width, d.height - area.topRect.height - area.bottomRect.height);
+    }
+    windowStage.on("windowStageEvent", (state)=>{
+      if (this.qpa != null)
+        this.qpa.updateApplicationState(state);
+      JsLogger.info("window stage changed %{public}d", state);
+    });
+    JsDataStore.setWindowStage(windowStage);
+    await this.extractFilesToCache();
+    this.loadQtApplication();
+    // let obj  = this.jsObjectLoader.createObject("JsWindowManager");
+    // (obj as JsWindowManager).createWindow("test_window");
+  }
+
+  quit() {
+    this.qpa.quitQtApplication();
+  }
+
+  loadQtApplication() {
+    this.qpa.setResourceManager(JsDataStore.getResourceManager());
+    let result : boolean = this.qpa.startQtApplication(JsDataStore.getApplicationDirs(), "libentry.so");
+    JsLogger.info("load qt application result: %{public}s", result);
+  }
+
+  private saveFileToCache(file: resourceManager.RawFileDescriptor, des: string) {
+    let paths = des.split("/").slice(0, -1);
+    let dirs = JsDataStore.getApplicationDirs();
+    let temp = dirs.cacheDir + "/";
+    for (let i = 0; i < paths.length; ++i) {
+      temp = temp + paths[i];
+      let result = fs.accessSync(temp);
+      if (!result) {
+        fs.mkdirSync(temp);
+      }
+      temp = temp + "/";
+    }
+
+    let fileName = dirs.cacheDir + "/" + des;
+    // ()
+    let cacheFile = fs.openSync(fileName,
+      fs.OpenMode.WRITE_ONLY | fs.OpenMode.CREATE | fs.OpenMode.TRUNC)
+    let buffer = new ArrayBuffer(4096);
+    let currentOffset = file.offset;
+    let lengthNeedToReed = file.length;
+    let readOption = {
+      offset: currentOffset,
+      length: lengthNeedToReed > buffer.byteLength ? 4096 : lengthNeedToReed
+    }
+    while (true) {
+      // buffer
+      let readLength = fs.readSync(file.fd, buffer, readOption);
+      // buffer
+      fs.writeSync(cacheFile.fd, buffer, {
+        length: readLength
+      })
+      //  
+      if (readLength < 4096) {
+        break;
+      }
+      lengthNeedToReed -= readLength;
+      readOption.offset += readLength;
+      readOption.length = lengthNeedToReed > buffer.byteLength ? 4096 : lengthNeedToReed;
+    }
+    fs.close(cacheFile);
+  }
+
+  async extractFile(src: string) {
+    try {
+      let R = JsDataStore.getResourceManager();
+      let file: resourceManager.RawFileDescriptor = await R.getRawFd(src);
+      this.saveFileToCache(file, src);
+    } catch (err) {
+      JsLogger.error("extract file failed: %{public}s %{public}s", JSON.stringify(err), src);
+    }
+  }
+
+  async extractFilesToCache() {
+    try {
+      let R = JsDataStore.getResourceManager();
+      let rawContent: Uint8Array = await R.getRawFileContent("qt.json");
+      let str: string = String.fromCharCode.apply(null, rawContent)
+      let files = JSON.parse(str);
+      for (var i = 0; i < files.files.length; ++i) {
+        await this.extractFile(files.files[i]);
+      }
+    } catch (err) {
+      JsLogger.error("read file qt.json failed: %{public}s", JSON.stringify(err));
+    }
+  }
+}
+
+export default new JsApplication;
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsDataStore.ts b/src/openharmony/native/QtCore/JsDataStore.ts
new file mode 100644
index 0000000000..f29bdce8f9
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsDataStore.ts
@@ -0,0 +1,113 @@
+import common from '@ohos.app.ability.common';
+import window from '@ohos.window';
+import bundleManager from '@ohos.bundle.bundleManager';
+import resourceManager from '@ohos.resourceManager';
+import HashMap from '@ohos.util.HashMap';
+import { JsQtModule } from './JsQtModule'
+import deviceInfo from '@ohos.deviceInfo';
+import QtJsObjectLoader from './JsObjectLoader';
+
+interface ApplicationDirs {
+  tempDir: string,
+  filesDir: string,
+  cacheDir: string,
+  databaseDir: string,
+  bundleCodeDir: string,
+  preferencesDir: string,
+  distributedFilesDir: string,
+  qmlDir: string
+}
+
+class JsDataStore {
+  private windowName: string;
+  private context: common.UIAbilityContext = null;
+  private windowStage: window.WindowStage;
+  private elementName: bundleManager.ElementName = null;
+  private jsModules: JsQtModule[] = [];
+  private applicationDirs: ApplicationDirs;
+  private qtMajorVersion: number = 0;
+  private qtNativeModules: HashMap<string, any> = new HashMap();
+  private jsObjectLoader: QtJsObjectLoader = new QtJsObjectLoader;
+
+  constructor() {
+  }
+
+  setContext(context: common.UIAbilityContext) {
+    this.context = context;
+    let appContext = this.context.getApplicationContext();
+    let dirs : ApplicationDirs = {
+      tempDir: appContext.tempDir,
+      filesDir: appContext.filesDir,
+      cacheDir: appContext.cacheDir,
+      databaseDir: appContext.databaseDir,
+      bundleCodeDir: appContext.bundleCodeDir,
+      preferencesDir: appContext.preferencesDir,
+      distributedFilesDir: appContext.distributedFilesDir,
+      qmlDir: appContext.cacheDir + "/Qt/qml"
+    };
+    this.applicationDirs = dirs;
+  }
+
+  getContext(): common.UIAbilityContext {
+    return this.context;
+  }
+
+  getApplicationDirs() : ApplicationDirs {
+    return this.applicationDirs;
+  }
+
+  setElementName(en: bundleManager.ElementName) {
+    this.elementName = en;
+  }
+
+  getElementName(): bundleManager.ElementName {
+    return this.elementName;
+  }
+
+
+  setWindowStage(windowStage: window.WindowStage) {
+    this.windowStage = windowStage;
+  }
+
+  getWindowStage(): window.WindowStage {
+    return this.windowStage;
+  }
+
+  getResourceManager() : resourceManager.ResourceManager {
+    return this.context.resourceManager;
+  }
+
+  addJsModule(module: JsQtModule) {
+    this.jsModules.push(module);
+  }
+
+  getJsModules(): JsQtModule[] {
+    return this.jsModules;
+  }
+
+  getJsObjectLoader(): QtJsObjectLoader {
+    return this.jsObjectLoader;
+  }
+
+  getQtMajorVersion(): number {
+    return this.qtMajorVersion;
+  }
+
+  setQtMajorVersion(version: number) {
+    this.qtMajorVersion = version;
+  }
+
+  addQtNativeModule(name: string, module: any) {
+    this.qtNativeModules.set(name, module);
+  }
+
+  getQtNativeModule(name: string): any {
+    return this.qtNativeModules.get(name);
+  }
+
+  deviceType(): string {
+    return deviceInfo.deviceType;
+  }
+}
+
+export default new JsDataStore;
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsDialog.ts b/src/openharmony/native/QtCore/JsDialog.ts
new file mode 100644
index 0000000000..c6e6e5de72
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsDialog.ts
@@ -0,0 +1,182 @@
+import promptAction from '@ohos.promptAction'
+import picker from '@ohos.file.picker';
+import JsDataStore from './JsDataStore'
+import uri from '@ohos.uri';
+import fs from '@ohos.file.fs';
+import JsLogger from './JsLogger'
+
+export class JsDialog {
+
+    constructor() {
+    }
+
+    messageBox(handler : number, title : string, text : string, buttons : Array<string>): boolean {
+        var opt: promptAction.ShowDialogOptions = {
+            title: title,
+            message: text,
+            buttons: [{
+                text: "OK",
+                color: "#000000"
+            }]
+        };
+        if (buttons != null && buttons.length > 0) {
+            var first : promptAction.Button = {
+                text: buttons[0],
+                color: '#000000',
+            }
+            opt.buttons[0] = first;
+            for (var i = 1; i < buttons.length; i++) {
+                var button : promptAction.Button = {
+                    text: buttons[i],
+                    color: '#000000',
+                }
+                opt.buttons.push(button)
+            }
+        }
+
+        promptAction.showDialog(opt, (err, data) => {
+            if (err) {
+                JsLogger.error("show dialog error: %{public}s", JSON.stringify(err));
+            }
+            let index = err ? -1 : data.index;
+            JsDataStore.getQtNativeModule("QPA").dialogResult(handler, index);
+        });
+        return true;
+    }
+
+    isVideo(filter: string): boolean {
+        return filter.includes("mp4") || filter.includes("MPEG")
+        || filter.includes("MPG") || filter.includes("DAT")
+        || filter.includes("MOV") || filter.includes("FLV");
+    }
+
+    isAudio(filter: string): boolean {
+        return filter.includes("mp3") || filter.includes("wma") || filter.includes("ogg") || filter.includes("flac")
+        || filter.includes("wv");
+    }
+
+    isImage(filter: string): boolean {
+        return filter.includes("png") || filter.includes("jpeg")
+        || filter.includes("jpg") || filter.includes("bmp")
+    }
+
+    async openFileDialog(handler: number, filter: string) : Promise<boolean> {
+        // let isImage = this.isImage(filter);
+        // let isVideo = this.isVideo(filter);
+        // let isAudio = this.isAudio(filter);
+        // if (isImage || isVideo) {
+        //     const photoSelectOptions = new picker.PhotoSelectOptions();
+        //     if (isImage)
+        //         photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE;
+        //     if (isVideo)
+        //         photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.VIDEO_TYPE;
+        //     if (isVideo && isImage)
+        //         photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_VIDEO_TYPE;
+        //     photoSelectOptions.maxSelectNumber = 5;
+        //     const photoViewPicker = new picker.PhotoViewPicker();
+        //     photoViewPicker.select(photoSelectOptions).then((photoSelectResult) => {
+        //         JsLogger.info('photoViewPicker.select to file succeed and uri is: %{public}', uri);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, photoSelectResult.photoUris);
+        //     }).catch((err) => {
+        //         JsLogger.error(`Invoke photoViewPicker.select failed, code is %{public}d, message is %{public}s`, err.code, err.message);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, []);
+        //     })
+        // } else if (isAudio) {
+        //     const audioSelectOptions = new picker.AudioSelectOptions();
+        //     const audioViewPicker = new picker.AudioViewPicker();
+        //     audioViewPicker.select(audioSelectOptions).then(audioSelectResult => {
+        //         JsDataStore.getQpa().selectedFilesResult(handler, audioSelectResult);
+        //         JsLogger.info('audioViewPicker.select to file succeed and uri is: %{public}s', JSON.stringify(audioSelectResult));
+        //     }).catch((err) => {
+        //         JsLogger.error(`Invoke audioViewPicker.select failed, code is %{public}d, message is %{public}s`, err.code, err.message);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, []);
+        //     })
+        // } else  {
+        //     const documentSelectOptions = new picker.DocumentSelectOptions();
+        //     const documentViewPicker = new picker.DocumentViewPicker();
+        //     documentViewPicker.select(documentSelectOptions).then((documentResult) => {
+        //         JsLogger.info('documentViewPicker.select to file succeed and uri is: %{public}s', JSON.stringify(documentResult));
+        //         JsDataStore.getQpa().selectedFilesResult(handler, documentResult);
+        //     }).catch((error) => {
+        //         JsLogger.error(`Invoke documentViewPicker.select failed, code is %{public}d, message is %{public}s`, error.code, error.message);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, []);
+        //     });
+        // }
+
+        let config = {
+            action: 'ohos.want.action.OPEN_FILE',
+            parameters: {
+                startMode: 'choose',
+            }
+        }
+
+        let context = JsDataStore.getContext();
+
+        context.startAbilityForResult(config).then((result) => {
+            // uri
+            let select_item_list = result.want.parameters.select_item_list;
+            JsLogger.info("select file: %{public}s", select_item_list.toString());
+            JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, ["datashare:/" + select_item_list.toString()]);
+        }).catch((error) => {
+            JsLogger.error("open file dialog result %{public}s", JSON.stringify(error));
+            JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, []);
+        });
+        return true;
+    }
+
+    async saveFileDialog(handler : number, fileName: string) : Promise<boolean> {
+        // let isImage = this.isImage(fileName);
+        // let isVideo = this.isVideo(fileName);
+        // let isAudio = this.isAudio(fileName);
+        // if (isImage || isVideo) {
+        //     const photoSaveOptions = new picker.PhotoSaveOptions();
+        //     photoSaveOptions.newFileNames = [fileName];
+        //     const photoViewPicker = new picker.PhotoViewPicker();
+        //     photoViewPicker.save(photoSaveOptions).then((photoResult) => {
+        //         JsDataStore.getQpa().selectedFilesResult(handler, photoResult);
+        //     }).catch((error) => {
+        //         JsLogger.error(`Invoke documentViewPicker.select failed, code is %{public}d, message is %{public}s`, error.code, error.message);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, []);
+        //     });
+        // } else if (isAudio) {
+        //     const audioSaveOptions = new picker.AudioSaveOptions();
+        //     audioSaveOptions.newFileNames = [fileName];
+        //     const audioViewPicker = new picker.AudioViewPicker();
+        //     audioViewPicker.save(audioSaveOptions).then((audioResult) => {
+        //         JsDataStore.getQpa().selectedFilesResult(handler, audioResult);
+        //     }).catch((error) => {
+        //         JsLogger.error(`Invoke documentViewPicker.select failed, code is %{public}d, message is %{public}s`, error.code, error.message);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, []);
+        //     });
+        // } else {
+        //     const documentSaveOptions = new picker.DocumentSaveOptions();
+        //     documentSaveOptions.newFileNames = [fileName];
+        //     const documentViewPicker = new picker.DocumentViewPicker();
+        //     documentViewPicker.save(documentSaveOptions).then((documentResult) => {
+        //         JsDataStore.getQpa().selectedFilesResult(handler, documentResult);
+        //     }).catch((error) => {
+        //         JsLogger.error(`Invoke documentViewPicker.select failed, code is %{public}d, message is %{public}s`, error.code, error.message);
+        //         JsDataStore.getQpa().selectedFilesResult(handler, []);
+        //     });
+        // }
+        // return true;
+        let config = {
+            action: 'ohos.want.action.CREATE_FILE',
+            parameters: {
+                startMode: 'save',
+                key_pick_file_name: [fileName],
+                saveFile: fileName,
+            }
+        }
+
+        try {
+            let context = JsDataStore.getContext()
+            let result = await context.startAbilityForResult(config);
+            JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, [result.want.parameters.pick_path_return.toString()]);
+        } catch (error) {
+            JsLogger.info("startAbilityForResult Promise.Reject is called, error.code = %{public}s",  error.code)
+            JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, []);
+        }
+        return true;
+    }
+}
diff --git a/src/openharmony/native/QtCore/JsFile.ts b/src/openharmony/native/QtCore/JsFile.ts
new file mode 100644
index 0000000000..6fc0351383
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsFile.ts
@@ -0,0 +1,92 @@
+import fs from '@ohos.file.fs';
+import deviceInfo from '@ohos.deviceInfo'
+import JSLogger from './JsLogger'
+
+export class JsFile {
+
+  private uri : string = '';
+  private file : fs.File= null;
+  private valid : boolean = false;
+  private offset : number = 0;
+
+
+  constructor(uriString: string) {
+    let _uri = uriString;
+    const versionRegex = /(\d+\.\d+\.\d+\.\d+)/;
+    const match = deviceInfo.displayVersion.match(versionRegex);
+    let version = '';
+    if (match) {
+      version = match[0]
+    }
+    if (version != '' && version.localeCompare("4.0.7.5") == -1)
+      _uri = _uri.replace("datashare://", "file:")
+    this.uri = _uri;
+  }
+
+  open(mode: number): boolean {
+    try {
+      JSLogger.info("open file: %{public}s %{public}d", this.uri, mode)
+      this.file = fs.openSync(this.uri, mode);
+      this.valid = true;
+    } catch (error) {
+      JSLogger.error("file open: %{public}s", JSON.stringify(error));
+      this.valid = false;
+    } finally {
+      return this.valid;
+    }
+  }
+
+   write(buffer : ArrayBuffer): number {
+    try {
+      return fs.writeSync(this.file.fd, buffer);
+    } catch (error) {
+      JSLogger.error("file write: %{public}s", JSON.stringify(error));
+      return -1;
+    }
+  }
+
+  seek(offset: number): boolean {
+    this.offset = offset;
+    return true;
+  }
+
+  pos(): number {
+    return this.offset;
+  }
+
+  size(): number {
+    return fs.statSync(this.file.fd).size;
+  }
+
+  flush(): boolean {
+    return true;
+  }
+
+  read(length: number): ArrayBuffer {
+    let buf = new ArrayBuffer(length);
+    try {
+      let options = { "offset": this.offset, "length": length }
+      let result = fs.readSync(this.file.fd, buf, options);
+      this.offset = this.offset + result;
+      return buf;
+    } catch (error) {
+      JSLogger.error("file read error: %{public}s", JSON.stringify(error));
+      return null;
+    }
+  }
+
+  close(): boolean {
+    if (this.valid) {
+      try {
+        fs.closeSync(this.file);
+      } catch (error) {
+        JSLogger.error("file close %{public}s", JSON.stringify(error));
+      } finally {
+        this.valid = false;
+        return true;
+      }
+    } else {
+      return true;
+    }
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsInputManager.ts b/src/openharmony/native/QtCore/JsInputManager.ts
new file mode 100644
index 0000000000..75c49c810f
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsInputManager.ts
@@ -0,0 +1,56 @@
+import window from '@ohos.window';
+import QtApplication from './JsApplication'
+import JsDataStore from './JsDataStore'
+export class JsInputManager {
+  public constructor() {
+  }
+
+  public complete(text: string) {
+    console.log('[SoftKeyboard] cocos input complete ' + text);
+    globalThis.qtinputmanager.callQtCommit(text);
+  }
+
+  public open(text: string) {
+    console.log('[SoftKeyboard] cocos open keyboard');
+    //globalThis.indexPage.dialogController.open();
+    globalThis.showMessage = text;
+    let windowClass = null;
+    try {
+      let windowStage = JsDataStore.getWindowStage();
+      let mainWindow = windowStage.getMainWindowSync();
+      let property = mainWindow.getWindowProperties();
+      let promise = windowStage.createSubWindow('EditBoxDialog');
+      promise.then((data) => {
+        windowClass = data;
+        let promiseUI = windowClass.setUIContent('pages/components/EditBoxDialog.ets');
+        promiseUI.then(() => {
+          windowClass.showWindow();
+          windowClass.setWindowBackgroundColor('#00000000');
+          windowClass.resize(property.windowRect.width, 30);
+          windowClass.moveWindowTo(0, property.windowRect.height - 30)
+        });
+      });
+    } catch (exception) {
+      console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(exception));
+      //globalThis.qtwindowmanager.createWindowResult(false);
+    }
+    ;
+  }
+
+  public close() {
+    console.log('[SoftKeyboard] cocos close keyboard');
+    //globalThis.indexPage.dialogController.close();
+    let windowClass = null;
+    try {
+      windowClass = window.findWindow('EditBoxDialog');
+      windowClass.destroyWindow();
+    } catch (exception) {
+      console.error('Failed to find the Window. Cause: ' + JSON.stringify(exception));
+    }
+
+  }
+
+  setKeyBoardVisible(visible: boolean) {
+    console.log('show keyboard 555555555555555555555555555555555555555555555', visible);
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsLogger.ts b/src/openharmony/native/QtCore/JsLogger.ts
new file mode 100644
index 0000000000..328a60c965
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsLogger.ts
@@ -0,0 +1,38 @@
+import hilog from '@ohos.hilog';
+
+export class JsLogger {
+  private domain: number;
+  private tag: string;
+
+  constructor(tag: string) {
+    this.tag = tag;
+    this.domain = 0xFF00;
+  }
+
+  debug(format: string, ...args: any[]): void {
+    hilog.debug(this.domain, this.tag, format, args);
+  }
+
+  info(format: string, ...args: any[]): void {
+    hilog.info(this.domain, this.tag, format, args);
+  }
+
+  warn(format: string, ...args: any[]): void {
+    hilog.warn(this.domain, this.tag, format, args);
+  }
+
+  error(format: string, ...args: any[]): void {
+    hilog.error(this.domain, this.tag, format, args);
+  }
+
+  fatal(format: string, ...args: any[]): void {
+    hilog.fatal(this.domain, this.tag, format, args);
+  }
+
+  isLoggable(level: number): void {
+    hilog.isLoggable(this.domain, this.tag, level);
+  }
+}
+
+export default new JsLogger('QtForHarmony');
+
diff --git a/src/openharmony/native/QtCore/JsObjectLoader.ts b/src/openharmony/native/QtCore/JsObjectLoader.ts
new file mode 100644
index 0000000000..e175af7dc2
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsObjectLoader.ts
@@ -0,0 +1,36 @@
+import JsDataStore from './JsDataStore'
+import { JsQtModule } from './JsQtModule'
+
+export default class QtJsObjectLoader {
+
+  constructor() {
+
+  }
+
+  createObject(type: string, name: string, ...args: any[]): Object {
+    let modules = JsDataStore.getJsModules();
+    let module: JsQtModule = null;
+    for (let i = 0; i < modules.length; ++i) {
+      if (modules[i].hasJsObject(type)) {
+        module = modules[i];
+        break;
+      }
+    }
+
+    if (module == null) {
+      return null;
+    }
+
+    let obj = module.createJsObject(type, name, ...args);
+    return obj;
+  }
+
+  deleteObject(name: string): void {
+    let modules = JsDataStore.getJsModules();
+    for (let i = 0; i < modules.length; ++i) {
+      if (modules[i].deleteJsObject(name)) {
+        break;
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsPasteBoard.ts b/src/openharmony/native/QtCore/JsPasteBoard.ts
new file mode 100644
index 0000000000..6d1dd690fd
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsPasteBoard.ts
@@ -0,0 +1,34 @@
+import pasteboard from '@ohos.pasteboard';
+import JsDataStore from './JsDataStore'
+import JsLogger from './JsLogger'
+
+export class JsPasteBoard {
+
+    constructor() {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        systemPasteboard.on('update', () => {
+            JsDataStore.getQtNativeModule("QPA").pasteChanged();
+        });
+    }
+
+    async hasClipboardText() : Promise<boolean> {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        let result = await systemPasteboard.hasData()
+        return result;
+    }
+
+    async clipboardText() : Promise<string> {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        let pastedata = await systemPasteboard.getData();
+        let result = pastedata.getPrimaryText();
+        return result;
+    }
+
+    setClipboardText(text: string) : boolean {
+        JsLogger.info('set clipboard text %{public}s', text);
+        var pasteData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text);
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        systemPasteboard.setData(pasteData);
+        return true;
+    }
+}
diff --git a/src/openharmony/native/QtCore/JsQtModule.ts b/src/openharmony/native/QtCore/JsQtModule.ts
new file mode 100644
index 0000000000..c681a270ba
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsQtModule.ts
@@ -0,0 +1,47 @@
+import HashMap from '@ohos.util.HashMap';
+import JsDataStore  from './JsDataStore'
+
+export class JsQtModule {
+
+  moduleJsObjects : Object = null;
+
+  jsObjects: HashMap<string, Object> = new HashMap();
+
+  constructor() {
+    JsDataStore.addJsModule(this);
+  }
+
+  hasJsObject(type: string): boolean {
+    if (this.moduleJsObjects == null)
+      return false;
+    const constructor = this.moduleJsObjects[type];
+    return constructor != null;
+  }
+
+  createJsObjectImpl(type: string, ...args: any[]): Object {
+    if (this.moduleJsObjects == null)
+      return null;
+    const constructor = this.moduleJsObjects[type];
+    if (constructor) {
+      return new constructor(...args);
+    }
+    return null;
+  }
+
+  createJsObject(type: string, name: string, ...args: any[]): Object {
+    if (this.jsObjects.hasKey(name))
+      return this.jsObjects.get(name);
+    let obj = this.createJsObjectImpl(type, ...args);
+    if (obj == null)
+      return null;
+    this.jsObjects.set(name, obj);
+    return obj;
+  }
+
+  deleteJsObject(name: string): boolean {
+    if (!this.jsObjects.hasKey(name))
+      return false;
+    this.jsObjects.remove(name);
+    return true;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsQtPlatform.ts b/src/openharmony/native/QtCore/JsQtPlatform.ts
new file mode 100644
index 0000000000..f039ac66d8
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsQtPlatform.ts
@@ -0,0 +1,23 @@
+import { JsQtModule } from './JsQtModule'
+import { JsDialog } from './JsDialog'
+import { JsPasteBoard } from './JsPasteBoard'
+import { JsInputManager } from './JsInputManager'
+import { JsWindowManager } from './JsWindowManager'
+import { JsFile } from './JsFile'
+import qpa from 'libplugins_platforms_qopenharmony.so'
+
+class JsQtPlatform extends JsQtModule {
+
+  public constructor() {
+    super();
+    this.moduleJsObjects = {
+      JsDialog,
+      JsPasteBoard,
+      JsInputManager,
+      JsWindowManager,
+      JsFile
+    };
+  }
+}
+export default new JsQtPlatform;
+export const QtQPA : Object = qpa
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsWindowManager.ts b/src/openharmony/native/QtCore/JsWindowManager.ts
new file mode 100644
index 0000000000..09a260d904
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsWindowManager.ts
@@ -0,0 +1,93 @@
+import window from '@ohos.window'
+import HashMap from '@ohos.util.HashMap'
+import JsDataStore from './JsDataStore'
+import JsLogger from './JsLogger'
+
+export class JsWindowManager {
+    private windowRect: HashMap<string, window.Rect> = new HashMap;
+    private windows: HashMap<string, window.Window> = new HashMap;
+
+    constructor() {
+
+    }
+
+    findWindow(name: string): window.Window {
+        if (this.windows.hasKey(name)) {
+            let p = this.windows.get(name);
+            return p;
+        }
+        return null;
+    }
+
+    async addWindow(name: string, window: window.Window) : Promise<void> {
+        this.windows.set(name, window);
+        window?.on("windowSizeChange", (size)=>{
+            let p = window.getWindowProperties();
+            JsLogger.info("%{public}s window size changed %{public}d %{public}d", name, size.width, size.height);
+            // JsDataStore.getQtNativeModule("QPA").handleGeometryChange(name, p.windowRect.left, p.windowRect.top, size.width, size.height);
+        });
+    }
+
+     async createWindow(name: string): Promise<boolean> {
+         try {
+             if (this.windows.hasKey(name))
+                 return true;
+             let windowStage = JsDataStore.getWindowStage();
+             let windowClass = await windowStage.createSubWindow(name);
+             let store = new LocalStorage({"name": name});
+             await windowClass.loadContent('pages/common', store);
+             this.addWindow(name, windowClass);
+             return true;
+         } catch (e) {
+             JsLogger.error("create window failed %{public}s", JSON.stringify(e));
+             return false;
+         }
+    }
+
+    async destroyWindow(name: string): Promise<boolean> {
+        let windowClass: window.Window = null;
+        try {
+            windowClass = this.findWindow(name);
+            await windowClass.destroyWindow();
+            return true;
+        } catch (exception) {
+            JsLogger.error('Failed to call destroyWindow for the Window. Cause: %{public}s' + JSON.stringify(exception));
+            return false;
+        }
+    }
+
+    async setGeometry(name: string, x: number, y: number, w: number, h: number): Promise<boolean> {
+        JsLogger.info('set window geometry: %{public}s %{public}d %{public}d %{public}d %{public}d', name, x, y, w, h)
+        let windowClass = this.findWindow(name);
+        if (windowClass != null) {
+            let visible = windowClass.isWindowShowing();
+            if (visible) {
+                await windowClass.moveWindowTo(x, y);
+                await windowClass.resize(w, h);
+            }
+            this.windowRect.set(name, {'width': w, 'height': h, 'left': x, 'top': y})
+        }
+        return true;
+    }
+
+    async setVisible(name: string, visible: boolean) {
+        JsLogger.error("set window visible: %{public}s %{public}s", name, visible);
+        try {
+            let windowClass = this.findWindow(name);
+            if (windowClass != null) {
+                if (visible) {
+                    await windowClass.showWindow();
+                    if (this.windowRect.hasKey(name)) {
+                        let p = this.windowRect.get(name);
+                        await windowClass.moveWindowTo(p.left, p.top);
+                        await windowClass.resize(p.width, p.height);
+                    }
+                }
+            }
+            return true;
+        } catch (exception) {
+            JsLogger.error('Failed to call showWindow for the Window. Cause: %{public}s' + JSON.stringify(exception));
+            return false;
+        }
+    }
+}
diff --git a/src/openharmony/openharmony.pro b/src/openharmony/openharmony.pro
new file mode 100644
index 0000000000..1c9156fde0
--- /dev/null
+++ b/src/openharmony/openharmony.pro
@@ -0,0 +1,12 @@
+TEMPLATE = aux
+CONFIG -= qt
+
+templates.files += $$files($$PWD/entryability/*.ts, true)
+templates.files += $$files($$PWD/native/*.ts, true)
+templates.files += $$files($$PWD/pages/*.ets, true)
+templates.path = $$[QT_INSTALL_PREFIX]/openharmony/qtbase
+templates.base = $$PWD
+
+INSTALLS += templates
+
+OTHER_FILES += $$templates.files
diff --git a/src/openharmony/pages/Index.ets b/src/openharmony/pages/Index.ets
new file mode 100644
index 0000000000..bcde846e17
--- /dev/null
+++ b/src/openharmony/pages/Index.ets
@@ -0,0 +1,16 @@
+import JsDataStore from '../../ets/native/QtCore/JsDataStore'
+
+@Entry
+@Component
+struct Index {
+  private store: LocalStorage = LocalStorage.GetShared();
+  private idName = this.store.get<string>("name");
+
+  build() {
+    Row() {
+      XComponent({id: this.idName, type: 'surface', libraryname: 'plugins_platforms_qopenharmony' }).width("100%").height("100%")
+        .onLoad(()=>{
+        })
+    }
+  }
+}
diff --git a/src/platformsupport/input/evdevkeyboard/qevdevkeyboardhandler.cpp b/src/platformsupport/input/evdevkeyboard/qevdevkeyboardhandler.cpp
index 24b2821fbb..e13a08cf45 100644
--- a/src/platformsupport/input/evdevkeyboard/qevdevkeyboardhandler.cpp
+++ b/src/platformsupport/input/evdevkeyboard/qevdevkeyboardhandler.cpp
@@ -159,16 +159,17 @@ std::unique_ptr<QEvdevKeyboardHandler> QEvdevKeyboardHandler::create(const QStri
 
 void QEvdevKeyboardHandler::switchLed(int led, bool state)
 {
-    qCDebug(qLcEvdevKey, "switchLed %d %d", led, int(state));
+    qCDebug(qLcEvdevKey) << "switchLed" << led << state;
 
+    struct ::input_event led_ie;
+#if __BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)
+    ::gettimeofday(&led_ie.time, 0);
+#else
     struct timeval tv;
     ::gettimeofday(&tv, 0);
-    struct ::input_event led_ie;
-    led_ie.input_event_sec = tv.tv_sec;
-    led_ie.input_event_usec = tv.tv_usec;
-    led_ie.type = EV_LED;
-    led_ie.code = led;
-    led_ie.value = state;
+    led_ie.__sec = tv.tv_sec;
+    led_ie.__usec = tv.tv_usec;
+#endif
 
     qt_safe_write(m_fd.get(), &led_ie, sizeof(led_ie));
 }
diff --git a/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp b/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp
index 7f1f0ebdae..e48e79e1b1 100644
--- a/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp
+++ b/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp
@@ -582,8 +582,11 @@ void QEvdevTouchScreenData::processInputEvent(input_event *data)
 
         // update timestamps
         m_lastTimeStamp = m_timeStamp;
-        m_timeStamp = data->input_event_sec + data->input_event_usec / 1000000.0;
-
+#if __BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)
+        m_timeStamp = data->time.tv_sec + data->time.tv_usec / 1000000.0;
+#else
+        m_timeStamp = data->__sec +  data->__usec / 1000000.0 ;
+#endif
         m_lastTouchPoints = m_touchPoints;
         m_touchPoints.clear();
         Qt::TouchPointStates combinedStates;
diff --git a/src/plugins/platforms/openharmony/openharmony.json b/src/plugins/platforms/openharmony/openharmony.json
new file mode 100644
index 0000000000..886625295c
--- /dev/null
+++ b/src/plugins/platforms/openharmony/openharmony.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "openharmony" ]
+}
diff --git a/src/plugins/platforms/openharmony/openharmony.pro b/src/plugins/platforms/openharmony/openharmony.pro
new file mode 100644
index 0000000000..b0fe98d729
--- /dev/null
+++ b/src/plugins/platforms/openharmony/openharmony.pro
@@ -0,0 +1,69 @@
+TARGET = qopenharmony
+
+LIBS += -lEGL -lace_napi.z -lace_ndk.z -lrawfile.z
+
+QT += \
+    core-private gui-private egl_support-private \
+    eventdispatcher_support-private fontdatabase_support-private
+
+qtConfig(vulkan){
+    QT += vulkan_support-private
+
+    HEADERS += $$PWD/qopenharmonyplatformvulkaninstance.h
+
+    SOURCES += $$PWD/qopenharmonyplatformvulkaninstance.cpp
+}
+
+OTHER_FILES += $$PWD/openharmony.json
+
+HEADERS += $$PWD/qopenharmonyplatformintegration.h \
+    $$PWD/qopenharmonyplatformwindow.h \
+    $$PWD/qopenharmonyplatformopenglwindow.h \
+    $$PWD/qopenharmonyplatformforeignwindow.h \
+    $$PWD/qopenharmonyplatformscreen.h \
+    $$PWD/qopenharmonyplatformbackingstore.h \
+    $$PWD/qopenharmonylog.h \
+    $$PWD/qopenharmonyxcomponent.h \
+    $$PWD/qopenharmonyxcomponentmanager.h \
+    $$PWD/qopenharmonyplatformopenglcontext.h \
+    $$PWD/qopenharmonyeventdispatcher.h \
+    $$PWD/qopenharmonyplatformoffscreensurface.h \
+    $$PWD/qopenharmonymain.h \
+    $$PWD/qopenharmonyeglcore.h \
+    $$PWD/qopenharmonyplatformfontdatabase.h \
+    $$PWD/qopenharmonyplatforminputcontext.h \
+    $$PWD/qopenharmonyplatformtheme.h \
+    $$PWD/qopenharmonyplatformdialoghelpers.h \
+    $$PWD/qopenharmonydrag.h \
+    $$PWD/qopenharmonyfileenginehandler.h
+
+SOURCES += $$PWD/qopenharmonyplatformplugin.cpp \
+    $$PWD/qopenharmonyplatformwindow.cpp \
+    $$PWD/qopenharmonyplatformintegration.cpp \
+    $$PWD/qopenharmonyplatformopenglwindow.cpp \
+    $$PWD/qopenharmonyplatformforeignwindow.cpp \
+    $$PWD/qopenharmonyplatformscreen.cpp \
+    $$PWD/qopenharmonyplatformbackingstore.cpp \
+    $$PWD/qopenharmonyplatformopenglcontext.cpp \
+    $$PWD/qopenharmonyplatformoffscreensurface.cpp \
+    $$PWD/qopenharmonymain.cpp \
+    $$PWD/qopenharmonyxcomponent.cpp \
+    $$PWD/qopenharmonyxcomponentmanager.cpp \
+    $$PWD/qopenharmonyeventdispatcher.cpp \
+    $$PWD/qopenharmonyeglcore.cpp \
+    $$PWD/qopenharmonyplatformfontdatabase.cpp \
+    $$PWD/qopenharmonyplatforminputcontext.cpp \
+    $$PWD/qopenharmonyplatformtheme.cpp \
+    $$PWD/qopenharmonyplatformdialoghelpers.cpp \
+    $$PWD/qopenharmonyplatformclipboard.cpp \
+    $$PWD/qopenharmonydrag.cpp \
+    $$PWD/qopenharmonyfileenginehandler.cpp
+
+
+PLUGIN_TYPE = platforms
+
+PLUGIN_CLASS_NAME = QOpenHarmonyPlatformIntegrationPlugin
+!equals(TARGET, $$QT_DEFAULT_QPA_PLUGIN): PLUGIN_EXTENDS = -
+
+load(qt_plugin)
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonydrag.cpp b/src/plugins/platforms/openharmony/qopenharmonydrag.cpp
new file mode 100644
index 0000000000..1f088afc20
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonydrag.cpp
@@ -0,0 +1,138 @@
+#include <QtCore/QDebug>
+#include <QtCore/QLoggingCategory>
+
+#include "qguiapplication.h"
+#include "qopenharmonydrag.h"
+#include "qpa/qplatformscreen.h"
+#include "qpa/qplatformwindow.h"
+#include <private/qhighdpiscaling_p.h>
+#include "qpa/qwindowsysteminterface.h"
+#include "private/qguiapplication_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_LOGGING_CATEGORY(ohDnd, "qt.openharmony.dnd")
+
+static QWindow* topLevelAt(const QPoint &pos)
+{
+    QWindowList list = QGuiApplication::topLevelWindows();
+    for (int i = list.count()-1; i >= 0; --i) {
+        QWindow *w = list.at(i);
+        if (w->isVisible() && w->handle() && w->geometry().contains(pos)/* && !qobject_cast<QShapedPixmapWindow*>(w)*/)
+            return w;
+    }
+    return 0;
+}
+
+QOpenHarmonyDrag::QOpenHarmonyDrag() = default;
+QOpenHarmonyDrag::~QOpenHarmonyDrag()
+{
+
+}
+
+void QOpenHarmonyDrag::startDrag()
+{
+    qInfo() << "<----------------------:::QOpenHarmonyDrag::startDrag()";
+    setExecutedDropAction(Qt::IgnoreAction);
+
+    QBasicDrag::startDrag();
+    // Here we can be fairly sure that QGuiApplication::mouseButtons/keyboardModifiers() will
+    // contain sensible values as startDrag() normally is called from mouse event handlers
+    // by QDrag::exec(). A better API would be if we could pass something like "input device
+    // pointer" to QDrag::exec(). My guess is that something like that might be required for
+    // QTBUG-52430.
+    m_sourceWindow = topLevelAt(QCursor::pos());
+    m_windowUnderCursor = m_sourceWindow;
+    if (m_sourceWindow) {
+        auto nativePixelPos = QHighDpi::toNativePixels(QCursor::pos(), m_sourceWindow);
+        move(nativePixelPos, QGuiApplication::mouseButtons(), QGuiApplication::keyboardModifiers());
+    } else {
+        setCanDrop(false);
+        updateCursor(Qt::IgnoreAction);
+    }
+
+    qCDebug(ohDnd) << "drag began from" << m_sourceWindow << "cursor pos" << QCursor::pos() << "can drop?" << canDrop();
+    qInfo() << "<----------------------:::QOpenHarmonyDrag::startDrag()<=====================";
+}
+
+static void sendDragLeave(QWindow *window)
+{
+    QWindowSystemInterface::handleDrag(window, nullptr, QPoint(), Qt::IgnoreAction, 0, 0);
+}
+
+void QOpenHarmonyDrag::cancel()
+{
+    QBasicDrag::cancel();
+    if (drag() && m_sourceWindow) {
+        sendDragLeave(m_sourceWindow);
+        m_sourceWindow = nullptr;
+    }
+}
+
+static inline QPoint fromNativeGlobalPixels(const QPoint &point)
+{
+#ifndef QT_NO_HIGHDPISCALING
+    QPoint res = point;
+    if (QHighDpiScaling::isActive()) {
+        for (const QScreen *s : qAsConst(QGuiApplicationPrivate::screen_list)) {
+            if (s->handle()->geometry().contains(point)) {
+                res = QHighDpi::fromNativePixels(point, s);
+                break;
+            }
+        }
+    }
+    return res;
+#else
+    return point;
+#endif
+}
+
+void QOpenHarmonyDrag::move(const QPoint &nativeGlobalPos, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)
+{
+    QPoint globalPos = fromNativeGlobalPixels(nativeGlobalPos);
+    moveShapedPixmapWindow(globalPos);
+    QWindow *window = topLevelAt(globalPos);
+
+    if (!window || window != m_windowUnderCursor) {
+        if (m_windowUnderCursor)
+            sendDragLeave(m_windowUnderCursor);
+        m_windowUnderCursor = window;
+        if (!window) {
+            // QSimpleDrag supports only in-process dnd, we can't drop anywhere else.
+            setCanDrop(false);
+            updateCursor(Qt::IgnoreAction);
+            return;
+        }
+    }
+
+    const QPoint pos = nativeGlobalPos - window->handle()->geometry().topLeft();
+    const QPlatformDragQtResponse qt_response = QWindowSystemInterface::handleDrag(
+            window, drag()->mimeData(), pos, drag()->supportedActions(),
+            buttons, modifiers);
+
+    setCanDrop(qt_response.isAccepted());
+    updateCursor(qt_response.acceptedAction());
+}
+
+void QOpenHarmonyDrag::drop(const QPoint &nativeGlobalPos, Qt::MouseButtons buttons,
+                            Qt::KeyboardModifiers modifiers)
+{
+    QPoint globalPos = fromNativeGlobalPixels(nativeGlobalPos);
+
+    QBasicDrag::drop(nativeGlobalPos, buttons, modifiers);
+    QWindow *window = topLevelAt(globalPos);
+    if (!window)
+        return;
+
+    const QPoint pos = nativeGlobalPos - window->handle()->geometry().topLeft();
+    const QPlatformDropQtResponse response = QWindowSystemInterface::handleDrop(
+            window, drag()->mimeData(), pos, drag()->supportedActions(),
+            buttons, modifiers);
+    if (response.isAccepted()) {
+        setExecutedDropAction(response.acceptedAction());
+    } else {
+        setExecutedDropAction(Qt::IgnoreAction);
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonydrag.h b/src/plugins/platforms/openharmony/qopenharmonydrag.h
new file mode 100644
index 0000000000..f29ee6fccb
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonydrag.h
@@ -0,0 +1,25 @@
+#ifndef QOPENHARMONYDRAG_H
+#define QOPENHARMONYDRAG_H
+
+#include <QtGui/qdrag.h>
+#include <QtGui/qpixmap.h>
+#include <private/qsimpledrag_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyDrag : public QBasicDrag
+{
+public:
+    QOpenHarmonyDrag();
+    virtual ~QOpenHarmonyDrag();
+
+protected:
+    virtual void startDrag() override;
+    virtual void cancel() override;
+    virtual void move(const QPoint &globalPos, Qt::MouseButtons b, Qt::KeyboardModifiers mods) override;
+    virtual void drop(const QPoint &globalPos, Qt::MouseButtons b, Qt::KeyboardModifiers mods) override;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYDRAG_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeglcore.cpp b/src/plugins/platforms/openharmony/qopenharmonyeglcore.cpp
new file mode 100644
index 0000000000..77b5f52e2b
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeglcore.cpp
@@ -0,0 +1,339 @@
+#include "qopenharmonyeglcore.h"
+#include <EGL/egl.h>
+#include <GLES3/gl3.h>
+#include <QImage>
+#include "qopenharmonylog.h"
+#include <QDebug>
+
+EGLDisplay QOpenHarmonyEGLCore::m_eglDisplay = EGL_NO_DISPLAY;
+EGLConfig QOpenHarmonyEGLCore::m_eglConfig = nullptr;
+
+
+static char vertextShader[] =
+        "#version 300 es\n"
+        "layout (location = 0) in vec4 a_position;\n"
+        "layout (location = 1) in vec2 a_textCoord;\n"
+        "out vec2 v_texCoord;\n"
+        "void main() { \n"
+        "     gl_Position  = a_position;\n"
+        "     v_texCoord = a_textCoord;\n"
+        "}\n";
+
+static char fragmentShader[] =
+        "#version 300 es\n"
+        "precision mediump float;\n"
+        "in vec2 v_texCoord;\n"
+        "layout(location = 0) out vec4 outColor;\n"
+        "uniform sampler2D s_TextureMap;\n"
+        "void main() {\n"
+        "     outColor = texture(s_TextureMap,v_texCoord);\n"
+        "}\n";
+
+QOpenHarmonyEGLCore::QOpenHarmonyEGLCore()
+{
+
+}
+
+QOpenHarmonyEGLCore::~QOpenHarmonyEGLCore()
+{
+    if (m_eglSurface != EGL_NO_SURFACE) {
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+    }
+}
+
+void QOpenHarmonyEGLCore::init()
+{
+    m_eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (Q_UNLIKELY(m_eglDisplay == EGL_NO_DISPLAY)) {
+        LOGE("Could not open egl display");
+        return;
+    }
+
+    EGLint major, minor;
+    if (Q_UNLIKELY(!eglInitialize(m_eglDisplay, &major, &minor))) {
+        m_eglDisplay = EGL_NO_DISPLAY;
+        LOGE("Could not initialize egl display");
+    }
+
+    if (Q_UNLIKELY(!eglBindAPI(EGL_OPENGL_ES_API))) {
+        LOGE("Could not bind GL_ES API");
+        return;
+    }
+
+    m_eglConfig = initConfig();
+    if (m_eglConfig == nullptr) {
+        LOGE("init config error");
+        return;
+    }
+}
+
+bool QOpenHarmonyEGLCore::valid() const
+{
+    return m_valid;
+}
+
+void QOpenHarmonyEGLCore::createSurface(EGLNativeWindowType window, int w, int h)
+{
+    if (m_eglSurface != EGL_NO_SURFACE) {
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+    }
+    LOGI("QOpenHarmonyEGLCore::init window = %{public}p, w = %{public}d, h = %{public}d.", window, w, h);
+    m_width = w;
+    m_height = h;
+    m_eglWindow = window;
+    // 1. Create EGL Surface from Native Window
+    // Todo 
+    EGLint winAttribs[] = {EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR, EGL_NONE};
+    if (m_eglWindow) {
+        m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, m_eglWindow, winAttribs);
+        if (m_eglSurface == nullptr) {
+            LOGE("EGLCore::eglCreateWindowSurface eglSurface is null, error code %{public}x", eglGetError());
+            return;
+        }
+    }
+    m_valid = true;
+}
+
+void QOpenHarmonyEGLCore::updateSurfaceSize(int w, int h)
+{
+    m_width = w;
+    m_height = h;
+    if (m_image.isNull()) {
+        QImage::Format format = QImage::Format_RGBA8888_Premultiplied;
+        m_image = QImage(w, h, format);
+        m_image.fill(Qt::white);
+    } else {
+        m_image = m_image.scaled(w, h, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+    }
+//    drawImage(m_image);
+}
+
+EGLConfig QOpenHarmonyEGLCore::initConfig(int version) {
+    int attribList[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RED_SIZE, 8,
+        EGL_GREEN_SIZE, 8,
+        EGL_BLUE_SIZE, 8,
+        EGL_ALPHA_SIZE, 8,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_NONE
+    };
+    EGLConfig configs = NULL;
+    int configsNum;
+    eglChooseConfig(m_eglDisplay, attribList, &configs, 1, &configsNum);
+    return configs;
+}
+
+void QOpenHarmonyEGLCore::createTexture()
+{
+    glActiveTexture(GL_TEXTURE0);
+    glGenTextures(1, &m_TextureId);
+    glBindTexture(GL_TEXTURE_2D, m_TextureId);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+}
+
+EGLSurface QOpenHarmonyEGLCore::eglSurface() const
+{
+    return m_eglSurface;
+}
+
+QImage QOpenHarmonyEGLCore::image() const
+{
+    return m_image;
+}
+
+void QOpenHarmonyEGLCore::initCore()
+{
+    // 1. Create EGLContext from
+    int attrib3_list[] = {
+        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_NONE
+    };
+
+    m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, m_sharedEGLContext, attrib3_list);
+
+    if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext)) {
+        LOGE("EGLCore::eglMakeCurrent error = %{public}d", eglGetError());
+    }
+    m_program = createProgram(vertextShader, fragmentShader);
+    if (!m_program) {
+        LOGE("Could not create createProgram");
+        return;
+    } else {
+        m_samplerLoc = glGetUniformLocation(m_program, "s_TextureMap");
+    }
+
+    createTexture();
+    m_inited = true;
+}
+
+void QOpenHarmonyEGLCore::drawImage(const QImage &image)
+{
+    if (!m_valid)
+        return;
+    if (!m_inited)
+        initCore();
+
+    if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext)) {
+        LOGE("EGLCore::eglMakeCurrent error = %{public}d", eglGetError());
+    }
+    glViewport(0, 0, m_width, m_height);
+//    glClearColor(1.0, 1.0, 1.0, 1.0);
+//    glClear(GL_COLOR_BUFFER_BIT);
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, m_TextureId);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.width(), image.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image.bits());
+    glBindTexture(GL_TEXTURE_2D, GL_NONE);
+
+    static GLfloat verticesCoords[] = {
+        -1.0f,  1.0f, 0.0f,  // Position 0
+        -1.0f, -1.0f, 0.0f,  // Position 1
+        1.0f, -1.0f, 0.0f,  // Position 2
+        1.0f,  1.0f, 0.0f,  // Position 3
+    };
+    // 4 texture coord
+    static GLfloat textureCoords[] = {
+        0.0f,  0.0f,        // TexCoord 0
+        0.0f,  1.0f,        // TexCoord 1
+        1.0f,  1.0f,        // TexCoord 2
+        1.0f,  0.0f         // TexCoord 3
+    };
+
+    // render container
+    glUseProgram(m_program);
+    // Load the vertex position
+    glVertexAttribPointer (0, 3, GL_FLOAT,
+                           GL_FALSE, 3 * sizeof (GLfloat), verticesCoords);
+    // Load the texture coordinate
+    glVertexAttribPointer (1, 2, GL_FLOAT,
+                           GL_FALSE, 2 * sizeof (GLfloat), textureCoords);
+
+    glEnableVertexAttribArray (0);
+    glEnableVertexAttribArray (1);
+
+    // Bind the RGBA map
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, m_TextureId);
+
+    // Set the RGBA map sampler to texture unit to 0
+    glUniform1i(m_samplerLoc, 0);
+    static GLushort indices[] = { 0, 1, 2, 0, 2, 3 };
+    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);
+    update();
+    if (m_image.size() != image.size())
+        m_image = image.scaled(m_width, m_height, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+    else
+        m_image = image;
+}
+
+void QOpenHarmonyEGLCore::update()
+{
+    eglSwapBuffers(m_eglDisplay, m_eglSurface);
+}
+
+GLuint QOpenHarmonyEGLCore::loadShader(GLenum type, const char *shaderSrc)
+{
+    GLuint shader;
+    GLint compiled;
+
+    shader = glCreateShader(type);
+    if (shader == 0) {
+        LOGE("LoadShader shader error");
+        return 0;
+    }
+
+    glShaderSource(shader, 1, &shaderSrc, nullptr);
+    glCompileShader(shader);
+
+    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
+
+    if (!compiled) {
+        GLint infoLen = 0;
+        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
+
+        if (infoLen > 1) {
+            char *infoLog = (char*)malloc(sizeof(char) * infoLen);
+            glGetShaderInfoLog(shader, infoLen, nullptr, infoLog);
+            LOGE("Error compiling shader:\n%s\n",infoLog);
+            free(infoLog);
+        }
+        glDeleteShader(shader);
+        return 0;
+    }
+    return shader;
+}
+
+GLuint QOpenHarmonyEGLCore::createProgram(const char *vertexShader, const char *fragShader)
+{
+    GLuint vertex;
+    GLuint fragment;
+    GLuint program;
+    GLint linked;
+
+    vertex = loadShader(GL_VERTEX_SHADER, vertexShader);
+    if (vertex == 0) {
+        LOGE("createProgram vertex error");
+        return 0;
+    }
+
+    fragment = loadShader(GL_FRAGMENT_SHADER, fragShader);
+    if (fragment == 0) {
+        LOGE("createProgram fragment error");
+        glDeleteShader(vertex);
+        return 0;
+    }
+
+    program = glCreateProgram();
+    if (program == 0) {
+        LOGE("createProgram program error");
+        glDeleteShader(vertex);
+        glDeleteShader(fragment);
+        return 0;
+    }
+
+    glAttachShader(program, vertex);
+    glAttachShader(program, fragment);
+    glLinkProgram(program);
+    glGetProgramiv(program, GL_LINK_STATUS, &linked);
+    if (!linked) {
+        LOGE("createProgram linked error");
+        GLint infoLen = 0;
+        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLen);
+        if (infoLen > 1) {
+            char *infoLog = (char *)malloc(sizeof(char) * infoLen);
+            glGetProgramInfoLog(program, infoLen, nullptr, infoLog);
+            LOGE("Error linking program:\n%s\n",infoLog);
+            free(infoLog);
+        }
+        glDeleteShader(vertex);
+        glDeleteShader(fragment);
+        glDeleteProgram(program);
+        return 0;
+    }
+    glDeleteShader(vertex);
+    glDeleteShader(fragment);
+
+    return program;
+}
+
+EGLConfig QOpenHarmonyEGLCore::eglConfig()
+{
+    return m_eglConfig;
+}
+
+void QOpenHarmonyEGLCore::clear()
+{
+    if (m_eglDisplay != EGL_NO_DISPLAY)
+        eglTerminate(m_eglDisplay);
+}
+
+EGLDisplay QOpenHarmonyEGLCore::eglDisplay()
+{
+    return m_eglDisplay;
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeglcore.h b/src/plugins/platforms/openharmony/qopenharmonyeglcore.h
new file mode 100644
index 0000000000..625cf14089
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeglcore.h
@@ -0,0 +1,58 @@
+#ifndef QOPENHARMONYEGLCORE_H
+#define QOPENHARMONYEGLCORE_H
+
+#include <GLES3/gl3.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <QtGui/qimage.h>
+
+class QOpenHarmonyEGLCore
+{
+public:
+    QOpenHarmonyEGLCore();
+    ~QOpenHarmonyEGLCore();
+
+    static void init();
+
+    bool valid() const;
+
+    void createSurface(EGLNativeWindowType window, int w, int h);
+    void updateSurfaceSize(int w, int h);
+    void drawImage(const QImage &image);
+
+public:
+    static EGLDisplay eglDisplay();
+
+    static EGLConfig eglConfig();
+
+    static void clear();
+
+    EGLSurface eglSurface() const;
+
+    QImage image() const;
+
+private:
+    void initCore();
+    static EGLConfig initConfig(int version = 3);
+    void update();
+    GLuint loadShader(GLenum type, const char *shaderSrc);
+    GLuint createProgram(const char *vertexShader, const char *fragShader);
+    void createTexture();
+
+    EGLNativeWindowType m_eglWindow = 0;
+    static EGLDisplay m_eglDisplay;
+    static EGLConfig m_eglConfig;
+    EGLContext m_eglContext = EGL_NO_CONTEXT;
+    EGLContext m_sharedEGLContext = EGL_NO_CONTEXT;
+    EGLSurface m_eglSurface = nullptr;
+    GLuint m_program;
+    GLuint m_TextureId;
+    GLint m_samplerLoc;
+    int m_width;
+    int m_height;
+    bool m_valid = false;
+    bool m_inited = false;
+    QImage m_image;
+};
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.cpp b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.cpp
new file mode 100644
index 0000000000..d86340340b
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.cpp
@@ -0,0 +1,127 @@
+#include "qopenharmonyeventdispatcher.h"
+
+QOpenHarmonyEventDispatcher::QOpenHarmonyEventDispatcher(QObject *parent) :
+    QUnixEventDispatcherQPA(parent)
+{
+    QOpenHarmonyEventDispatcherStopper::instance()->addEventDispatcher(this);
+}
+
+QOpenHarmonyEventDispatcher::~QOpenHarmonyEventDispatcher()
+{
+    QOpenHarmonyEventDispatcherStopper::instance()->removeEventDispatcher(this);
+}
+
+enum States {Running = 0, StopRequest = 1, Stopping = 2};
+
+void QOpenHarmonyEventDispatcher::start()
+{
+    int prevState = m_stopRequest.fetchAndStoreAcquire(Running);
+    if (prevState == Stopping) {
+        m_semaphore.release();
+        wakeUp();
+    } else if (prevState == Running) {
+        qWarning("Error: start without corresponding stop");
+    }
+    //else if prevState == StopRequest, no action needed
+}
+
+void QOpenHarmonyEventDispatcher::stop()
+{
+    if (m_stopRequest.testAndSetAcquire(Running, StopRequest))
+        wakeUp();
+    else
+        qWarning("Error: start/stop out of sync");
+}
+
+void QOpenHarmonyEventDispatcher::goingToStop(bool stop)
+{
+    m_goingToStop.store(stop ? 1 : 0);
+    if (!stop)
+        wakeUp();
+}
+
+class OpenHarmonyDeadlockProtector
+{
+public:
+    OpenHarmonyDeadlockProtector()
+        : m_acquired(0)
+    {
+    }
+
+    ~OpenHarmonyDeadlockProtector() {
+        if (m_acquired)
+            s_blocked.storeRelease(0);
+    }
+
+    bool acquire() {
+        m_acquired = s_blocked.testAndSetAcquire(0, 1);
+        return m_acquired;
+    }
+
+private:
+    static QAtomicInt s_blocked;
+    int m_acquired;
+};
+
+QAtomicInt OpenHarmonyDeadlockProtector::s_blocked(0);
+
+bool QOpenHarmonyEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags)
+{
+    if (m_goingToStop.load())
+        flags |= QEventLoop::ExcludeSocketNotifiers | QEventLoop::X11ExcludeTimers;
+
+    {
+        OpenHarmonyDeadlockProtector protector;
+        if (protector.acquire() && m_stopRequest.testAndSetAcquire(StopRequest, Stopping)) {
+            m_semaphore.acquire();
+            wakeUp();
+        }
+    }
+
+    return QUnixEventDispatcherQPA::processEvents(flags);
+}
+
+QOpenHarmonyEventDispatcherStopper *QOpenHarmonyEventDispatcherStopper::instance()
+{
+    static QOpenHarmonyEventDispatcherStopper openharmonyEventDispatcherStopper;
+    return &openharmonyEventDispatcherStopper;
+}
+
+void QOpenHarmonyEventDispatcherStopper::startAll()
+{
+    QMutexLocker lock(&m_mutex);
+    if (!m_started.testAndSetOrdered(0, 1))
+        return;
+
+    for (QOpenHarmonyEventDispatcher *d : qAsConst(m_dispatchers))
+        d->start();
+}
+
+void QOpenHarmonyEventDispatcherStopper::stopAll()
+{
+    QMutexLocker lock(&m_mutex);
+    if (!m_started.testAndSetOrdered(1, 0))
+        return;
+
+    for (QOpenHarmonyEventDispatcher *d : qAsConst(m_dispatchers))
+        d->stop();
+}
+
+void QOpenHarmonyEventDispatcherStopper::addEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher)
+{
+    QMutexLocker lock(&m_mutex);
+    m_dispatchers.push_back(dispatcher);
+}
+
+void QOpenHarmonyEventDispatcherStopper::removeEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher)
+{
+    QMutexLocker lock(&m_mutex);
+    m_dispatchers.erase(std::find(m_dispatchers.begin(), m_dispatchers.end(), dispatcher));
+}
+
+void QOpenHarmonyEventDispatcherStopper::goingToStop(bool stop)
+{
+    QMutexLocker lock(&m_mutex);
+    for (QOpenHarmonyEventDispatcher *d : qAsConst(m_dispatchers))
+        d->goingToStop(stop);
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.h b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.h
new file mode 100644
index 0000000000..51fe72e96e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.h
@@ -0,0 +1,46 @@
+#ifndef QOPENHARMONYEVENTDISPATCHER_H
+#define QOPENHARMONYEVENTDISPATCHER_H
+
+#include <QtCore/QMutex>
+#include <QtCore/QSemaphore>
+#include <QtEventDispatcherSupport/private/qunixeventdispatcher_qpa_p.h>
+
+class QOpenHarmonyEventDispatcher : public QUnixEventDispatcherQPA
+{
+    Q_OBJECT
+public:
+    explicit QOpenHarmonyEventDispatcher(QObject *parent = 0);
+    ~QOpenHarmonyEventDispatcher();
+    void start();
+    void stop();
+
+    void goingToStop(bool stop);
+
+protected:
+    bool processEvents(QEventLoop::ProcessEventsFlags flags) override;
+
+private:
+    QAtomicInt m_stopRequest;
+    QAtomicInt m_goingToStop;
+    QSemaphore m_semaphore;
+};
+
+class QOpenHarmonyEventDispatcherStopper
+{
+public:
+    static QOpenHarmonyEventDispatcherStopper *instance();
+    static bool stopped() {return !instance()->m_started.load(); }
+    void startAll();
+    void stopAll();
+    void addEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher);
+    void removeEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher);
+    void goingToStop(bool stop);
+
+private:
+    QMutex m_mutex;
+    QAtomicInt m_started = 1;
+    QVector<QOpenHarmonyEventDispatcher *> m_dispatchers;
+};
+
+
+#endif // QOPENHARMONYEVENTDISPATCHER_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.cpp b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.cpp
new file mode 100644
index 0000000000..b3e4fd2f07
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.cpp
@@ -0,0 +1,466 @@
+#include "qopenharmonyfileenginehandler.h"
+#include "qopenharmonymain.h"
+
+#include <QSharedPointer>
+#include <QOpenHarmonyJsObjectLoader>
+#include <QOpenHarmonyJsObject>
+#include <QString>
+#include <QDebug>
+#include <rawfile/raw_file.h>
+#include <rawfile/raw_dir.h>
+#include <rawfile/raw_file_manager.h>
+
+QT_BEGIN_NAMESPACE
+
+typedef QVector<QString> FilesList;
+
+struct OpenHarmonyRawDir
+{
+    OpenHarmonyRawDir(RawDir* rd)
+    {
+        if (rd) {
+            const char *fileName;
+            int count = OH_ResourceManager_GetRawFileCount(rd);
+            for (int i = 0; i < count; ++i) {
+                const char *fileName = OH_ResourceManager_GetRawFileName(rd, i);
+                m_items.push_back(QString::fromUtf8(fileName));
+            }
+            OH_ResourceManager_CloseRawDir(rd);
+        }
+    }
+    FilesList m_items;
+};
+
+
+class OpenHarmonyAbstractFileEngineIterator: public QAbstractFileEngineIterator
+{
+public:
+    OpenHarmonyAbstractFileEngineIterator(QDir::Filters filters,
+                                      const QStringList &nameFilters,
+                                      QSharedPointer<OpenHarmonyRawDir> rd,
+                                      const QString &path)
+        : QAbstractFileEngineIterator(filters, nameFilters)
+    {
+        m_items = rd->m_items;
+        m_index = -1;
+        m_path = path;
+    }
+
+    QFileInfo currentFileInfo() const override
+    {
+        return QFileInfo(currentFilePath());
+    }
+
+    QString currentFileName() const override
+    {
+        if (m_index < 0 || m_index >= m_items.size())
+            return QString();
+        QString fileName = m_items[m_index];
+        if (fileName.endsWith(QLatin1Char('/')))
+            fileName.chop(1);
+        return fileName;
+    }
+
+    virtual QString currentFilePath() const
+    {
+        return m_path + currentFileName();
+    }
+
+    bool hasNext() const override
+    {
+        return m_items.size() && (m_index < m_items.size() - 1);
+    }
+
+    QString next() override
+    {
+        if (!hasNext())
+            return QString();
+        m_index++;
+        return currentFileName();
+    }
+
+private:
+    QString     m_path;
+    FilesList   m_items;
+    int         m_index;
+};
+
+
+class QOpenHarmonyRawfileEngine: public QAbstractFileEngine
+{
+public:
+   explicit QOpenHarmonyRawfileEngine(RawFile *file, const QString &fileName)
+        : m_file(file)
+        , m_fileName(fileName)
+    {
+
+    }
+
+    explicit QOpenHarmonyRawfileEngine(QSharedPointer<OpenHarmonyRawDir> ohrd, const QString &fileName)
+    {
+        m_file = 0;
+        m_dir = ohrd;
+        m_fileName =  fileName;
+        if (!m_fileName.endsWith(QLatin1Char('/')))
+            m_fileName += QLatin1Char('/');
+    }
+
+    bool open(QIODevice::OpenMode openMode) override
+    {
+        return m_file != 0 && (openMode & QIODevice::WriteOnly) == 0;
+    }
+
+    bool close() override
+    {
+        if (m_file) {
+            OH_ResourceManager_CloseRawFile(m_file);
+            m_file = 0;
+            return true;
+        }
+        return false;
+    }
+
+    qint64 size() const override
+    {
+        if (m_file)
+            return OH_ResourceManager_GetRawFileSize(m_file);
+        return -1;
+    }
+
+    qint64 pos() const override
+    {
+        if (m_file)
+            return OH_ResourceManager_GetRawFileOffset(m_file);
+        return -1;
+    }
+
+    bool seek(qint64 pos) override
+    {
+        if (m_file)
+            return pos == OH_ResourceManager_SeekRawFile(m_file, pos, 0);
+        return false;
+    }
+
+    qint64 read(char *data, qint64 maxlen) override
+    {
+        if (m_file)
+            return OH_ResourceManager_ReadRawFile(m_file, data, maxlen);
+        return -1;
+    }
+
+    bool isSequential() const override
+    {
+        return false;
+    }
+
+    bool caseSensitive() const override
+    {
+        return true;
+    }
+
+    bool isRelativePath() const override
+    {
+        return false;
+    }
+
+    FileFlags fileFlags(FileFlags type = FileInfoAll) const override
+    {
+        FileFlags flags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm|ExistsFlag);
+        if (m_file)
+            flags |= FileType;
+        if (!m_dir.isNull())
+            flags |= DirectoryType;
+
+        return type & flags;
+    }
+
+    QString fileName(FileName file = DefaultName) const override
+    {
+        int pos;
+        switch (file) {
+        case DefaultName:
+        case AbsoluteName:
+        case CanonicalName:
+                return m_fileName;
+        case BaseName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.mid(pos);
+            else
+                return m_fileName;
+        case PathName:
+        case AbsolutePathName:
+        case CanonicalPathName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.left(pos);
+            else
+                return m_fileName;
+        default:
+            return QString();
+        }
+    }
+
+    void setFileName(const QString &file) override
+    {
+        if (file == m_fileName)
+            return;
+
+        m_fileName = file;
+        close();
+    }
+
+    Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames) override
+    {
+        if (!m_dir.isNull())
+            return new OpenHarmonyAbstractFileEngineIterator(filters, filterNames, m_dir, m_fileName);
+        return 0;
+    }
+private:
+    RawFile *m_file;
+    QString m_fileName;
+    QSharedPointer<OpenHarmonyRawDir> m_dir;
+};
+
+
+class QOpenHarmonyFileEngine: public QAbstractFileEngine
+{
+public:
+    explicit QOpenHarmonyFileEngine(const QString &fileName)
+    {
+        m_fileName = fileName;
+        static int index = 0;
+        m_fileHandler = QString("fileHandler%1").arg(index++);
+        m_jsFile = qJsObjectLoader->create("JsFile", m_fileHandler, QVariantList() << m_fileName);
+    }
+
+    ~QOpenHarmonyFileEngine()
+    {
+        close();
+        if (!m_jsFile.isNull()) {
+            qJsObjectLoader->remove(m_fileHandler);
+        }
+    }
+
+    bool checkJsFile() const
+    {
+        if (m_jsFile.isNull() || !m_jsFile->isValid()) {
+            qWarning() << "js file object is invalid";
+            return false;
+        }
+        return true;
+    }
+
+    bool open(QIODevice::OpenMode openMode) override
+    {
+        if (!checkJsFile())
+            return false;
+
+//        const READ_ONLY = 0o0; // Read only Permission
+//        const WRITE_ONLY = 0o1; // Write only Permission
+//        const READ_WRITE = 0o2; // Write and Read Permission
+//        const CREATE = 0o100; // If not exist, create file
+//        const TRUNC = 0o1000; // File truncate len 0
+//        const APPEND = 0o2000; // File append write
+//        const NONBLOCK = 0o4000; // File open in nonblocking mode
+//        const DIR = 0o200000; // File is Dir
+//        const NOFOLLOW = 0o400000; // File is not symbolic link
+//        const SYNC = 0o4010000; // SYNC IO
+
+        int mode = 0;
+        if (openMode & QIODevice::ReadOnly) {
+
+        }
+        if (openMode & QIODevice::WriteOnly) {
+            mode |= 1;
+        }
+        if (openMode & QIODevice::Append) {
+            mode |= 02000;
+        }
+
+        if (openMode & QIODevice::Truncate) {
+            mode |= 01000;
+        }
+
+        return m_jsFile->call<bool>("open", mode);
+    }
+
+    bool flush()
+    {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("flush");
+    }
+
+    bool close() override
+    {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("close");
+    }
+
+    qint64 size() const override
+    {
+        if (!checkJsFile())
+            return -1;
+        return m_jsFile->call<qint64>("size");
+    }
+
+    qint64 pos() const override
+    {
+        if (!checkJsFile())
+            return -1;
+        return m_jsFile->call<qint64>("pos");
+    }
+
+    bool seek(qint64 pos) override
+    {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("seek", pos);
+    }
+
+    qint64 read(char *data, qint64 maxlen) override
+    {
+        if (!checkJsFile())
+            return -1;
+        QByteArray result = m_jsFile->call<QByteArray>("read", maxlen);
+        qint64 l = result.length();
+        memcpy(data, result.constData(), qMin(l, maxlen));
+        return l;
+    }
+
+    bool isSequential() const override
+    {
+        return false;
+    }
+
+    bool caseSensitive() const override
+    {
+        return true;
+    }
+
+    bool isRelativePath() const override
+    {
+        return false;
+    }
+
+    FileFlags fileFlags(FileFlags type = FileInfoAll) const override
+    {
+        FileFlags flags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm|ExistsFlag);
+        if (m_jsFile->isValid()) {
+            flags |= FileType;
+        }
+
+        return type & flags;
+    }
+
+    QString fileName(FileName file = DefaultName) const override
+    {
+        int pos;
+        switch (file) {
+        case DefaultName:
+        case AbsoluteName:
+        case CanonicalName:
+                return m_fileName;
+        case BaseName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.mid(pos);
+            else
+                return m_fileName;
+        case PathName:
+        case AbsolutePathName:
+        case CanonicalPathName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.left(pos);
+            else
+                return m_fileName;
+        default:
+            return QString();
+        }
+    }
+
+    void setFileName(const QString &file) override
+    {
+        if (file == m_fileName)
+            return;
+
+        m_fileName = file;
+
+
+        close();
+    }
+
+    qint64 write(const char *data, qint64 len) override
+    {
+        if (!checkJsFile())
+            return -1;
+        QByteArray dataArrary = QByteArray(data, len);
+        qint64 result = m_jsFile->call<qint64>("write", dataArrary);
+        return result;
+    }
+
+private:
+    QString m_fileName;
+    QString m_fileHandler;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsFile;
+};
+
+
+QOpenHarmonyFileEngineHandler::QOpenHarmonyFileEngineHandler()
+    : m_rawDirCache(5)
+    , m_hasPrepopulatedCache(false)
+    , m_hasTriedPrepopulatingCache(false)
+{
+
+}
+
+QAbstractFileEngine *QOpenHarmonyFileEngineHandler::create(const QString &fileName) const
+{
+    if (fileName.isEmpty())
+        return 0;
+
+    static QLatin1String datasharePrefix("datashare:");
+    static QLatin1String rawfilePrefix("rawfile:/");
+
+    if (!fileName.startsWith(datasharePrefix) && !fileName.startsWith(rawfilePrefix))
+        return 0;
+
+    if (fileName.startsWith(datasharePrefix))
+        return new QOpenHarmonyFileEngine(fileName);
+
+    if (fileName.startsWith(rawfilePrefix)) {
+        QString _fileName = fileName;
+        _fileName.replace("rawfile:/", "");
+        QByteArray byteArray = _fileName.toLatin1();
+        RawFile *file = OH_ResourceManager_OpenRawFile(QtOpenHarmony::resourceManager(), byteArray.constData());
+        if (file != nullptr) {
+            return new QOpenHarmonyRawfileEngine(file, fileName);
+        }
+        return 0;
+
+        //Todo OH_ResourceManager_OpenRawDir
+
+//        m_rawfileCacheMutext.lock();
+//        QSharedPointer<OpenHarmonyRawDir> *ohrd = m_rawDirCache.object(_fileName.toLatin1());
+//        m_rawfileCacheMutext.unlock();
+
+//        if (!ohrd) {
+//            if (!m_hasPrepopulatedCache) {
+//                RawDir *rd = OH_ResourceManager_OpenRawDir(QtOpenHarmony::resourceManager(), byteArray.constData());
+//                if (rd) {
+//                    ohrd = new QSharedPointer<OpenHarmonyRawDir>(new OpenHarmonyRawDir(rd));
+//                    m_rawfileCacheMutext.lock();
+//                    m_rawDirCache.insert(_fileName.toLatin1(), ohrd);
+//                    m_rawfileCacheMutext.unlock();
+//                    return 0;
+//                    return new QOpenHarmonyRawfileEngine(*ohrd, fileName);
+//                }
+//                return 0;
+//            }
+//        } else {
+//            return new QOpenHarmonyRawfileEngine(*ohrd, fileName);
+//        }
+    }
+    return 0;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.h b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.h
new file mode 100644
index 0000000000..b81d93de63
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.h
@@ -0,0 +1,28 @@
+#ifndef QOPENHARMONYFILEENGINEHANDLER_H
+#define QOPENHARMONYFILEENGINEHANDLER_H
+
+#include <QtCore/private/qabstractfileengine_p.h>
+#include <QString>
+#include <QCache>
+#include <QMutex>
+#include <QSharedPointer>
+
+QT_BEGIN_NAMESPACE
+struct OpenHarmonyRawDir;
+
+class Q_CORE_EXPORT QOpenHarmonyFileEngineHandler : public QAbstractFileEngineHandler
+{
+public:
+    QOpenHarmonyFileEngineHandler();
+    virtual QAbstractFileEngine *create(const QString &fileName) const override;
+private:
+
+    mutable QCache<QByteArray, QSharedPointer<OpenHarmonyRawDir>> m_rawDirCache;
+    mutable QMutex m_rawfileCacheMutext;
+    mutable bool m_hasPrepopulatedCache;
+    mutable bool m_hasTriedPrepopulatingCache;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYFILEENGINEHANDLER_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonylog.h b/src/plugins/platforms/openharmony/qopenharmonylog.h
new file mode 100644
index 0000000000..1a88d88b24
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonylog.h
@@ -0,0 +1,106 @@
+#ifndef QOPENHARMONYDEFINES_H
+#define QOPENHARMONYDEFINES_H
+#include <hilog/log.h>
+
+#define NAPI_RETVAL_NOTHING
+
+#define GET_AND_THROW_LAST_ERROR(env)                                                                   \
+    do {                                                                                                \
+        const napi_extended_error_info* errorInfo = nullptr;                                            \
+        napi_get_last_error_info((env), &errorInfo);                                                    \
+        bool isPending = false;                                                                         \
+        napi_is_exception_pending((env), &isPending);                                                   \
+        if (!isPending && errorInfo != nullptr) {                                                       \
+            const char* errorMessage =                                                                  \
+                errorInfo->error_message != nullptr ? errorInfo->error_message : "empty error message"; \
+            napi_throw_error((env), nullptr, errorMessage);                                             \
+        }                                                                                               \
+    } while (0)
+
+#define NAPI_ASSERT_BASE(env, assertion, message, retVal)                                    \
+    do {                                                                                     \
+        if (!(assertion)) {                                                                  \
+            napi_throw_error((env), nullptr, "assertion (" #assertion ") failed: " message); \
+            return retVal;                                                                   \
+        }                                                                                    \
+    } while (0)
+
+#define NAPI_ASSERT(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, nullptr)
+
+#define NAPI_ASSERT_RETURN_VOID(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_BASE(env, theCall, retVal) \
+    do {                                     \
+        if ((theCall) != napi_ok) {          \
+            GET_AND_THROW_LAST_ERROR((env)); \
+            return retVal;                   \
+        }                                    \
+    } while (0)
+
+#define NAPI_CALL_BASE_NO_THROW(env, theCall, retVal) \
+    do {                                     \
+        if ((theCall) != napi_ok) {          \
+            return retVal;                   \
+        }                                    \
+    } while (0)
+
+#define NAPI_CALL(env, theCall) NAPI_CALL_BASE(env, theCall, nullptr)
+
+#define NAPI_CALL_RETURN_VOID(env, theCall) NAPI_CALL_BASE(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_RETURN_VOID_NO_THROW(env, theCall) NAPI_CALL_BASE_NO_THROW(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define DECLARE_NAPI_PROPERTY(name, val)                                       \
+    {                                                                          \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_STATIC_PROPERTY(name, val)                               \
+    {                                                                         \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION_WITH_DATA(name, func, data)                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, data    \
+    }
+
+#define DECLARE_NAPI_STATIC_FUNCTION(name, func)                                 \
+    {                                                                            \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER(name, getter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, (getter), nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_SETTER(name, setter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, nullptr, (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER_SETTER(name, getter, setter)                             \
+    {                                                                                \
+        (name), nullptr, nullptr, (getter), (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+
+#define QPA_LOG_DOMAIN 0xff00
+#define QPA_LOG_TAG "QpaForOpenHarmony"
+#define LOGI(...) ((void)OH_LOG_Print(LOG_APP, LOG_INFO, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGD(...) ((void)OH_LOG_Print(LOG_APP, LOG_DEBUG, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGW(...) ((void)OH_LOG_Print(LOG_APP, LOG_WARN, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGE(...) ((void)OH_LOG_Print(LOG_APP, LOG_ERROR, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+
+#endif // QOPENHARMONYDEFINES_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonymain.cpp b/src/plugins/platforms/openharmony/qopenharmonymain.cpp
new file mode 100644
index 0000000000..81e88a39d3
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonymain.cpp
@@ -0,0 +1,414 @@
+#include <memory>
+#include <semaphore.h>
+#include <dlfcn.h>
+#include <pthread.h>
+#include <napi/native_api.h>
+#include <rawfile/raw_file_manager.h>
+
+#include <QDir>
+#include <QHash>
+#include <QString>
+#include <QByteArray>
+#include <QJsonObject>
+#include <QJsonDocument>
+#include <QByteArray>
+#include <QString>
+#include <QStringList>
+#include <QGuiApplication>
+#include <QtCore/private/qopenharmonyhelpers_p.h>
+#include <QOpenHarmonyJsEnvironment>
+#include <QOpenHarmonyJsObjectPool>
+
+#include "qopenharmonyfileenginehandler.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonylog.h"
+#include "qopenharmonyxcomponentmanager.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonyplatformdialoghelpers.h"
+#include "qopenharmonyplatformclipboard.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyeventdispatcher.h"
+#include "qopenharmonyplatformwindow.h"
+
+extern "C" typedef int (*Main)(int, char **); //use the standard main method to start the application
+static Main m_main = nullptr;
+static void *m_mainLibraryHnd = nullptr;
+pthread_t m_qtAppThread = 0;
+static sem_t m_exitSemaphore, m_terminateSemaphore;
+static double m_scaledDensity = 0;
+static double m_density = 1.5;
+static int m_screenWidthPixels  = 0;
+static int m_screenHeightPixels = 0;
+static int m_desktopWidthPixels  = 0;
+static int m_desktopHeightPixels = 0;
+static NativeResourceManager *m_resourceManager = nullptr;
+static QOpenHarmonyPlatformIntegration *m_platformIntegration = nullptr;
+static QOpenHarmonyFileEngineHandler *m_openHarmonyFileEngineHandler = nullptr;
+static QString m_deviceType = "default";
+
+static void *startMainMethod(void *arg)
+{
+    if (nullptr == arg) {
+        return nullptr;
+    }
+
+    QVarLengthArray<const char *> params(1);
+    QByteArray p((char*)arg);
+    params[0] = static_cast<const char *>(p.constData());
+
+    int ret = m_main(1, const_cast<char **>(params.data()));
+
+    if (m_mainLibraryHnd) {
+        int res = dlclose(m_mainLibraryHnd);
+        if (res < 0)
+            LOGE("dlclose failed: %{public}s", dlerror());
+    }
+
+    sem_post(&m_terminateSemaphore);
+    sem_wait(&m_exitSemaphore);
+    sem_destroy(&m_exitSemaphore);
+
+    // We must call exit() to ensure that all global objects will be destructed
+    exit(ret);
+    return 0;
+}
+
+static napi_value startQtApplication(napi_env env, napi_callback_info info)
+{
+    napi_status status;
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return qJs::createBool(false);
+    }
+
+    QString bundleStr = qJs::getObjectPropertyValue<QString>(args[0], "bundleCodeDir");
+    QByteArray bundle = bundleStr.toLatin1();
+    if (bundle.isEmpty()) {
+        LOGE("args is vaild");
+        return qJs::createBool(false);
+    }
+
+#if defined(Q_PROCESSOR_ARM_64)
+    QByteArray libDir = bundle + "/libs/arm64";
+#elif defined(Q_PROCESSOR_ARM_32)
+    QByteArray libDir = bundle + "/libs/arm";
+#endif
+
+    QByteArrayList qmls = {bundle + "/entry/resources/rawfile"};
+    QString cacheQmlStr = qJs::getObjectPropertyValue<QString>(args[0], "qmlDir");
+    if (!cacheQmlStr.isEmpty())
+        qmls << cacheQmlStr.toLatin1();
+
+
+    if (::setenv("QT_QPA_PLATFORM_PLUGIN_PATH", libDir.constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_PLUGIN_PATH");
+    }
+    if (::setenv("QML_DISABLE_DISK_CACHE", "1", 1) != 0) {
+        LOGE("Can't set environment for QML_DISABLE_DISK_CACHE");
+    }
+    if (::setenv("QT_PLUGIN_PATH", libDir.constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_PLUGIN_PATH");
+    }
+
+    QByteArray qmlImportPath = qmls.join(":");
+    if (::setenv("QML2_IMPORT_PATH", qmlImportPath.constData(), 1) != 0) {
+        LOGE("Can't set environment for QML2_IMPORT_PATH");
+    }
+
+//    if (::setenv("QT_DEBUG_PLUGINS", "1", 1) != 0) {
+//        LOGE("Can't set environment for QT_DEBUG_PLUGINS");
+//    }
+
+    m_mainLibraryHnd = nullptr;
+    QByteArray fileName = qJs::getString(args[1]).toLatin1();
+    LOGI("load qt application %{public}s", fileName.constData());
+
+    //look for main()
+    // Obtain a handle to the main library (the library that contains the main() function).
+    m_mainLibraryHnd = dlopen(fileName.constData(), 0);
+    if (Q_UNLIKELY(!m_mainLibraryHnd)) {
+        QString error = QString("dlopen failed: %1").arg(dlerror());
+        LOGI("load qt application %{public}s failed%{public}s", fileName.constData(), dlerror());
+        napi_throw_type_error(env, NULL, error.toUtf8().constData());
+        return nullptr;
+    }
+    m_main = (Main)dlsym(m_mainLibraryHnd, "main");
+    if (Q_UNLIKELY(!m_main)) {
+        QString error = QString("dlsym failed: %1, Could not find main method.").arg(dlerror());
+        qJs::throwError(error.toUtf8().constData());
+        return qJs::createBool(false);
+    }
+    if (sem_init(&m_exitSemaphore, 0, 0) == -1)
+        return qJs::createBool(false);
+
+    if (sem_init(&m_terminateSemaphore, 0, 0) == -1)
+        return qJs::createBool(false);
+
+
+    m_openHarmonyFileEngineHandler = new QOpenHarmonyFileEngineHandler;
+
+    QByteArray applib = libDir + "/" + fileName;
+    pthread_create(&m_qtAppThread, nullptr, startMainMethod, (void*)applib.data());
+    return qJs::createBool(true);
+}
+
+static napi_value setResourceManager(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_resourceManager = OH_ResourceManager_InitNativeResourceManager(env, args[0]);
+    return nullptr;
+}
+
+static napi_value setDeviceType(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_deviceType = qJs::getString(args[0]);
+    return nullptr;
+}
+
+static napi_value setDisplayMetrics(napi_env env, napi_callback_info info)
+{
+    size_t argc = 8;
+    napi_value args[8];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 8) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    double value[8] = {0};
+    for (size_t i = 0; i < argc; ++i) {
+        value[i] = qJs::getDouble(args[i]);
+    }
+
+    m_screenWidthPixels = static_cast<int>(value[0]);
+    m_screenHeightPixels = static_cast<int>(value[1]);
+
+    m_density = value[2];
+    m_scaledDensity = value[3];
+
+    // openharmony old api, xdpi and ydpi is 0
+    double xdpi = value[4];
+    double ydpi = value[5];
+
+    m_desktopWidthPixels = static_cast<int>(value[6]);
+    m_desktopHeightPixels = static_cast<int>(value[7]);
+
+    m_screenWidthPixels = qMax(m_screenWidthPixels, m_desktopWidthPixels);
+    m_screenHeightPixels = qMax(m_screenHeightPixels, m_desktopHeightPixels);
+
+    if (m_platformIntegration == nullptr) {
+        QOpenHarmonyPlatformIntegration::setDefaultDisplayMetrics(m_desktopWidthPixels,
+                                                              m_desktopHeightPixels,
+                                                              qRound(double(m_screenWidthPixels)  / xdpi * 25.4),
+                                                              qRound(double(m_screenHeightPixels) / ydpi * 25.4),
+                                                              m_screenWidthPixels,
+                                                              m_screenHeightPixels);
+    } else {
+        m_platformIntegration->setDisplayMetrics(qRound(double(m_screenWidthPixels)  / xdpi * 25.4),
+                                                        qRound(double(m_screenHeightPixels) / ydpi * 25.4));
+        m_platformIntegration->setScreenSize(m_screenWidthPixels, m_screenHeightPixels);
+        m_platformIntegration->setDesktopSize(m_desktopWidthPixels, m_desktopHeightPixels);
+    }
+    return nullptr;
+}
+
+static napi_value updateApplicationState(napi_env env, napi_callback_info info)
+{
+    if (!m_main || !m_platformIntegration) {
+        return nullptr;
+    }
+
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments in updateApplicationState");
+        return nullptr;
+    }
+
+    Qt::ApplicationState qtState = Qt::ApplicationSuspended;
+
+//    Openharmony doc
+//    SHOWN = 1,
+//    ACTIVE,
+//    INACTIVE,
+//    HIDDEN
+
+    int32_t state = qJs::getInt32(args[0]);
+    switch (state) {
+    case 1:
+        qtState = Qt::ApplicationActive;
+        break;
+    case 2:
+        qtState = Qt::ApplicationActive;
+        break;
+    case 3:
+        qtState = Qt::ApplicationInactive;
+        break;
+    case 4:
+        qtState = Qt::ApplicationSuspended;
+    }
+
+    if (qtState == Qt::ApplicationActive)
+        QtHarmonyPrivate::handleResume();
+    else if (state == Qt::ApplicationInactive)
+        QtHarmonyPrivate::handlePause();
+
+    if (qtState <= Qt::ApplicationInactive) {
+        // NOTE: sometimes we will receive two consecutive suspended notifications,
+        // In the second suspended notification, QWindowSystemInterface::flushWindowSystemEvents()
+        // will deadlock since the dispatcher has been stopped in the first suspended notification.
+        // To avoid the deadlock we simply return if we found the event dispatcher has been stopped.
+        if (QOpenHarmonyEventDispatcherStopper::instance()->stopped())
+            return nullptr;
+
+        // Don't send timers and sockets events anymore if we are going to hide all windows
+        QOpenHarmonyEventDispatcherStopper::instance()->goingToStop(true);
+        QWindowSystemInterface::handleApplicationStateChanged(qtState);
+        if (state == Qt::ApplicationSuspended)
+            QOpenHarmonyEventDispatcherStopper::instance()->stopAll();
+    } else {
+        QOpenHarmonyEventDispatcherStopper::instance()->startAll();
+        QWindowSystemInterface::handleApplicationStateChanged(qtState);
+        QOpenHarmonyEventDispatcherStopper::instance()->goingToStop(false);
+    }
+    return nullptr;
+}
+
+static napi_value quitQtApplication(napi_env env, napi_callback_info info)
+{
+    if (m_openHarmonyFileEngineHandler != nullptr) {
+        delete m_openHarmonyFileEngineHandler;
+        m_openHarmonyFileEngineHandler = nullptr;
+    }
+    LOGI("quit qt application");
+    OH_ResourceManager_ReleaseNativeResourceManager(m_resourceManager);
+    qApp->quit();
+    return nullptr;
+}
+
+static napi_value qtMajorVersion(napi_env env, napi_callback_info info)
+{
+    return qJs::createInt32(QT_VERSION_MAJOR);
+}
+
+/*
+ * function for module exports
+ */
+EXTERN_C_START
+static napi_value Init(napi_env env, napi_value exports)
+{
+    static bool inited = false;
+    QOpenHarmonyXComponentManager::init(env, exports);
+    if (!inited) {
+        napi_property_descriptor desc[] ={
+            DECLARE_NAPI_FUNCTION("startQtApplication", startQtApplication),
+            DECLARE_NAPI_FUNCTION("setDisplayMetrics", setDisplayMetrics),
+            DECLARE_NAPI_FUNCTION("updateApplicationState", updateApplicationState),
+            DECLARE_NAPI_FUNCTION("setResourceManager", setResourceManager),
+            DECLARE_NAPI_FUNCTION("quitQtApplication", quitQtApplication),
+            DECLARE_NAPI_FUNCTION("qtMajorVersion", qtMajorVersion),
+            DECLARE_NAPI_FUNCTION("setDeviceType", setDeviceType),
+        };
+        NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+        QOpenHarmonyPlatformInputContext::init(env, exports);
+        QOpenHarmonyPlatformMessageDialogHelper::init(env, exports);
+        QOpenHarmonyPlatformFileDialogHelper::init(env, exports);
+
+    #ifndef QT_NO_CLIPBOARD
+        QOpenHarmonyPlatformClipboard::init(env, exports);
+    #endif
+        qJs::init(env);
+        inited = true;
+    }
+    return exports;
+}
+EXTERN_C_END
+
+/*
+ * Napi Module define
+ */
+static napi_module openharmonyPluginModule = {
+    .nm_version = 1,
+    .nm_flags = 0,
+    .nm_filename = nullptr,
+    .nm_register_func = Init,
+    .nm_modname = "plugins_platforms_qopenharmony",
+    .nm_priv = ((void*)0),
+    .reserved = { 0 },
+};
+/*
+ * Module register function
+ */
+extern "C" __attribute__((constructor)) void RegisterModule(void)
+{
+    napi_module_register(&openharmonyPluginModule);
+}
+
+double QtOpenHarmony::scaledDensity()
+{
+    return m_scaledDensity;
+}
+
+double QtOpenHarmony::pixelDensity()
+{
+    return m_density;
+}
+
+void QtOpenHarmony::setOpenHarmonyPlatformIntegration(QOpenHarmonyPlatformIntegration *integration)
+{
+    m_platformIntegration = integration;
+}
+
+void QtOpenHarmony::updateDisplayMetrics(int w, int h)
+{
+//    m_screenWidthPixels = w;
+//    m_screenHeightPixels = h;
+
+////    openharmony xdpi and ydpi is 0
+//    double xdpi = 72;
+//    double ydpi = 72;
+//    if (m_platformIntegration == nullptr) {
+//        QOpenHarmonyPlatformIntegration::setDefaultDisplayMetrics(m_screenWidthPixels,
+//                                                                  m_screenHeightPixels,
+//                                                                  qRound(double(m_screenWidthPixels)  / xdpi * 25.4),
+//                                                                  qRound(double(m_screenHeightPixels) / ydpi * 25.4),
+//                                                                  m_screenWidthPixels,
+//                                                                  m_screenHeightPixels);
+//    } else {
+//        m_platformIntegration->setDisplayMetrics(qRound(double(m_desktopWidthPixels)  / xdpi * 25.4),
+//                                                 qRound(double(m_desktopHeightPixels) / ydpi * 25.4));
+//        m_platformIntegration->setScreenSize(m_screenWidthPixels, m_screenHeightPixels);
+//        m_platformIntegration->setDesktopSize(m_screenWidthPixels, m_screenWidthPixels);
+//    }
+}
+
+NativeResourceManager *QtOpenHarmony::resourceManager()
+{
+    return m_resourceManager;
+}
+
+bool QtOpenHarmony::isPhone()
+{
+    return m_deviceType == "default";
+}
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonymain.h b/src/plugins/platforms/openharmony/qopenharmonymain.h
new file mode 100644
index 0000000000..2dc9b9fb71
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonymain.h
@@ -0,0 +1,24 @@
+#ifndef QOPENHARMONYMAIN_H
+#define QOPENHARMONYMAIN_H
+
+#include <napi/native_api.h>
+class QOpenHarmonyPlatformIntegration;
+struct NativeResourceManager;
+
+namespace QtOpenHarmony {
+
+void setOpenHarmonyPlatformIntegration(QOpenHarmonyPlatformIntegration *integration);
+
+double scaledDensity();
+
+double pixelDensity();
+
+void updateDisplayMetrics(int w, int h);
+
+bool isPhone();
+
+NativeResourceManager *resourceManager();
+
+}
+
+#endif //QOPENHARMONYMAIN_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.cpp
new file mode 100644
index 0000000000..a6a9c436fe
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.cpp
@@ -0,0 +1,48 @@
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformwindow.h"
+#include <qpa/qplatformscreen.h>
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformBackingStore::QOpenHarmonyPlatformBackingStore(QWindow *window)
+    : QPlatformBackingStore(window)
+{
+    if (window->handle())
+        setBackingStore(window);
+}
+
+QPaintDevice *QOpenHarmonyPlatformBackingStore::paintDevice()
+{
+    return &m_image;
+}
+
+void QOpenHarmonyPlatformBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+{
+    Q_UNUSED(offset);
+
+    if (!m_backingStoreSet)
+        setBackingStore(window);
+
+    (static_cast<QOpenHarmonyPlatformWindow *>(window->handle()))->repaint(region);
+}
+
+void QOpenHarmonyPlatformBackingStore::resize(const QSize &size, const QRegion &staticContents)
+{
+    Q_UNUSED(staticContents);
+
+    if (m_image.size() != size)
+        m_image = QImage(size, window()->screen()->handle()->format());
+}
+
+void QOpenHarmonyPlatformBackingStore::setBackingStore(QWindow *window)
+{
+    if (window->surfaceType() == QSurface::RasterSurface || window->surfaceType() == QSurface::RasterGLSurface) {
+        (static_cast<QOpenHarmonyPlatformWindow *>(window->handle()))->setBackingStore(this);
+        m_backingStoreSet = true;
+    } else {
+        qWarning("QOpenHarmonyPlatformBackingStore does not support OpenGL-only windows.");
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.h b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.h
new file mode 100644
index 0000000000..db75831b39
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.h
@@ -0,0 +1,25 @@
+#ifndef QOPENHARMONYPLATFORMBACKINGSTORE_H
+#define QOPENHARMONYPLATFORMBACKINGSTORE_H
+
+#include <qpa/qplatformbackingstore.h>
+#include <qpa/qwindowsysteminterface.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformBackingStore : public QPlatformBackingStore
+{
+public:
+    explicit QOpenHarmonyPlatformBackingStore(QWindow *window);
+    QPaintDevice *paintDevice() override;
+    void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
+    void resize(const QSize &size, const QRegion &staticContents) override;
+    QImage toImage() const override { return m_image; }
+    void setBackingStore(QWindow *window);
+protected:
+    QImage m_image;
+    bool m_backingStoreSet = false;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMBACKINGSTORE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.cpp
new file mode 100644
index 0000000000..c0694de72e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.cpp
@@ -0,0 +1,86 @@
+#include "qopenharmonyplatformclipboard.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyjsobjectloader.h"
+
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+
+#include <QTimer>
+#include <QThread>
+
+#ifndef QT_NO_CLIPBOARD
+
+#define qClipBoard QOpenHarmonyPlatformClipboard::instance()
+
+QOpenHarmonyPlatformClipboard *QOpenHarmonyPlatformClipboard::m_self = nullptr;
+
+static napi_value pasteChanged(napi_env env, napi_callback_info info)
+{
+    Q_UNUSED(env)
+    Q_UNUSED(info)
+    qClipBoard->emitChanged(QClipboard::Clipboard);
+    return nullptr;
+}
+
+
+napi_value QOpenHarmonyPlatformClipboard::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("pasteChanged", pasteChanged),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+
+    return nullptr;
+}
+
+QOpenHarmonyPlatformClipboard::QOpenHarmonyPlatformClipboard()
+{
+    m_self = this;
+    m_jsClipboard = qJsObjectLoader->create("JsPasteBoard");
+}
+
+QOpenHarmonyPlatformClipboard::~QOpenHarmonyPlatformClipboard()
+{
+    m_self = nullptr;
+}
+
+QOpenHarmonyPlatformClipboard *QOpenHarmonyPlatformClipboard::instance()
+{
+    return m_self;
+}
+
+QMimeData *QOpenHarmonyPlatformClipboard::mimeData(QClipboard::Mode mode)
+{
+    Q_UNUSED(mode);
+    Q_ASSERT(supportsMode(mode));
+    m_mimeData.setText(hasClipboardText() ? clipboardText() : QString());
+    return &m_mimeData;
+}
+
+void QOpenHarmonyPlatformClipboard::setMimeData(QMimeData *data, QClipboard::Mode mode)
+{
+    if (supportsMode(mode)) {
+        QString text = (data != 0 && data->hasText() ? data->text() : QString());
+        m_jsClipboard->call("setClipboardText", text);;
+    }
+    if (data != 0)
+        data->deleteLater();
+}
+
+bool QOpenHarmonyPlatformClipboard::supportsMode(QClipboard::Mode mode) const
+{
+    return QClipboard::Clipboard == mode;
+}
+
+bool QOpenHarmonyPlatformClipboard::hasClipboardText()
+{
+    return m_jsClipboard->call<bool>("hasClipboardText");
+}
+
+QString QOpenHarmonyPlatformClipboard::clipboardText()
+{
+    return m_jsClipboard->call<QString>("clipboardText");
+}
+
+#endif // QT_NO_CLIPBOARD
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.h b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.h
new file mode 100644
index 0000000000..40b3576be4
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.h
@@ -0,0 +1,36 @@
+#ifndef QOPENHARMONYPLATFORMCLIPBOARD_H
+#define QOPENHARMONYPLATFORMCLIPBOARD_H
+
+#include <qpa/qplatformclipboard.h>
+#include <QMimeData>
+#include <QSharedPointer>
+#include <napi/native_api.h>
+
+#ifndef QT_NO_CLIPBOARD
+class QOpenHarmonyJsObject;
+
+class QOpenHarmonyPlatformClipboard: public QPlatformClipboard
+{
+public:
+    QOpenHarmonyPlatformClipboard();
+    ~QOpenHarmonyPlatformClipboard();
+    static QOpenHarmonyPlatformClipboard *instance();
+
+    QMimeData *mimeData(QClipboard::Mode mode = QClipboard::Clipboard) override;
+    void setMimeData(QMimeData *data, QClipboard::Mode mode = QClipboard::Clipboard) override;
+    bool supportsMode(QClipboard::Mode mode) const override;
+
+    bool hasClipboardText();
+
+    QString clipboardText();
+
+    static napi_value init(napi_env env, napi_value exports);
+private:
+    QMimeData m_mimeData;
+    static QOpenHarmonyPlatformClipboard *m_self;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsClipboard;
+};
+
+#endif // QT_NO_CLIPBOARD
+
+#endif // QOPENHARMONYPLATFORMCLIPBOARD_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.cpp
new file mode 100644
index 0000000000..7368f11911
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.cpp
@@ -0,0 +1,298 @@
+#include "qopenharmonyplatformdialoghelpers.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyjsobjectloader.h"
+
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+
+#include <private/qguiapplication_p.h>
+#include <qpa/qplatformtheme.h>
+#include <QTextDocument>
+#include <QTimer>
+
+void QWaiter::wait(int timeout)
+{
+    if (timeout != -1)
+        QTimer::singleShot(timeout, &m_loop, &QEventLoop::quit);
+    m_loop.exec();
+}
+
+void QWaiter::cancelWait()
+{
+    if (m_loop.isRunning())
+        m_loop.exit();
+}
+
+QOpenHarmonyPlatformMessageDialogHelper::QOpenHarmonyPlatformMessageDialogHelper()
+    : m_buttonId(-1)
+    , m_shown(false)
+{
+    m_jsDialog = qJsObjectLoader->create("JsDialog");
+}
+
+QOpenHarmonyPlatformMessageDialogHelper::~QOpenHarmonyPlatformMessageDialogHelper()
+{
+
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::exec()
+{
+    if (!m_shown)
+        show(Qt::Dialog, Qt::ApplicationModal, 0);
+     wait(-1);
+}
+
+static QString htmlText(QString text)
+{
+    if (Qt::mightBeRichText(text))
+        return text;
+    text.remove(QLatin1Char('\r'));
+    return text.toHtmlEscaped().replace(QLatin1Char('\n'), QLatin1String("<br />"));
+}
+
+bool QOpenHarmonyPlatformMessageDialogHelper::show(Qt::WindowFlags windowFlags
+                                         , Qt::WindowModality windowModality
+                                         , QWindow *parent)
+{
+    Q_UNUSED(windowFlags)
+    Q_UNUSED(windowModality)
+    Q_UNUSED(parent)
+    if (m_jsDialog.isNull())
+        return false;
+    QSharedPointer<QMessageDialogOptions> opt = options();
+    if (!opt.data())
+        return false;
+
+    m_buttons.clear();
+    m_stanardButton.clear();
+    const int * currentLayout = buttonLayout(Qt::Horizontal);
+    while (*currentLayout != QPlatformDialogHelper::EOL) {
+        int role = (*currentLayout & ~QPlatformDialogHelper::Reverse);
+        addButtons(opt, static_cast<ButtonRole>(role));
+        ++currentLayout;
+    }
+
+    QString text = htmlText(opt->text());
+    QString str = htmlText(opt->informativeText());
+    if (!str.isEmpty())
+        text += str;
+    str = htmlText(opt->detailedText());
+    if (!str.isEmpty())
+        text += str;
+
+    m_jsDialog->call("messageBox", QVariant(qlonglong(static_cast<QObject*>(this))), htmlText(opt->windowTitle()), text, m_buttons);
+    m_shown = true;
+    return true;
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::addButtons(QSharedPointer<QMessageDialogOptions> opt, ButtonRole role)
+{
+    for (const QMessageDialogOptions::CustomButton &b : opt->customButtons()) {
+        if (b.role == role) {
+            QString label = b.label;
+            label.remove(QChar('&'));
+        }
+    }
+
+    for (int i = QPlatformDialogHelper::FirstButton; i < QPlatformDialogHelper::LastButton; i<<=1) {
+        StandardButton b = static_cast<StandardButton>(i);
+        if (buttonRole(b) == role && (opt->standardButtons() & i)) {
+            const QString text = QGuiApplicationPrivate::platformTheme()->standardButtonText(b);
+            m_buttons << text;
+            m_stanardButton << b;
+        }
+    }
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::hide()
+{
+    m_shown = false;
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::setDialogResult(int buttonID)
+{
+    m_buttonId = buttonID;
+    cancelWait();
+    if (m_buttonId < 0) {
+        emit reject();
+        return;
+    }
+
+//    QPlatformDialogHelper::StandardButton standardButton = static_cast<QPlatformDialogHelper::StandardButton>(buttonID);
+    QPlatformDialogHelper::StandardButton standardButton = m_stanardButton.at(buttonID);
+    QPlatformDialogHelper::ButtonRole role = QPlatformDialogHelper::buttonRole(standardButton);
+    if (buttonID > QPlatformDialogHelper::LastButton) {
+        const QMessageDialogOptions::CustomButton *custom = options()->customButton(buttonID);
+        Q_ASSERT(custom);
+        role = custom->role;
+    }
+    emit clicked(standardButton, role);
+}
+
+static napi_value dialogResult(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    int32_t value1 = qJs::getInt32(args[1]);
+
+
+    QObject *object = reinterpret_cast<QObject *>(value0);
+    QMetaObject::invokeMethod(object, "setDialogResult", Qt::QueuedConnection, Q_ARG(int, value1));
+    return nullptr;
+}
+
+napi_value QOpenHarmonyPlatformMessageDialogHelper::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("dialogResult", dialogResult),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+    return nullptr;
+}
+
+static napi_value selectedFilesResult(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+    int64_t value0 = qJs::getInt64(args[0]);
+    QStringList value1 = qJs::getStringList(args[1]);
+
+
+    QObject *object = reinterpret_cast<QObject *>(value0);
+    QMetaObject::invokeMethod(object, "setFileResult", Qt::QueuedConnection, Q_ARG(QStringList, value1));
+
+    return nullptr;
+}
+
+napi_value QOpenHarmonyPlatformFileDialogHelper::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("selectedFilesResult", selectedFilesResult),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+    return nullptr;
+}
+
+QOpenHarmonyPlatformFileDialogHelper::QOpenHarmonyPlatformFileDialogHelper()
+    : m_shown(false)
+{
+    m_jsDialog = qJsObjectLoader->create("JsDialog");
+}
+
+QOpenHarmonyPlatformFileDialogHelper::~QOpenHarmonyPlatformFileDialogHelper()
+{
+
+}
+
+bool QOpenHarmonyPlatformFileDialogHelper::defaultNameFilterDisables() const
+{
+    return true;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::setDirectory(const QUrl &directory)
+{
+    m_dir = directory;
+}
+
+QUrl QOpenHarmonyPlatformFileDialogHelper::directory() const
+{
+    return m_dir;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::selectFile(const QUrl &filename)
+{
+    m_saveFile = filename.toLocalFile();
+    if (m_saveFile.contains("/")) {
+        int index = m_saveFile.lastIndexOf("/");
+        m_saveFile = m_saveFile.right(m_saveFile.length() - index - 1);
+    }
+}
+
+QList<QUrl> QOpenHarmonyPlatformFileDialogHelper::selectedFiles() const
+{
+    QList<QUrl> result;
+    for (int i = 0; i < m_files.count(); ++i) {
+        result << QUrl(m_files.at(i));
+    }
+    QSharedPointer<QFileDialogOptions> opt = options();
+    if (opt.data()) {
+        bool save = (opt->acceptMode() == QFileDialogOptions::AcceptSave);
+        if (save) {
+            // js100
+            QThread::msleep(100);
+        }
+    }
+    return result;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::setFilter()
+{
+
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::selectNameFilter(const QString &filter)
+{
+    m_filter = filter;
+}
+
+QString QOpenHarmonyPlatformFileDialogHelper::selectedNameFilter() const
+{
+    return m_filter;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::exec()
+{
+    if (!m_shown)
+        show(Qt::Dialog, Qt::ApplicationModal, nullptr);
+    wait(-1);
+}
+
+bool QOpenHarmonyPlatformFileDialogHelper::show(Qt::WindowFlags windowFlags, Qt::WindowModality windowModality, QWindow *parent)
+{
+    Q_UNUSED(windowModality)
+    if (m_jsDialog.isNull())
+        return false;
+    QSharedPointer<QFileDialogOptions> opt = options();
+    if (!opt.data())
+        return false;
+    bool open = (opt->acceptMode() == QFileDialogOptions::AcceptOpen);
+    if (open)
+        m_jsDialog->call("openFileDialog", QVariant(qlonglong(static_cast<QObject*>(this))), m_filter);
+    else
+        m_jsDialog->call("saveFileDialog", QVariant(qlonglong(static_cast<QObject*>(this))), m_saveFile);
+    m_shown = true;
+    return true;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::hide()
+{
+    m_shown = false;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::setFileResult(const QStringList &file)
+{
+    m_files.clear();
+    if (!file.isEmpty()) {
+        m_files << file;
+    }
+    cancelWait();
+    if (m_files.isEmpty())
+        emit reject();
+    else
+        emit accept();
+}
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.h b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.h
new file mode 100644
index 0000000000..39762fdc90
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.h
@@ -0,0 +1,87 @@
+#ifndef QOPENHARMONYPLATFORMDIALOGHELPERS_H
+#define QOPENHARMONYPLATFORMDIALOGHELPERS_H
+
+#include <qpa/qplatformdialoghelper.h>
+#include <napi/native_api.h>
+
+#include <QList>
+#include <QSharedPointer>
+#include <QEventLoop>
+
+class QOpenHarmonyJsObject;
+
+class QWaiter
+{
+public:
+    QWaiter() {}
+
+    void wait(int timeout = 1000);
+    void cancelWait();
+private:
+    QEventLoop m_loop;
+};
+
+class QOpenHarmonyPlatformMessageDialogHelper: public QPlatformMessageDialogHelper, public QWaiter
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformMessageDialogHelper();
+    ~QOpenHarmonyPlatformMessageDialogHelper();
+    void exec() override;
+    bool show(Qt::WindowFlags windowFlags,
+              Qt::WindowModality windowModality,
+              QWindow *parent) override;
+    void hide() override;
+
+    static napi_value init(napi_env env, napi_value exports);
+
+public slots:
+    void setDialogResult(int buttonID);
+
+private:
+    void addButtons(QSharedPointer<QMessageDialogOptions> opt, ButtonRole role);
+
+private:
+    int m_buttonId;
+    bool m_shown;
+    QStringList m_buttons;
+    QList<QPlatformDialogHelper::StandardButton> m_stanardButton;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsDialog;
+};
+
+class QOpenHarmonyPlatformFileDialogHelper: public QPlatformFileDialogHelper, public QWaiter
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformFileDialogHelper();
+    ~QOpenHarmonyPlatformFileDialogHelper();
+
+    virtual bool defaultNameFilterDisables() const override;
+    virtual void setDirectory(const QUrl &directory) override;
+    virtual QUrl directory() const override;
+    virtual void selectFile(const QUrl &filename) override;
+    virtual QList<QUrl> selectedFiles() const override;
+    virtual void setFilter() override;
+    virtual void selectNameFilter(const QString &filter) override;
+    virtual QString selectedNameFilter() const override;
+
+    virtual void exec() override;
+    virtual bool show(Qt::WindowFlags windowFlags,
+                          Qt::WindowModality windowModality,
+                          QWindow *parent) override;
+    virtual void hide() override;
+
+public slots:
+    void setFileResult(const QStringList &file);
+
+    static napi_value init(napi_env env, napi_value exports);
+private:
+    bool m_shown;
+    QStringList m_files;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsDialog;
+    QString m_saveFile;
+    QUrl m_dir;
+    QString m_filter;
+};
+
+#endif // QOPENHARMONYPLATFORMDIALOGHELPERS_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.cpp
new file mode 100644
index 0000000000..894071dd1e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.cpp
@@ -0,0 +1,35 @@
+#include <QDir>
+
+#include "qopenharmonyplatformfontdatabase.h"
+
+QT_BEGIN_NAMESPACE
+
+QString QOpenHarmonyPlatformFontDatabase::fontDir() const
+{
+    return QLatin1String("/system/fonts");
+}
+
+void QOpenHarmonyPlatformFontDatabase::populateFontDatabase()
+{
+    QString fontpath = fontDir();
+    QDir dir(fontpath);
+
+    if (Q_UNLIKELY(!dir.exists())) {
+        qWarning("QFontDatabase: Cannot find font directory %s - is Qt installed correctly?",
+               qPrintable(fontpath));
+    }
+
+    QStringList nameFilters;
+    nameFilters << QLatin1String("*.ttf")
+                << QLatin1String("*.otf")
+                << QLatin1String("*.ttc");
+
+    const auto entries = dir.entryInfoList(nameFilters, QDir::Files);
+    for (const QFileInfo &fi : entries) {
+        const QByteArray file = QFile::encodeName(fi.absoluteFilePath());
+        QFreeTypeFontDatabase::addTTFile(QByteArray(), file);
+    }
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.h b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.h
new file mode 100644
index 0000000000..3e38d4f853
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.h
@@ -0,0 +1,17 @@
+#ifndef QOPENHARMONYPLATFORMFONTDATABASE_H
+#define QOPENHARMONYPLATFORMFONTDATABASE_H
+
+#include <QtFontDatabaseSupport/private/qfreetypefontdatabase_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformFontDatabase: public QFreeTypeFontDatabase
+{
+public:
+    QString fontDir() const override;
+    void populateFontDatabase() override;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMFONTDATABASE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.cpp
new file mode 100644
index 0000000000..38c5c0ae04
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.cpp
@@ -0,0 +1,54 @@
+#include "qopenharmonyplatformforeignwindow.h"
+#include <QtCore/qvariant.h>
+#include <qpa/qwindowsysteminterface.h>
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformForeignWindow::QOpenHarmonyPlatformForeignWindow(QWindow *window, WId nativeHandle)
+    : QOpenHarmonyPlatformWindow(window),
+      m_surfaceId(-1)
+{
+
+}
+
+QOpenHarmonyPlatformForeignWindow::~QOpenHarmonyPlatformForeignWindow()
+{
+
+}
+
+void QOpenHarmonyPlatformForeignWindow::lower()
+{
+    if (m_surfaceId == -1)
+        return;
+
+    QOpenHarmonyPlatformWindow::lower();
+}
+
+void QOpenHarmonyPlatformForeignWindow::raise()
+{
+    if (m_surfaceId == -1)
+        return;
+
+    QOpenHarmonyPlatformWindow::raise();
+}
+
+void QOpenHarmonyPlatformForeignWindow::setGeometry(const QRect &rect)
+{
+    QOpenHarmonyPlatformWindow::setGeometry(rect);
+}
+
+void QOpenHarmonyPlatformForeignWindow::setVisible(bool visible)
+{
+}
+
+void QOpenHarmonyPlatformForeignWindow::applicationStateChanged(Qt::ApplicationState state)
+{
+    QOpenHarmonyPlatformWindow::applicationStateChanged(state);
+}
+
+void QOpenHarmonyPlatformForeignWindow::setParent(const QPlatformWindow *window)
+{
+    Q_UNUSED(window);
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.h b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.h
new file mode 100644
index 0000000000..e792d1a019
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.h
@@ -0,0 +1,27 @@
+#ifndef QOPENHARMONYPLATFORMFOREIGNWINDOW_H
+#define QOPENHARMONYPLATFORMFOREIGNWINDOW_H
+
+#include "qopenharmonyplatformwindow.h"
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformForeignWindow : public QOpenHarmonyPlatformWindow
+{
+public:
+    explicit QOpenHarmonyPlatformForeignWindow(QWindow *window, WId nativeHandle);
+    ~QOpenHarmonyPlatformForeignWindow() override;
+    void lower() override;
+    void raise() override;
+    void setGeometry(const QRect &rect) override;
+    void setVisible(bool visible) override;
+    void applicationStateChanged(Qt::ApplicationState state) override;
+    void setParent(const QPlatformWindow *window) override;
+    bool isForeignWindow() const override { return true; }
+
+private:
+    int m_surfaceId;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMFOREIGNWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.cpp
new file mode 100644
index 0000000000..b959962c77
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.cpp
@@ -0,0 +1,459 @@
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonyjsobjectloader.h"
+
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+
+#include <qevent.h>
+#include <qguiapplication.h>
+#include <qsharedpointer.h>
+#include <qthread.h>
+#include <qinputmethod.h>
+#include <qwindow.h>
+#include <private/qhighdpiscaling_p.h>
+
+#include <QTextCharFormat>
+#include <QTextBoundaryFinder>
+
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformintegration.h>
+
+QT_BEGIN_NAMESPACE
+
+static QOpenHarmonyPlatformInputContext *m_openHarmonyInputContext = 0;
+
+static napi_value callQtCommit(napi_env env, napi_callback_info info)
+{
+    if (m_openHarmonyInputContext)
+    {
+        size_t argc = 1;
+        napi_value args[1];
+        napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);
+        QString text = qJs::getString(args[0]);
+        m_openHarmonyInputContext->setComposingText(text);
+        m_openHarmonyInputContext->commit();
+    }
+    return nullptr;
+}
+
+// cursor position getter that also works with editors that have not been updated to the new API
+static inline int getAbsoluteCursorPosition(const QSharedPointer<QInputMethodQueryEvent> &query)
+{
+    QVariant absolutePos = query->value(Qt::ImAbsolutePosition);
+    return absolutePos.isValid() ? absolutePos.toInt() : query->value(Qt::ImCursorPosition).toInt();
+}
+
+// position of the start of the current block
+static inline int getBlockPosition(const QSharedPointer<QInputMethodQueryEvent> &query)
+{
+    QVariant absolutePos = query->value(Qt::ImAbsolutePosition);
+    return  absolutePos.isValid() ? absolutePos.toInt() - query->value(Qt::ImCursorPosition).toInt() : 0;
+}
+
+napi_value QOpenHarmonyPlatformInputContext::init(napi_env env, napi_value exports)
+{
+    Q_UNUSED(exports)
+    Q_UNUSED(env)
+    return nullptr;
+}
+
+void QOpenHarmonyPlatformInputContext::sendKeyEvent(QKeyEvent *event)
+{
+    QObject *focusObject = qGuiApp->focusObject();
+    if (!focusObject)
+        return;
+
+    QCoreApplication::sendEvent(focusObject, event);
+}
+
+void QOpenHarmonyPlatformInputContext::updateCursorPosition()
+{
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (!query.isNull() && m_batchEditNestingLevel == 0) {
+        const int cursorPos = getAbsoluteCursorPosition(query);
+        const int composeLength = m_composingText.length();
+
+             //Q_ASSERT(m_composingText.isEmpty() == (m_composingTextStart == -1));
+        if (m_composingText.isEmpty() != (m_composingTextStart == -1))
+            qWarning() << "Input method out of sync" << m_composingText << m_composingTextStart;
+
+        int realSelectionStart = cursorPos;
+        int realSelectionEnd = cursorPos;
+
+        int cpos = query->value(Qt::ImCursorPosition).toInt();
+        int anchor = query->value(Qt::ImAnchorPosition).toInt();
+        if (cpos != anchor) {
+            if (!m_composingText.isEmpty()) {
+                qWarning("Selecting text while preediting may give unpredictable results.");
+                focusObjectStopComposing();
+            }
+            int blockPos = getBlockPosition(query);
+            realSelectionStart = blockPos + cpos;
+            realSelectionEnd = blockPos + anchor;
+        }
+        // Qt's idea of the cursor position is the start of the preedit area, so we maintain our own preedit cursor pos
+        if (focusObjectIsComposing())
+            realSelectionStart = realSelectionEnd = m_composingCursor;
+
+             // Some keyboards misbahave when selStart > selEnd
+        if (realSelectionStart > realSelectionEnd)
+            std::swap(realSelectionStart, realSelectionEnd);
+
+        //TODO
+//        QtAndroidInput::updateSelection(realSelectionStart, realSelectionEnd,
+//                                        m_composingTextStart, m_composingTextStart + composeLength); // pre-edit text
+    }
+}
+
+QOpenHarmonyPlatformInputContext::QOpenHarmonyPlatformInputContext()
+    : QPlatformInputContext()
+      , m_composingTextStart(-1)
+      , m_composingCursor(-1)
+      , m_focusObject(Q_NULLPTR)
+{
+    napi_property_descriptor desc[] ={ DECLARE_NAPI_FUNCTION("callQtCommit", callQtCommit) };
+
+    m_openHarmonyInputContext = this;
+}
+
+QOpenHarmonyPlatformInputContext::~QOpenHarmonyPlatformInputContext()
+{
+    m_openHarmonyInputContext = Q_NULLPTR;
+}
+
+QOpenHarmonyPlatformInputContext *QOpenHarmonyPlatformInputContext::openHarmonyInputContext()
+{
+    return m_openHarmonyInputContext;
+}
+
+void QOpenHarmonyPlatformInputContext::invokeAction(QInputMethod::Action act, int cursorPosition)
+{
+    qInfo() << "QOpenHarmonyPlatformInputContext<===================invokeAction:"
+            << act
+            << cursorPosition;
+}
+
+void QOpenHarmonyPlatformInputContext::setPlatformIntegration(QOpenHarmonyPlatformIntegration *integration)
+{
+    m_integration = integration;
+}
+
+void QOpenHarmonyPlatformInputContext::clear()
+{
+    m_integration = nullptr;
+    m_ignoreMouseEvents = false;
+}
+
+void QOpenHarmonyPlatformInputContext::touchBegin()
+{
+    m_touchPoints.clear();
+}
+
+void QOpenHarmonyPlatformInputContext::touchAdd(int id, int action, float force, float x, float y)
+{
+    if (m_integration == nullptr)
+        return;
+
+    Qt::TouchPointState state = Qt::TouchPointStationary;
+    switch (action) {
+    case 0:
+        state = Qt::TouchPointPressed;
+        break;
+    case 1:
+        state = Qt::TouchPointReleased;
+        break;
+    case 2:
+        state = Qt::TouchPointMoved;
+        break;
+    case 3:
+        // ohos touch cancel
+//        state = Qt::TouchPointStationary;
+        break;
+    default:
+        break;
+    }
+
+    QRect rc = m_integration->screen()->availableGeometry();
+
+    const double dw = static_cast<double>(rc.width());
+    const double dh = static_cast<double>(rc.height());
+    QWindowSystemInterface::TouchPoint touchPoint;
+    touchPoint.id = id;
+    touchPoint.pressure = static_cast<qreal>(force);
+    //    touchPoint.rotation = qRadiansToDegrees(rotation);
+    touchPoint.rotation = 0;
+    touchPoint.normalPosition = QPointF(double(x / dw), double(y / dh));
+    touchPoint.state = state;
+
+    float minor = 50;
+    float major = 50;
+    touchPoint.area = QRectF(x - minor,
+                             y - major,
+                             double(minor * 2),
+                             double(major * 2));
+    m_touchPoints.push_back(touchPoint);
+
+    if (state == Qt::TouchPointPressed) {
+        touchDown(x, y);
+    }
+}
+
+void QOpenHarmonyPlatformInputContext::touchEnd(int id)
+{
+    Q_UNUSED(id)
+    if ((m_integration == nullptr) || m_touchPoints.isEmpty())
+        return;
+
+    QTouchDevice *touchDevice = m_integration->touchDevice();
+    if (touchDevice == nullptr) {
+        touchDevice = new QTouchDevice;
+        touchDevice->setType(QTouchDevice::TouchScreen);
+        touchDevice->setCapabilities(QTouchDevice::Position
+                                     | QTouchDevice::Area
+                                     | QTouchDevice::Pressure
+                                     | QTouchDevice::NormalizedPosition);
+        QWindowSystemInterface::registerTouchDevice(touchDevice);
+        m_integration->setTouchDevice(touchDevice);
+    }
+
+    QWindow *window = m_integration->screen()->topLevelAt(m_touchPoints.at(0).area.center().toPoint());
+    QWindowSystemInterface::handleTouchEvent(window, touchDevice, m_touchPoints);
+}
+
+void QOpenHarmonyPlatformInputContext::reset()
+{
+    qInfo() << "QOpenHarmonyPlatformInputContext<===================reset:";
+    focusObjectStopComposing();
+    /* clear */
+    m_composingText.clear();
+    m_composingTextStart  = -1;
+    m_composingCursor = -1;
+    //m_extractedText.clear();
+
+    m_batchEditNestingLevel = 0;
+//    m_handleMode = Hidden;
+    if (qGuiApp->focusObject()) {
+        QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery(Qt::ImEnabled);
+        if (!query.isNull() && query->value(Qt::ImEnabled).toBool()) {
+            //QtAndroidInput::resetSoftwareKeyboard();
+            return;
+        }
+    }
+    //QtAndroidInput::hideSoftwareKeyboard();
+}
+
+void QOpenHarmonyPlatformInputContext::commit()
+{
+    static QString oldText;
+    if (oldText == m_composingText) {
+        return;
+    }
+    focusObjectStopComposing();
+    oldText = m_composingText;
+    qInfo() << "QOpenHarmonyPlatformInputContext<===================commit:" << m_composingText;
+}
+
+void QOpenHarmonyPlatformInputContext::showInputPanel()
+{
+    qInfo() << "QOpenHarmonyPlatformInputContext<===================showInputPanel:";
+//    if (QGuiApplication::applicationState() != Qt::ApplicationActive) {
+//        connect(qGuiApp, SIGNAL(applicationStateChanged(Qt::ApplicationState)), this, SLOT(showInputPanelLater(Qt::ApplicationState)));
+//        return;
+//    }
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return;
+
+    disconnect(m_updateCursorPosConnection);
+    if (qGuiApp->focusObject()->metaObject()->indexOfSignal("cursorPositionChanged(int,int)") >= 0) // QLineEdit breaks the pattern
+        m_updateCursorPosConnection = connect(qGuiApp->focusObject(), SIGNAL(cursorPositionChanged(int,int)), this, SLOT(updateCursorPosition()));
+    else
+        m_updateCursorPosConnection = connect(qGuiApp->focusObject(), SIGNAL(cursorPositionChanged()), this, SLOT(updateCursorPosition()));
+
+    //m_jsInputManager->call("open", m_composingText);
+    //m_jsInputCtl->call("attach");
+}
+
+void QOpenHarmonyPlatformInputContext::hideInputPanel()
+{
+    //m_jsInputCtl->call("detach");
+   qInfo() << "QOpenHarmonyPlatformInputContext<===================hideInputPanel:";
+}
+
+bool QOpenHarmonyPlatformInputContext::isAnimating() const
+{
+    return false;
+}
+
+QRectF QOpenHarmonyPlatformInputContext::keyboardRect() const
+{
+    //TODO acquire softkeyborad rect
+    return QRectF();
+}
+
+void QOpenHarmonyPlatformInputContext::update(Qt::InputMethodQueries)
+{
+//    qInfo() << "QOpenHarmonyPlatformInputContext<============================update";
+}
+
+void QOpenHarmonyPlatformInputContext::setFocusObject(QObject *object)
+{
+    if (object != m_focusObject) {
+        focusObjectStopComposing();
+        m_focusObject = object;
+        reset();
+    }
+    QPlatformInputContext::setFocusObject(object);
+    //updateSelectionHandles();
+}
+
+bool QOpenHarmonyPlatformInputContext::isInputPanelVisible() const
+{
+    //TODO acquire softkeyborad visable
+    return false;
+}
+
+void QOpenHarmonyPlatformInputContext::setComposingText(const QString &text)
+{
+    m_composingText = text;
+}
+
+void QOpenHarmonyPlatformInputContext::mousePress(float x, float y)
+{
+    if ((m_integration == nullptr) || m_ignoreMouseEvents)
+        return;
+
+    QPoint globalPos(x,y);
+    QWindow *tlw = m_integration->screen()->topLevelAt(globalPos);
+    //    m_mouseGrabber = tlw;
+    QPoint localPos = tlw ? (globalPos - tlw->position()) : globalPos;
+    QWindowSystemInterface::handleMouseEvent(tlw, localPos, globalPos,
+                                             Qt::MouseButtons(Qt::LeftButton),
+                                             Qt::LeftButton, QEvent::MouseButtonPress);
+}
+
+void QOpenHarmonyPlatformInputContext::mouseRelease(float x, float y)
+{
+    if ((m_integration == nullptr) || m_ignoreMouseEvents)
+        return;
+
+    QPoint globalPos(x,y);
+    QWindow *tlw = m_integration->screen()->topLevelAt(globalPos);
+    //    m_mouseGrabber = tlw;
+    QPoint localPos = tlw ? (globalPos - tlw->position()) : globalPos;
+    QWindowSystemInterface::handleMouseEvent(tlw, localPos, globalPos,
+                                             Qt::MouseButtons(Qt::LeftButton),
+                                             Qt::LeftButton, QEvent::MouseButtonPress);
+}
+
+void QOpenHarmonyPlatformInputContext::touchDown(float x, float y)
+{
+
+}
+
+void QOpenHarmonyPlatformInputContext::showInputPanelLater(Qt::ApplicationState state)
+{
+    if (state != Qt::ApplicationActive)
+        return;
+    disconnect(qGuiApp, SIGNAL(applicationStateChanged(Qt::ApplicationState)), this, SLOT(showInputPanelLater(Qt::ApplicationState)));
+    showInputPanel();
+}
+
+void QOpenHarmonyPlatformInputContext::sendInputMethodEvent(QInputMethodEvent *event)
+{
+    if (!qGuiApp)
+        return;
+
+    QObject *focusObject = qGuiApp->focusObject();
+    if (!focusObject)
+        return;
+
+    QCoreApplication::sendEvent(focusObject, event);
+}
+
+QSharedPointer<QInputMethodQueryEvent> QOpenHarmonyPlatformInputContext::focusObjectInputMethodQuery(Qt::InputMethodQueries queries)
+{
+    if (!qGuiApp)
+        return {};
+
+    QObject *focusObject = qGuiApp->focusObject();
+    if (!focusObject)
+        return {};
+
+    QInputMethodQueryEvent *ret = new QInputMethodQueryEvent(queries);
+    QCoreApplication::sendEvent(focusObject, ret);
+    return QSharedPointer<QInputMethodQueryEvent>(ret);
+}
+
+bool QOpenHarmonyPlatformInputContext::focusObjectIsComposing() const
+{
+    return m_composingCursor != -1;
+}
+
+void QOpenHarmonyPlatformInputContext::focusObjectStartComposing()
+{
+    if (focusObjectIsComposing() || m_composingText.isEmpty())
+        return;
+
+         // Composing strings containing newline characters are rare and may cause problems
+    if (m_composingText.contains(QLatin1Char('\n')))
+        return;
+
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (!query)
+        return;
+
+    if (query->value(Qt::ImCursorPosition).toInt() != query->value(Qt::ImAnchorPosition).toInt())
+        return;
+
+    const int absoluteCursorPos = getAbsoluteCursorPosition(query);
+    if (absoluteCursorPos < m_composingTextStart
+        || absoluteCursorPos > m_composingTextStart + m_composingText.length())
+        return;
+
+    m_composingCursor = absoluteCursorPos;
+
+    QTextCharFormat underlined;
+    underlined.setFontUnderline(true);
+
+    QInputMethodEvent event(m_composingText, {
+                                                     { QInputMethodEvent::Cursor, absoluteCursorPos - m_composingTextStart, 1 },
+                                                     { QInputMethodEvent::TextFormat, 0, m_composingText.length(), underlined }
+                                             });
+
+    event.setCommitString({}, m_composingTextStart - absoluteCursorPos, m_composingText.length());
+
+    QGuiApplication::sendEvent(m_focusObject, &event);
+}
+
+bool QOpenHarmonyPlatformInputContext::focusObjectStopComposing()
+{
+//    if (!focusObjectIsComposing())
+//        return true; // not composing
+
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return false;
+
+    const int blockPos = getBlockPosition(query);
+    const int localCursorPos = m_composingCursor - blockPos;
+
+    m_composingCursor = -1;
+
+    // Moving Qt's cursor to where the preedit cursor used to be
+    QList<QInputMethodEvent::Attribute> attributes;
+    attributes.append(QInputMethodEvent::Attribute(QInputMethodEvent::Selection, localCursorPos, 0));
+
+    QInputMethodEvent event(QString(), attributes);
+    event.setCommitString(m_composingText);
+    sendInputMethodEvent(&event);
+
+    return true;
+}
+
+QT_END_NAMESPACE
+
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.h b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.h
new file mode 100644
index 0000000000..4b59e63e07
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.h
@@ -0,0 +1,76 @@
+#ifndef QOPENHARMONYPLATFORMINPUTCONTEXT_H
+#define QOPENHARMONYPLATFORMINPUTCONTEXT_H
+
+#include <QTimer>
+#include <functional>
+#include <napi/native_api.h>
+#include <qpa/qplatforminputcontext.h>
+#include <qpa/qwindowsysteminterface.h>
+
+class QOpenHarmonyJsObject;
+class QOpenHarmonyPlatformIntegration;
+
+QT_BEGIN_NAMESPACE
+class QOpenHarmonyPlatformInputContext: public QPlatformInputContext
+{
+    Q_OBJECT
+
+public:
+    QOpenHarmonyPlatformInputContext();
+    ~QOpenHarmonyPlatformInputContext() override;
+
+    void clear();
+    void touchBegin();
+    void touchEnd(int id);
+    void reset() override;
+    void commit() override;
+    void showInputPanel() override;
+    void hideInputPanel() override;
+    bool isAnimating() const override;
+    QRectF keyboardRect() const override;
+    void update(Qt::InputMethodQueries) override;
+    void setFocusObject(QObject *object) override;
+    bool isValid() const override { return true; }
+    bool isInputPanelVisible() const override;
+    void setComposingText(const QString &text);
+    void touchAdd(int id, int action, float force, float x, float y);
+    static QOpenHarmonyPlatformInputContext * openHarmonyInputContext();
+    void invokeAction(QInputMethod::Action act, int cursorPosition) override;
+    void setPlatformIntegration(QOpenHarmonyPlatformIntegration *integration);
+    static napi_value init(napi_env env, napi_value exports);
+
+    void sendKeyEvent(QKeyEvent *event);
+
+public Q_SLOTS:
+    void updateCursorPosition();
+    void mousePress(float x, float y);
+    void mouseRelease(float x, float y);
+    void touchDown(float x, float y);
+
+private Q_SLOTS:
+    void showInputPanelLater(Qt::ApplicationState state);
+
+private:
+    void sendInputMethodEvent(QInputMethodEvent *event);
+    QSharedPointer<QInputMethodQueryEvent> focusObjectInputMethodQuery(Qt::InputMethodQueries queries = Qt::ImQueryAll);
+    bool focusObjectIsComposing() const;
+    void focusObjectStartComposing();
+    bool focusObjectStopComposing();
+
+private:
+    QString m_composingText;
+    int m_composingTextStart;
+    int m_composingCursor;
+    QObject *m_focusObject;
+    bool m_ignoreMouseEvents = false;
+    int m_batchEditNestingLevel;
+    QMetaObject::Connection m_updateCursorPosConnection;
+    QOpenHarmonyPlatformIntegration *m_integration = nullptr;
+    QList<QWindowSystemInterface::TouchPoint> m_touchPoints;
+
+    QSharedPointer<QOpenHarmonyJsObject> m_jsInputCtl;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMINPUTCONTEXT_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.cpp
new file mode 100644
index 0000000000..ab9fe0ac0b
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.cpp
@@ -0,0 +1,292 @@
+#include "qopenharmonyplatformintegration.h"
+
+#include <QtGui/private/qguiapplication_p.h>
+#include <QGuiApplication>
+#include <QOpenGLContext>
+#include <QThread>
+#include <QMetaObject>
+#include <QOffscreenSurface>
+
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformwindow.h>
+#include <qpa/qplatformoffscreensurface.h>
+
+#include "qabstracteventdispatcher.h"
+#include "qopenharmonyeventdispatcher.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyplatformforeignwindow.h"
+#include "qopenharmonyplatformopenglcontext.h"
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformfontdatabase.h"
+#include "qopenharmonyplatformoffscreensurface.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyplatformtheme.h"
+#include "qopenharmonyplatformclipboard.h"
+#include "qopenharmonyeglcore.h"
+#if QT_CONFIG(vulkan)
+#include "qopenharmonyplatformvulkaninstance.h"
+#endif
+#include "qopenharmonydefines.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonymain.h"
+
+#include <QtGui/qpa/qplatforminputcontextfactory_p.h>
+#include <QtPlatformHeaders/QEGLNativeContext>
+
+
+QT_BEGIN_NAMESPACE
+
+int QOpenHarmonyPlatformIntegration::m_defaultGeometryWidth = 720;
+int QOpenHarmonyPlatformIntegration::m_defaultGeometryHeight = 1280;
+int QOpenHarmonyPlatformIntegration::m_defaultScreenWidth = 720;
+int QOpenHarmonyPlatformIntegration::m_defaultScreenHeight = 1280;
+int QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeWidth = 68;
+int QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeHeight = 121;
+
+Qt::ScreenOrientation QOpenHarmonyPlatformIntegration::m_orientation = Qt::PrimaryOrientation;
+Qt::ScreenOrientation QOpenHarmonyPlatformIntegration::m_nativeOrientation = Qt::PrimaryOrientation;
+
+bool QOpenHarmonyPlatformIntegration::m_showPasswordEnabled = false;
+
+
+QOpenHarmonyPlatformIntegration::QOpenHarmonyPlatformIntegration(const QStringList &paramList)
+{
+    Q_UNUSED(paramList);
+
+    QOpenHarmonyEGLCore::init();
+    m_eglDisplay = QOpenHarmonyEGLCore::eglDisplay();
+    m_eglConfig = QOpenHarmonyEGLCore::eglConfig();
+
+    m_harmonyFontDatabase.reset(new QOpenHarmonyPlatformFontDatabase);
+
+    m_primaryScreen.reset(new QOpenHarmonyPlatformScreen);
+    m_primaryScreen->setPhysicalSize(QSize(m_defaultPhysicalSizeWidth, m_defaultPhysicalSizeHeight));
+    m_primaryScreen->setSize(QSize(m_defaultScreenWidth, m_defaultScreenHeight));
+    m_primaryScreen->setAvailableGeometry(QRect(0, 0, m_defaultGeometryWidth, m_defaultGeometryHeight));
+    QWindowSystemInterface::handleScreenAdded(m_primaryScreen.data());
+
+    m_mainThread = QThread::currentThread();
+
+#ifndef QT_NO_CLIPBOARD
+    m_platformClipboard.reset(new QOpenHarmonyPlatformClipboard);
+#endif
+
+    m_platformNativeInterface.reset(new QOpenHarmonyPlatformNativeInterface());
+    QCoreApplication::postEvent(m_platformNativeInterface.data(), new QEvent(QEvent::User));
+}
+
+
+bool QOpenHarmonyPlatformIntegration::hasCapability(Capability cap) const
+{
+    return true;
+}
+
+QPlatformBackingStore *QOpenHarmonyPlatformIntegration::createPlatformBackingStore(QWindow *window) const
+{
+    return new QOpenHarmonyPlatformBackingStore(window);
+}
+
+#ifndef QT_NO_OPENGL
+QPlatformOpenGLContext *QOpenHarmonyPlatformIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
+{
+    QSurfaceFormat format(context->format());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+    format.setDepthBufferSize(8);
+    format.setStencilBufferSize(8);
+    EGLConfig confg = QOpenHarmonyEGLCore::eglConfig();
+    auto ctx = new QOpenHarmonyPlatformOpenGLContext(format, context->shareHandle(), m_eglDisplay, &confg, context->nativeHandle());
+    context->setNativeHandle(QVariant::fromValue<QEGLNativeContext>(QEGLNativeContext(ctx->eglContext(), m_eglDisplay)));
+    return ctx;
+}
+#endif
+
+QPlatformOffscreenSurface *QOpenHarmonyPlatformIntegration::createPlatformOffscreenSurface(QOffscreenSurface *surface) const
+{
+    QSurfaceFormat format(surface->requestedFormat());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+
+    if (surface->nativeHandle()) {
+        return new QOpenHarmonyPlatformOffscreenSurface(m_eglDisplay, format, surface);
+    }
+
+    return new QEGLPbuffer(m_eglDisplay, format, surface);
+}
+
+QPlatformWindow *QOpenHarmonyPlatformIntegration::createPlatformWindow(QWindow *window) const
+{
+    return new QOpenHarmonyPlatformOpenGLWindow(window, m_eglDisplay);
+}
+
+QPlatformWindow *QOpenHarmonyPlatformIntegration::createForeignWindow(QWindow *window, WId nativeHandle) const
+{
+    return new QOpenHarmonyPlatformForeignWindow(window, nativeHandle);
+}
+
+QAbstractEventDispatcher *QOpenHarmonyPlatformIntegration::createEventDispatcher() const
+{
+    return new QOpenHarmonyEventDispatcher;
+}
+
+QOpenHarmonyPlatformIntegration::~QOpenHarmonyPlatformIntegration()
+{
+    QOpenHarmonyEGLCore::clear();
+    QOpenHarmonyPlatformInputContext *context = qobject_cast<QOpenHarmonyPlatformInputContext *>(m_platformInputContext.data());
+    if (context != nullptr)
+        context->clear();
+    QtOpenHarmony::setOpenHarmonyPlatformIntegration(nullptr);
+}
+
+void QOpenHarmonyPlatformIntegration::initialize()
+{
+    const QString icStr = QPlatformInputContextFactory::requested();
+    if (icStr.isNull()) {
+        QOpenHarmonyPlatformInputContext *context = new QOpenHarmonyPlatformInputContext;
+        context->setPlatformIntegration(this);
+        m_platformInputContext.reset(context);
+    }
+    else
+        m_platformInputContext.reset(QPlatformInputContextFactory::create(icStr));
+}
+
+QPlatformInputContext *QOpenHarmonyPlatformIntegration::inputContext() const
+{
+    return m_platformInputContext.data();
+}
+
+QPlatformNativeInterface *QOpenHarmonyPlatformIntegration::nativeInterface() const
+{
+    return m_platformNativeInterface.data();
+}
+
+QVariant QOpenHarmonyPlatformIntegration::styleHint(StyleHint hint) const
+{
+    switch (hint) {
+    case PasswordMaskDelay:
+        return m_showPasswordEnabled ? 1500 : 0;
+    case ShowIsMaximized:
+        return QtOpenHarmony::isPhone();
+    default:
+        return QPlatformIntegration::styleHint(hint);
+    }
+}
+
+Qt::WindowState QOpenHarmonyPlatformIntegration::defaultWindowState(Qt::WindowFlags flags) const
+{
+    // Don't maximize dialogs on OpenHarmony
+    if (flags & Qt::Dialog & ~Qt::Window) {
+        return Qt::WindowNoState;
+    }
+    return QPlatformIntegration::defaultWindowState(flags);
+}
+
+static const QLatin1String openharmonyThemeName("openharmony");
+QStringList QOpenHarmonyPlatformIntegration::themeNames() const
+{
+    return QStringList(QString(openharmonyThemeName));
+}
+
+QPlatformTheme *QOpenHarmonyPlatformIntegration::createPlatformTheme(const QString &name) const
+{
+    return new QOpenHarmonyPlatformTheme;
+}
+
+void QOpenHarmonyPlatformIntegration::setDefaultDisplayMetrics(int gw, int gh, int sw, int sh, int screenWidth, int screenHeight)
+{
+    m_defaultGeometryWidth = gw;
+    m_defaultGeometryHeight = gh;
+    m_defaultPhysicalSizeWidth = sw;
+    m_defaultPhysicalSizeHeight = sh;
+    m_defaultScreenWidth = screenWidth;
+    m_defaultScreenHeight = screenHeight;
+}
+
+void QOpenHarmonyPlatformIntegration::setDefaultDesktopSize(int gw, int gh)
+{
+    m_defaultScreenWidth = gw;
+    m_defaultScreenHeight = gh;
+}
+
+void QOpenHarmonyPlatformIntegration::setDefaultGeometrySize(int gw, int gh)
+{
+    m_defaultGeometryWidth = gw;
+    m_defaultGeometryHeight = gh;
+}
+
+void QOpenHarmonyPlatformIntegration::setScreenOrientation(Qt::ScreenOrientation currentOrientation,
+                                                       Qt::ScreenOrientation nativeOrientation)
+{
+    m_orientation = currentOrientation;
+    m_nativeOrientation = nativeOrientation;
+}
+
+void QOpenHarmonyPlatformIntegration::flushPendingUpdates()
+{
+    m_primaryScreen->setPhysicalSize(QSize(m_defaultPhysicalSizeWidth,
+                                           m_defaultPhysicalSizeHeight));
+    m_primaryScreen->setSize(QSize(m_defaultScreenWidth, m_defaultScreenHeight));
+    m_primaryScreen->setAvailableGeometry(QRect(0, 0, m_defaultGeometryWidth, m_defaultGeometryHeight));
+}
+
+void QOpenHarmonyPlatformIntegration::setDesktopSize(int width, int height)
+{
+    if (m_primaryScreen.isNull())
+        return;
+    m_primaryScreen->setAvailableGeometry(QRect(0, 0, width, height));
+}
+
+void QOpenHarmonyPlatformIntegration::setDisplayMetrics(int width, int height)
+{
+    if (m_primaryScreen.isNull())
+        return;
+    QMetaObject::invokeMethod(m_primaryScreen.data(), "setPhysicalSize", Qt::AutoConnection, Q_ARG(QSize, QSize(width, height)));
+}
+
+void QOpenHarmonyPlatformIntegration::setScreenSize(int width, int height)
+{
+    if (m_primaryScreen.isNull())
+        return;
+    QMetaObject::invokeMethod(m_primaryScreen.data(), "setSize", Qt::AutoConnection, Q_ARG(QSize, QSize(width, height)));
+}
+
+QPlatformFontDatabase *QOpenHarmonyPlatformIntegration::fontDatabase() const
+{
+    return m_harmonyFontDatabase.data();
+}
+
+#ifndef QT_NO_CLIPBOARD
+QPlatformClipboard *QOpenHarmonyPlatformIntegration::clipboard() const
+{
+    return m_platformClipboard.data();
+}
+#endif
+
+#if QT_CONFIG(vulkan)
+
+QPlatformVulkanInstance *QOpenHarmonyPlatformIntegration::createPlatformVulkanInstance(QVulkanInstance *instance) const
+{
+    return new QOpenHarmonyPlatformVulkanInstance(instance);
+}
+
+#endif // QT_CONFIG(vulkan)
+
+void QOpenHarmonyPlatformNativeInterface::customEvent(QEvent *event)
+{
+    if (event->type() != QEvent::User)
+        return;
+
+    QOpenHarmonyPlatformIntegration *api = static_cast<QOpenHarmonyPlatformIntegration *>(QGuiApplicationPrivate::platformIntegration());
+    QtOpenHarmony::setOpenHarmonyPlatformIntegration(api);
+    api->flushPendingUpdates();
+}
+
+
+QT_END_NAMESPACE
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.h b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.h
new file mode 100644
index 0000000000..d215197c5c
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.h
@@ -0,0 +1,131 @@
+#ifndef QOPENHARMONYPLATFORMINTERATION_H
+#define QOPENHARMONYPLATFORMINTERATION_H
+
+#include <QtGui/qtguiglobal.h>
+
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformmenu.h>
+#include <qpa/qplatformnativeinterface.h>
+
+#include <EGL/egl.h>
+
+#include <memory>
+#include <QScopedPointer>
+
+QT_BEGIN_NAMESPACE
+
+class QTouchDevice;
+class QDesktopWidget;
+class QOpenHarmonyDrag;
+class QPlatformAccessibility;
+class QOpenHarmonyPlatformScreen;
+class QOpenHarmonyPlatformFontDatabase;
+class QOpenHarmonyPlatformInputContext;
+
+
+class QOpenHarmonyPlatformNativeInterface: public QPlatformNativeInterface
+{
+protected:
+    void customEvent(QEvent *event) override;
+};
+
+class QOpenHarmonyPlatformIntegration : public QPlatformIntegration
+{
+    friend class QOpenHarmonyPlatformScreen;
+
+public:
+    QOpenHarmonyPlatformIntegration(const QStringList &paramList);
+    ~QOpenHarmonyPlatformIntegration() override;
+
+    void initialize() override;
+
+    bool hasCapability(QPlatformIntegration::Capability cap) const override;
+
+    QPlatformWindow *createPlatformWindow(QWindow *window) const override;
+    QPlatformWindow *createForeignWindow(QWindow *window, WId nativeHandle) const override;
+    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const override;
+#ifndef QT_NO_OPENGL
+    QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
+#endif
+    QAbstractEventDispatcher *createEventDispatcher() const override;
+    QOpenHarmonyPlatformScreen *screen() { return m_primaryScreen.data(); }
+    QPlatformOffscreenSurface *createPlatformOffscreenSurface(QOffscreenSurface *surface) const override;
+
+    virtual void setDesktopSize(int width, int height);
+    virtual void setDisplayMetrics(int width, int height);
+    void setScreenSize(int width, int height);
+    bool isVirtualDesktop() { return true; }
+
+    QPlatformFontDatabase *fontDatabase() const override;
+
+#ifndef QT_NO_CLIPBOARD
+    QPlatformClipboard *clipboard() const override;
+#endif
+
+    QPlatformInputContext *inputContext() const override;
+    QPlatformNativeInterface *nativeInterface() const override;
+//    QPlatformServices *services() const override;
+
+//#ifndef QT_NO_ACCESSIBILITY
+//    virtual QPlatformAccessibility *accessibility() const override;
+//#endif
+
+    QVariant styleHint(StyleHint hint) const override;
+    Qt::WindowState defaultWindowState(Qt::WindowFlags flags) const override;
+
+    QStringList themeNames() const override;
+    QPlatformTheme *createPlatformTheme(const QString &name) const override;
+
+    static void setDefaultDisplayMetrics(int gw, int gh, int sw, int sh, int width, int height);
+    static void setDefaultDesktopSize(int gw, int gh);
+    static void setDefaultGeometrySize(int gw, int gh);
+    static void setScreenOrientation(Qt::ScreenOrientation currentOrientation,
+                                     Qt::ScreenOrientation nativeOrientation);
+
+    static QSize defaultDesktopSize()
+    {
+        return QSize(m_defaultGeometryWidth, m_defaultGeometryHeight);
+    }
+
+    QTouchDevice *touchDevice() const { return m_touchDevice; }
+    void setTouchDevice(QTouchDevice *touchDevice) { m_touchDevice = touchDevice; }
+
+    void flushPendingUpdates();
+
+#if QT_CONFIG(vulkan)
+    QPlatformVulkanInstance *createPlatformVulkanInstance(QVulkanInstance *instance) const;
+#endif // QT_CONFIG(vulkan)
+private:
+    EGLDisplay m_eglDisplay;
+    EGLConfig m_eglConfig;
+    QTouchDevice *m_touchDevice = nullptr;
+
+    QScopedPointer<QOpenHarmonyPlatformScreen> m_primaryScreen;
+
+    QThread *m_mainThread;
+
+    static int m_defaultGeometryWidth;
+    static int m_defaultGeometryHeight;
+    static int m_defaultPhysicalSizeWidth;
+    static int m_defaultPhysicalSizeHeight;
+    static int m_defaultScreenWidth;
+    static int m_defaultScreenHeight;
+
+    static Qt::ScreenOrientation m_orientation;
+    static Qt::ScreenOrientation m_nativeOrientation;
+    static bool m_showPasswordEnabled;
+
+    QScopedPointer<QOpenHarmonyPlatformFontDatabase> m_harmonyFontDatabase;
+
+    QScopedPointer<QPlatformInputContext> m_platformInputContext;
+
+#ifndef QT_NO_CLIPBOARD
+    QScopedPointer<QPlatformClipboard> m_platformClipboard;
+#endif
+
+    QScopedPointer<QPlatformNativeInterface> m_platformNativeInterface;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.cpp
new file mode 100644
index 0000000000..def46c762e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.cpp
@@ -0,0 +1,32 @@
+#include "qopenharmonyplatformoffscreensurface.h"
+
+#include <QtGui/QOffscreenSurface>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformOffscreenSurface::QOpenHarmonyPlatformOffscreenSurface(EGLDisplay display, const QSurfaceFormat &format, QOffscreenSurface *offscreenSurface)
+    : QPlatformOffscreenSurface(offscreenSurface)
+    , m_format(format)
+    , m_display(display)
+    , m_surface(EGL_NO_SURFACE)
+{
+    // Get native handle
+    EGLNativeWindowType surfaceTexture = (EGLNativeWindowType)offscreenSurface->nativeHandle();
+
+    EGLConfig config = q_configFromGLFormat(m_display, m_format, false);
+    if (config) {
+        const EGLint attributes[] = {
+            EGL_NONE
+        };
+        m_surface = eglCreateWindowSurface(m_display, config, surfaceTexture, attributes);
+    }
+}
+
+QOpenHarmonyPlatformOffscreenSurface::~QOpenHarmonyPlatformOffscreenSurface()
+{
+    eglDestroySurface(m_display, m_surface);
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.h b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.h
new file mode 100644
index 0000000000..0b4009d140
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.h
@@ -0,0 +1,28 @@
+#ifndef QOPENHARMONYPLATFORMOFFSCREENSURFACETEXTURE_H
+#define QOPENHARMONYPLATFORMOFFSCREENSURFACETEXTURE_H
+
+#include <qpa/qplatformoffscreensurface.h>
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+class QOffscreenSurface;
+class QOpenHarmonyPlatformOffscreenSurface : public QPlatformOffscreenSurface
+{
+public:
+    QOpenHarmonyPlatformOffscreenSurface(EGLDisplay display, const QSurfaceFormat &format,
+                                            QOffscreenSurface *offscreenSurface);
+    ~QOpenHarmonyPlatformOffscreenSurface();
+
+    QSurfaceFormat format() const override { return m_format; }
+    bool isValid() const override { return m_surface != EGL_NO_SURFACE; }
+
+    EGLSurface surface() const { return m_surface; }
+private:
+    QSurfaceFormat m_format;
+    EGLDisplay m_display;
+    EGLSurface m_surface;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMOFFSCREENSURFACETEXTURE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.cpp
new file mode 100644
index 0000000000..fdb3c5cfbb
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.cpp
@@ -0,0 +1,49 @@
+#include "qopenharmonyplatformopenglcontext.h"
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonydefines.h"
+
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+
+#include <QSurface>
+#include <QtGui/private/qopenglcontext_p.h>
+#include <QtGui/QOffscreenSurface>
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformOpenGLContext::QOpenHarmonyPlatformOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display, EGLConfig *config,
+                                                             const QVariant &nativeHandle)
+    :QEGLPlatformContext(format, share, display, config, nativeHandle)
+{
+}
+
+//void QOpenHarmonyPlatformOpenGLContext::swapBuffers(QPlatformSurface *surface)
+//{
+//    if (surface->surface()->surfaceClass() == QSurface::Window &&
+//            static_cast<QOpenHarmonyPlatformOpenGLWindow *>(surface)->checkNativeSurface(eglConfig())) {
+//        QEGLPlatformContext::makeCurrent(surface);
+//    }
+
+//    QEGLPlatformContext::swapBuffers(surface);
+//}
+
+//bool QOpenHarmonyPlatformOpenGLContext::makeCurrent(QPlatformSurface *surface)
+//{
+//    return QEGLPlatformContext::makeCurrent(surface);
+//}
+
+EGLSurface QOpenHarmonyPlatformOpenGLContext::eglSurfaceForPlatformSurface(QPlatformSurface *surface)
+{
+    if (surface->surface()->surfaceClass() == QSurface::Window) {
+        return static_cast<QOpenHarmonyPlatformOpenGLWindow *>(surface)->eglSurface(eglConfig());
+    } else {
+        auto platformOffscreenSurface = static_cast<QPlatformOffscreenSurface*>(surface);
+        if (platformOffscreenSurface->offscreenSurface()->nativeHandle())
+            return 0;
+//            return static_cast<QOpenHarmonyPlatformOffscreenSurface *>(surface)->surface();
+        else
+            return static_cast<QEGLPbuffer *>(surface)->pbuffer();
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.h b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.h
new file mode 100644
index 0000000000..c885aa5fec
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.h
@@ -0,0 +1,22 @@
+#ifndef QOPENHARMONYPLATFORMOPENGLCONTEXT_H
+#define QOPENHARMONYPLATFORMOPENGLCONTEXT_H
+
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformOpenGLContext : public QEGLPlatformContext
+{
+public:
+    QOpenHarmonyPlatformOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display, EGLConfig *config, const QVariant &nativeHandle);
+//    void swapBuffers(QPlatformSurface *surface) override;
+//    bool makeCurrent(QPlatformSurface *surface) override;
+
+private:
+    EGLSurface eglSurfaceForPlatformSurface(QPlatformSurface *surface) override;
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMOPENGLCONTEXT_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.cpp
new file mode 100644
index 0000000000..63c35e210a
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.cpp
@@ -0,0 +1,218 @@
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyxcomponentmanager.h"
+#include "qopenharmonymain.h"
+
+#include <QStaticText>
+#include <QSurfaceFormat>
+#include <QtGui/private/qwindow_p.h>
+#include <QtGui/qguiapplication.h>
+
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformscreen.h>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+#include <QDebug>
+QT_BEGIN_NAMESPACE
+
+
+QOpenHarmonyPlatformOpenGLWindow::QOpenHarmonyPlatformOpenGLWindow(QWindow *window, EGLDisplay display)
+    :QOpenHarmonyPlatformWindow(window), m_eglDisplay(display), m_component(nullptr)
+{
+
+}
+
+QOpenHarmonyPlatformOpenGLWindow::~QOpenHarmonyPlatformOpenGLWindow()
+{
+    clearEgl();
+    if (m_component != nullptr)
+        QOpenHarmonyXComponentManager::instance()->releaseXComponent(m_component);
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::repaint(const QRegion &region)
+{
+    // This is only for real raster top-level windows. Stop in all other cases.
+    if ((window()->surfaceType() == QSurface::RasterGLSurface && qt_window_private(window())->compositing)
+        || window()->surfaceType() == QSurface::OpenGLSurface
+        || QOpenHarmonyPlatformWindow::parent())
+        return;
+
+    if (QtOpenHarmony::isPhone()) {
+        // phone draw all windows in a xcomponent
+        QRect dirtyClient = region.boundingRect();
+        QRect currentGeometry = geometry();
+        QRect dirtyRegion(currentGeometry.left() + dirtyClient.left(),
+                          currentGeometry.top() + dirtyClient.top(),
+                          dirtyClient.width(),
+                          dirtyClient.height());
+        QRect mOldGeometryLocal = m_oldGeometry;
+        m_oldGeometry = currentGeometry;
+        // If this is a move, redraw the previous location
+        if (mOldGeometryLocal != currentGeometry)
+            platformScreen()->setDirty(mOldGeometryLocal);
+        platformScreen()->setDirty(dirtyRegion);
+    } else {
+        // pad pc draw window in a independent xcomponent
+        if (m_component == nullptr) {
+            createXComponent();
+        }
+        if (m_component == nullptr)
+            return;
+        QOpenHarmonyPlatformBackingStore *backingStore = this->backingStore();
+        if (backingStore) {
+            QImage image = m_component->image();
+            QPainter compositePainter(&image);
+            compositePainter.setCompositionMode(QPainter::CompositionMode_Source);
+            QImage backingStoreImage = backingStore->toImage();
+            compositePainter.drawImage(QPoint(0, 0), backingStoreImage, backingStoreImage.rect());
+#ifdef USE_MASK
+            compositePainter.save();
+            compositePainter.setBrush(QBrush(Qt::red));
+            QString ct("managed by isoftstone");
+            QStaticText sct(ct);
+            QFontMetrics fm(compositePainter.font());
+            int height = fm.height();
+            int width = fm.horizontalAdvance(ct);
+            QPoint tp = image.rect().bottomRight();
+            tp.rx() -= (width + 2);
+            tp.ry() -= (height + 2);
+            compositePainter.drawStaticText(tp, sct);
+            compositePainter.restore();
+#endif
+
+            m_component->paint(image);
+        }
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::setGeometry(const QRect &rect)
+{
+    if (m_component == nullptr)
+        createXComponent();
+    if (m_component == nullptr)
+        return;
+    if (m_component->geometry() != rect) {
+        // Xcomponent,
+        if (!QtOpenHarmony::isPhone()) {
+            QOpenHarmonyXComponentManager::instance()->setGeometry(m_component, rect);
+        }
+    }
+    if (rect == geometry())
+        return;
+
+    m_oldGeometry = geometry();
+
+    QOpenHarmonyPlatformWindow::setGeometry(rect);
+    QRect availableGeometry = screen()->availableGeometry();
+    if (m_oldGeometry.width() == 0
+            && m_oldGeometry.height() == 0
+            && rect.width() > 0
+            && rect.height() > 0
+            && availableGeometry.width() > 0
+            && availableGeometry.height() > 0) {
+        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(0, 0), rect.size()));
+    }
+
+    if (rect.topLeft() != m_oldGeometry.topLeft())
+        repaint(QRegion(rect));
+}
+
+EGLSurface QOpenHarmonyPlatformOpenGLWindow::surface() const
+{
+    if (m_component == nullptr) {
+        m_component = QOpenHarmonyXComponentManager::instance()->getXComponent();
+    }
+    return m_component == nullptr ? EGL_NO_SURFACE : m_component->eglSurface();
+}
+
+EGLSurface QOpenHarmonyPlatformOpenGLWindow::eglSurface(EGLConfig config)
+{
+    if (QGuiApplication::applicationState() == Qt::ApplicationSuspended)
+        return m_eglSurface;
+
+    if (m_eglSurface == EGL_NO_SURFACE) {
+        checkNativeSurface(config);
+    }
+    return m_eglSurface;
+}
+
+bool QOpenHarmonyPlatformOpenGLWindow::checkNativeSurface(EGLConfig config)
+{
+    createEgl(config);
+    // we've create another surface, the window should be repainted
+    QRect availableGeometry = screen()->availableGeometry();
+    if (geometry().width() > 0 && geometry().height() > 0 && availableGeometry.width() > 0 && availableGeometry.height() > 0)
+        QWindowSystemInterface::handleExposeEvent(window(), QRegion(QRect(QPoint(), geometry().size())));
+    return true; // makeCurrent is needed!
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::applicationStateChanged(Qt::ApplicationState state)
+{
+    QOpenHarmonyPlatformWindow::applicationStateChanged(state);
+    if (state <=  Qt::ApplicationHidden) {
+        clearEgl();
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::createEgl(EGLConfig config)
+{
+//    clearEgl();
+    EGLint winAttribs[] = {EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR, EGL_NONE};
+    m_eglSurface = surface();
+    m_format = q_glFormatFromConfig(m_eglDisplay, config, window()->requestedFormat());
+    if (Q_UNLIKELY(m_eglSurface == EGL_NO_SURFACE)) {
+        EGLint error = eglGetError();
+        eglTerminate(m_eglDisplay);
+        qWarning("EGL Error : Could not create the egl surface: error = 0x%x\n", error);
+    }
+}
+
+QSurfaceFormat QOpenHarmonyPlatformOpenGLWindow::format() const
+{
+    if (m_nativeWindow == 0)
+        return window()->requestedFormat();
+    else
+        return m_format;
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::clearEgl()
+{
+    if (m_eglSurface != EGL_NO_SURFACE) {
+        eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+    }
+
+    if (m_nativeWindow) {
+        m_nativeWindow = 0;
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::createXComponent()
+{
+    m_component = QOpenHarmonyXComponentManager::instance()->getXComponent();
+    if (m_component != nullptr)
+        m_component->setWindow(this);
+}
+
+EGLDisplay QOpenHarmonyPlatformOpenGLWindow::eglDisplay() const
+{
+    return m_eglDisplay;
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::setVisible(bool visible)
+{
+    QOpenHarmonyPlatformWindow::setVisible(visible);
+    if (m_component == nullptr)
+        createXComponent();
+    if (m_component != nullptr && !QtOpenHarmony::isPhone()) {
+        QOpenHarmonyXComponentManager::instance()->setVisible(m_component, visible);
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.h b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.h
new file mode 100644
index 0000000000..2e53ea0900
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.h
@@ -0,0 +1,48 @@
+#ifndef QOPENHARMONYPLATFORMOPENGLWINDOW_H
+#define QOPENHARMONYPLATFORMOPENGLWINDOW_H
+
+#include <EGL/egl.h>
+#include <QWaitCondition>
+#include "qopenharmonyplatformwindow.h"
+class QOpenHarmonyJsObject;
+class QOpenHarmonyXComponent;
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformOpenGLWindow : public QOpenHarmonyPlatformWindow
+{
+public:
+    explicit QOpenHarmonyPlatformOpenGLWindow(QWindow *window, EGLDisplay display);
+    ~QOpenHarmonyPlatformOpenGLWindow() override;
+
+    void setGeometry(const QRect &rect) override;
+
+    EGLSurface eglSurface(EGLConfig config);
+    QSurfaceFormat format() const override;
+
+    bool checkNativeSurface(EGLConfig config);
+
+    void applicationStateChanged(Qt::ApplicationState) override;
+
+    void repaint(const QRegion &region) override;
+
+    EGLDisplay eglDisplay() const;
+
+    void setVisible(bool visible);
+
+protected:
+    EGLSurface surface() const;
+    void createEgl(EGLConfig config);
+    void clearEgl();
+    void createXComponent();
+
+private:
+    EGLDisplay m_eglDisplay = EGL_NO_DISPLAY;
+    EGLSurface m_eglSurface = EGL_NO_SURFACE;
+    EGLNativeWindowType m_nativeWindow = 0;
+    QSurfaceFormat m_format;
+    QRect m_oldGeometry;
+    mutable QOpenHarmonyXComponent *m_component = nullptr;
+};
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYPLATFORMOPENGLWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformplugin.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformplugin.cpp
new file mode 100644
index 0000000000..c4cb6257c3
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformplugin.cpp
@@ -0,0 +1,26 @@
+#include <qpa/qplatformintegrationplugin.h>
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonydefines.h"
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformIntegrationPlugin: public QPlatformIntegrationPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "openharmony.json")
+public:
+    QPlatformIntegration *create(const QString &key, const QStringList &paramList) override;
+};
+
+
+QPlatformIntegration *QOpenHarmonyPlatformIntegrationPlugin::create(const QString &key, const QStringList &paramList)
+{
+    Q_UNUSED(paramList);
+    if (!key.compare(QLatin1String("openharmony"), Qt::CaseInsensitive))
+        return new QOpenHarmonyPlatformIntegration(paramList);
+    return 0;
+}
+
+QT_END_NAMESPACE
+#include "qopenharmonyplatformplugin.moc"
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.cpp
new file mode 100644
index 0000000000..7eb35356b3
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.cpp
@@ -0,0 +1,328 @@
+#include <QDebug>
+#include <QTime>
+
+#ifdef USE_MASK
+#include <QBrush>
+#endif
+
+#include <QStaticText>
+#include <qpa/qwindowsysteminterface.h>
+
+#include "qopenharmonymain.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyxcomponentmanager.h"
+
+#include <qguiapplication.h>
+
+#include <QtGui/QGuiApplication>
+#include <QtGui/QWindow>
+#include <QtGui/private/qwindow_p.h>
+#include <QtEglSupport/private/qt_egl_p.h>
+
+#include <vector>
+
+QT_BEGIN_NAMESPACE
+
+
+QOpenHarmonyPlatformScreen::QOpenHarmonyPlatformScreen()
+    : QObject(), QPlatformScreen(), m_stopDraw(false)
+{
+    m_availableGeometry = QRect(0, 0, QOpenHarmonyPlatformIntegration::m_defaultGeometryWidth, QOpenHarmonyPlatformIntegration::m_defaultGeometryHeight);
+    m_size = QSize(QOpenHarmonyPlatformIntegration::m_defaultScreenWidth, QOpenHarmonyPlatformIntegration::m_defaultScreenHeight);
+
+    m_format = QImage::Format_ARGB32_Premultiplied;
+    m_depth = 32;
+    m_physicalSize.setHeight(QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeHeight);
+    m_physicalSize.setWidth(QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeWidth);
+    connect(qGuiApp, &QGuiApplication::applicationStateChanged, this, &QOpenHarmonyPlatformScreen::applicationStateChanged);
+}
+
+QOpenHarmonyPlatformScreen::~QOpenHarmonyPlatformScreen()
+{
+
+}
+
+QWindow *QOpenHarmonyPlatformScreen::topWindow() const
+{
+    for (QOpenHarmonyPlatformWindow *w : m_windowStack) {
+        if (w->window()->type() == Qt::Window ||
+                w->window()->type() == Qt::Popup ||
+                w->window()->type() == Qt::Dialog) {
+            return w->window();
+        }
+    }
+    return nullptr;
+}
+
+QWindow *QOpenHarmonyPlatformScreen::topLevelAt(const QPoint &p) const
+{
+    for (QOpenHarmonyPlatformWindow *w : m_windowStack) {
+        if (w->geometry().contains(p, false) && w->window()->isVisible())
+            return w->window();
+    }
+    return nullptr;
+}
+
+bool QOpenHarmonyPlatformScreen::event(QEvent *event)
+{
+    if (event->type() == QEvent::UpdateRequest) {
+        doRedraw();
+        m_updatePending = false;
+        return true;
+    }
+    return QObject::event(event);
+}
+
+void QOpenHarmonyPlatformScreen::addWindow(QOpenHarmonyPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+    Q_ASSERT(!m_windowStack.contains(window));
+    m_windowStack.prepend(window);
+    if (window->isRaster() && QtOpenHarmony::isPhone()) {
+        setDirty(window->geometry());
+    }
+
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+void QOpenHarmonyPlatformScreen::removeWindow(QOpenHarmonyPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+
+    Q_ASSERT(m_windowStack.contains(window));
+    m_windowStack.removeOne(window);
+    Q_ASSERT(!m_windowStack.contains(window));
+
+    if (window->isRaster() && QtOpenHarmony::isPhone()) {
+        setDirty(window->geometry());
+    }
+
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QOpenHarmonyPlatformScreen::raise(QOpenHarmonyPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+    int index = m_windowStack.indexOf(window);
+    if (index <= 0)
+        return;
+    m_windowStack.move(index, 0);
+    if (window->isRaster() && QtOpenHarmony::isPhone()) {
+        setDirty(window->geometry());
+    }
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QOpenHarmonyPlatformScreen::lower(QOpenHarmonyPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+    int index = m_windowStack.indexOf(window);
+    if (index == -1 || index == (m_windowStack.size() - 1))
+        return;
+    m_windowStack.move(index, m_windowStack.size() - 1);
+    if (window->isRaster() && QtOpenHarmony::isPhone()) {
+        setDirty(window->geometry());
+    }
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QOpenHarmonyPlatformScreen::scheduleUpdate()
+{
+    if (!m_updatePending) {
+        m_updatePending = true;
+        QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest));
+    }
+}
+
+void QOpenHarmonyPlatformScreen::setDirty(const QRect &rect)
+{
+    QRect intersection = rect.intersected(m_availableGeometry);
+    m_dirtyRect |= intersection;
+    scheduleUpdate();
+}
+
+void QOpenHarmonyPlatformScreen::setPhysicalSize(const QSize &size)
+{
+    m_physicalSize = size;
+}
+
+void QOpenHarmonyPlatformScreen::setSize(const QSize &size)
+{
+    m_size = size;
+    QWindowSystemInterface::handleScreenGeometryChange(QPlatformScreen::screen(), geometry(), availableGeometry());
+}
+
+void QOpenHarmonyPlatformScreen::setAvailableGeometry(const QRect &rect)
+{
+    if (m_availableGeometry == rect)
+        return;
+
+    QRect oldGeometry = m_availableGeometry;
+
+    m_availableGeometry = rect;
+    QWindowSystemInterface::handleScreenGeometryChange(QPlatformScreen::screen(), geometry(), availableGeometry());
+    resizeMaximizedWindows();
+
+    if (oldGeometry.width() == 0 && oldGeometry.height() == 0 && rect.width() > 0 && rect.height() > 0) {
+        QList<QWindow *> windows = QGuiApplication::allWindows();
+        for (int i = 0; i < windows.size(); ++i) {
+            QWindow *w = windows.at(i);
+            if (w->handle()) {
+                QRect geometry = w->handle()->geometry();
+                if (geometry.width() > 0 && geometry.height() > 0)
+                    QWindowSystemInterface::handleExposeEvent(w, QRect(QPoint(0, 0), geometry.size()));
+            }
+        }
+    }
+}
+
+void QOpenHarmonyPlatformScreen::applicationStateChanged(Qt::ApplicationState state)
+{
+    for (QOpenHarmonyPlatformWindow *w : qAsConst(m_windowStack))
+        w->applicationStateChanged(state);
+
+//    if (state <=  Qt::ApplicationHidden) {
+//        releaseSurface();
+//    }
+    m_stopDraw = (state <=  Qt::ApplicationHidden);
+}
+
+void QOpenHarmonyPlatformScreen::topWindowChanged(QWindow *w)
+{
+    if (w != 0) {
+        QOpenHarmonyPlatformWindow *platformWindow = static_cast<QOpenHarmonyPlatformWindow *>(w->handle());
+        if (platformWindow != 0)
+            platformWindow->updateStatusBarVisibility();
+    }
+}
+
+void QOpenHarmonyPlatformScreen::doRedraw()
+{
+    if (m_dirtyRect.isEmpty() || m_stopDraw)
+        return;
+
+    // Stop if there are no visible raster windows. If we only have RasterGLSurface
+    // windows that have renderToTexture children (i.e. they need the OpenGL path) then
+    // we do not need an overlay surface.
+    bool hasVisibleRasterWindows = false;
+    for (QOpenHarmonyPlatformWindow *window : qAsConst(m_windowStack)) {
+        if (window->window()->isVisible() && window->isRaster() && !qt_window_private(window->window())->compositing) {
+            hasVisibleRasterWindows = true;
+            break;
+        }
+    }
+    if (!hasVisibleRasterWindows) {
+        qDebug() << "no visible raster windows";
+        return;
+    }
+
+    if (m_component == nullptr) {
+        m_component = QOpenHarmonyXComponentManager::instance()->getXComponent();
+    }
+    if (m_component == nullptr) {
+        return;
+    }
+
+    QImage screenImage = m_component->image();
+    QPainter compositePainter(&screenImage);
+    compositePainter.setCompositionMode(QPainter::CompositionMode_Source);
+
+    QRegion visibleRegion(m_dirtyRect);
+    for (QOpenHarmonyPlatformWindow *window : qAsConst(m_windowStack)) {
+        if (!window->window()->isVisible()
+                || qt_window_private(window->window())->compositing
+                || !window->isRaster())
+            continue;
+
+        for (const QRect &rect : std::vector<QRect>(visibleRegion.begin(), visibleRegion.end())) {
+            QRect targetRect = window->geometry();
+            targetRect &= rect;
+
+            if (targetRect.isNull())
+                continue;
+
+            visibleRegion -= targetRect;
+            QRect windowRect = targetRect.translated(-window->geometry().topLeft());
+            QOpenHarmonyPlatformOpenGLWindow *openglWindow = static_cast<QOpenHarmonyPlatformOpenGLWindow *>(window);
+            if (openglWindow != nullptr) {
+                QOpenHarmonyPlatformBackingStore *backingStore = openglWindow->backingStore();
+                if (backingStore) {
+                    compositePainter.drawImage(targetRect.topLeft(), backingStore->toImage(), windowRect);
+                }
+            }
+        }
+    }
+
+    for (const QRect &rect : visibleRegion)
+        compositePainter.fillRect(rect, QColor(Qt::transparent));
+
+#ifdef USE_MASK
+    compositePainter.save();
+    compositePainter.setBrush(QBrush(Qt::red));
+    QString ct("managed by isoftstone");
+    QStaticText sct(ct);
+    QFontMetrics fm(compositePainter.font());
+    int height = fm.height();
+    int width = fm.horizontalAdvance(ct);
+    QPoint tp = screenImage.rect().bottomRight();
+    tp.rx() -= (width + 2);
+    tp.ry() -= (height + 2);
+    compositePainter.drawStaticText(tp, sct);
+    compositePainter.restore();
+#endif
+
+    m_component->paint(screenImage);
+    m_dirtyRect = QRect();
+}
+
+QDpi QOpenHarmonyPlatformScreen::logicalDpi() const
+{
+    qreal lDpi = QtOpenHarmony::scaledDensity() * 72;
+    return QDpi(lDpi, lDpi);
+}
+
+qreal QOpenHarmonyPlatformScreen::pixelDensity() const
+{
+    return QtOpenHarmony::pixelDensity();
+}
+
+Qt::ScreenOrientation QOpenHarmonyPlatformScreen::orientation() const
+{
+    return QOpenHarmonyPlatformIntegration::m_orientation;
+}
+
+Qt::ScreenOrientation QOpenHarmonyPlatformScreen::nativeOrientation() const
+{
+    return QOpenHarmonyPlatformIntegration::m_nativeOrientation;
+}
+
+void QOpenHarmonyPlatformScreen::releaseSurface()
+{
+//    if (m_component != nullptr) {
+//        QOpenHarmonyXComponentManager::instance()->remove(m_component);
+//        m_component = nullptr;
+//    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.h b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.h
new file mode 100644
index 0000000000..033d7ed59b
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.h
@@ -0,0 +1,80 @@
+#ifndef QOPENHARMONYPLATFORMSCREEN_H
+#define QOPENHARMONYPLATFORMSCREEN_H
+
+#include <qpa/qplatformscreen.h>
+#include <QList>
+#include <QPainter>
+#include <QTimer>
+#include <QWaitCondition>
+
+#include <native_window/external_window.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformWindow;
+class QOpenHarmonyXComponent;
+
+class QOpenHarmonyPlatformScreen: public QObject, public QPlatformScreen
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformScreen();
+    ~QOpenHarmonyPlatformScreen();
+
+    QRect geometry() const override { return QRect(QPoint(), m_size); }
+    QRect availableGeometry() const override { return m_availableGeometry; }
+    int depth() const override { return m_depth; }
+    QImage::Format format() const override { return m_format; }
+    QSizeF physicalSize() const override { return m_physicalSize; }
+
+    inline QWindow *topWindow() const;
+    QWindow *topLevelAt(const QPoint & p) const override;
+
+    // compositor api
+    void addWindow(QOpenHarmonyPlatformWindow *window);
+    void removeWindow(QOpenHarmonyPlatformWindow *window);
+    void raise(QOpenHarmonyPlatformWindow *window);
+    void lower(QOpenHarmonyPlatformWindow *window);
+
+    void scheduleUpdate();
+    void topWindowChanged(QWindow *w);
+
+public slots:
+    void setDirty(const QRect &rect);
+    void setPhysicalSize(const QSize &size);
+    void setAvailableGeometry(const QRect &rect);
+    void setSize(const QSize &size);
+
+protected:
+    bool event(QEvent *event) override;
+
+    typedef QList<QOpenHarmonyPlatformWindow *> WindowStackType;
+    WindowStackType m_windowStack;
+    QRect m_dirtyRect;
+    bool m_updatePending = false;
+
+    QRect m_availableGeometry;
+    int m_depth;
+    QImage::Format m_format;
+    QSizeF m_physicalSize;
+
+private:
+    QDpi logicalDpi() const override;
+    qreal pixelDensity()  const override;
+    Qt::ScreenOrientation orientation() const override;
+    Qt::ScreenOrientation nativeOrientation() const override;
+    void releaseSurface();
+    void applicationStateChanged(Qt::ApplicationState);
+
+private slots:
+    void doRedraw();
+
+private:
+    QOpenHarmonyXComponent *m_component = nullptr;
+    QWaitCondition m_surfaceWaitCondition;
+    QSize m_size;
+    bool m_stopDraw;
+};
+
+QT_END_NAMESPACE
+#endif
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.cpp
new file mode 100644
index 0000000000..e10fd6b9a1
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.cpp
@@ -0,0 +1,42 @@
+#include "qopenharmonyplatformtheme.h"
+#include "qopenharmonyplatformdialoghelpers.h"
+
+#include <QCoreApplication>
+
+QOpenHarmonyPlatformTheme::QOpenHarmonyPlatformTheme()
+{
+
+}
+
+QString QOpenHarmonyPlatformTheme::standardButtonText(int button) const
+{
+    switch (button) {
+    case QPlatformDialogHelper::Yes:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "Yes");
+    case QPlatformDialogHelper::YesToAll:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "Yes to All");
+    case QPlatformDialogHelper::No:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "No");
+    case QPlatformDialogHelper::NoToAll:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "No to All");
+    }
+    return QPlatformTheme::standardButtonText(button);
+}
+
+bool QOpenHarmonyPlatformTheme::usePlatformNativeDialog(QPlatformTheme::DialogType type) const
+{
+    Q_UNUSED(type)
+    return true;
+}
+
+QPlatformDialogHelper *QOpenHarmonyPlatformTheme::createPlatformDialogHelper(QPlatformTheme::DialogType type) const
+{
+    switch (type) {
+    case MessageDialog:
+        return new QOpenHarmonyPlatformMessageDialogHelper;
+    case FileDialog:
+        return new QOpenHarmonyPlatformFileDialogHelper;
+    default:
+        return 0;
+    }
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.h b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.h
new file mode 100644
index 0000000000..06de62426a
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.h
@@ -0,0 +1,15 @@
+#ifndef QOPENHARMONYPLATFORMTHEME_H
+#define QOPENHARMONYPLATFORMTHEME_H
+
+#include <qpa/qplatformtheme.h>
+
+class QOpenHarmonyPlatformTheme: public QPlatformTheme
+{
+public:
+    QOpenHarmonyPlatformTheme();
+    virtual QString standardButtonText(int button) const override;
+    bool usePlatformNativeDialog(DialogType type) const override;
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const override;
+};
+
+#endif // QOPENHARMONYPLATFORMTHEME_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.cpp
new file mode 100644
index 0000000000..92e75915d3
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.cpp
@@ -0,0 +1,27 @@
+#include "qopenharmonyplatformvulkaninstance.h"
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformVulkanInstance::QOpenHarmonyPlatformVulkanInstance(QVulkanInstance *instance)
+    : m_instance(instance)
+{
+    m_lib.setFileName(QStringLiteral("vulkan"));
+
+    if (!m_lib.load()) {
+        qWarning("Failed to load %s", qPrintable(m_lib.fileName()));
+        return;
+    }
+
+    init(&m_lib);
+}
+
+void QOpenHarmonyPlatformVulkanInstance::createOrAdoptInstance()
+{
+    initInstance(m_instance, QByteArrayList() << QByteArrayLiteral("VK_KHR_android_surface"));
+}
+
+QOpenHarmonyPlatformVulkanInstance::~QOpenHarmonyPlatformVulkanInstance()
+{
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.h b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.h
new file mode 100644
index 0000000000..27803ba6a1
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.h
@@ -0,0 +1,24 @@
+#ifndef QOPENHARMONYPLATFORMVULKANINSTANCE_H
+#define QOPENHARMONYPLATFORMVULKANINSTANCE_H
+
+#include <QtVulkanSupport/private/qbasicvulkanplatforminstance_p.h>
+#include <QLibrary>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformVulkanInstance : public QBasicPlatformVulkanInstance
+{
+public:
+    QOpenHarmonyPlatformVulkanInstance(QVulkanInstance *instance);
+    ~QOpenHarmonyPlatformVulkanInstance();
+
+    void createOrAdoptInstance() override;
+
+private:
+    QVulkanInstance *m_instance;
+    QLibrary m_lib;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMVULKANINSTANCE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.cpp
new file mode 100644
index 0000000000..9a8b1663cb
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.cpp
@@ -0,0 +1,145 @@
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonyplatformscreen.h"
+
+#include <qguiapplication.h>
+#include <qpa/qwindowsysteminterface.h>
+#include <QtGui/private/qhighdpiscaling_p.h>
+#include <QtCore/qopenharmonyjsenvironment.h>
+#include <QtCore/qopenharmonydefines.h>
+
+QT_BEGIN_NAMESPACE
+
+enum {
+    defaultWindowWidth = 160,
+    defaultWindowHeight = 160
+};
+
+QOpenHarmonyPlatformWindow::QOpenHarmonyPlatformWindow(QWindow *window)
+    : QPlatformWindow(window)
+{
+    m_windowFlags = Qt::Widget;
+    m_windowState = Qt::WindowNoState;
+    static QAtomicInt winIdGenerator(1);
+    m_windowId = winIdGenerator.fetchAndAddRelaxed(1);
+    setWindowState(window->windowStates());
+    m_rect = initialGeometry(window,
+         QRect(0, 0, 400, 300), defaultWindowWidth, defaultWindowHeight);
+}
+
+void QOpenHarmonyPlatformWindow::lower()
+{
+    platformScreen()->lower(this);
+}
+
+void QOpenHarmonyPlatformWindow::raise()
+{
+    updateStatusBarVisibility();
+    platformScreen()->raise(this);
+}
+
+void QOpenHarmonyPlatformWindow::setGeometry(const QRect &rect)
+{
+    QWindowSystemInterface::handleGeometryChange(window(), rect);
+    QPlatformWindow::setGeometry(rect);
+    m_rect = rect;
+}
+
+QRect QOpenHarmonyPlatformWindow::geometry() const
+{
+    return m_rect;
+}
+
+void QOpenHarmonyPlatformWindow::setVisible(bool visible)
+{
+    if (visible) {
+        updateStatusBarVisibility();
+        if (m_windowState & Qt::WindowFullScreen)
+            setGeometry(platformScreen()->geometry());
+        else if (m_windowState & Qt::WindowMaximized)
+            setGeometry(platformScreen()->availableGeometry());
+        else if (m_windowState == Qt::WindowNoState) {
+            QRect rect = initialGeometry(window(),
+                                        window()->geometry(), defaultWindowWidth, defaultWindowHeight);
+            setGeometry(rect);
+        }
+        platformScreen()->addWindow(this);
+    } else {
+        platformScreen()->removeWindow(this);
+    }
+
+    QRect availableGeometry = screen()->availableGeometry();
+    if (geometry().width() > 0 && geometry().height() > 0 && availableGeometry.width() > 0 && availableGeometry.height() > 0)
+        QPlatformWindow::setVisible(visible);
+}
+
+void QOpenHarmonyPlatformWindow::setWindowState(Qt::WindowStates state)
+{
+    if (m_windowState == state)
+        return;
+
+    QPlatformWindow::setWindowState(state);
+    m_windowState = state;
+
+    if (window()->isVisible())
+        updateStatusBarVisibility();
+}
+
+void QOpenHarmonyPlatformWindow::setWindowFlags(Qt::WindowFlags flags)
+{
+    if (m_windowFlags == flags)
+        return;
+
+    m_windowFlags = flags;
+}
+
+Qt::WindowFlags QOpenHarmonyPlatformWindow::windowFlags() const
+{
+    return m_windowFlags;
+}
+
+void QOpenHarmonyPlatformWindow::setParent(const QPlatformWindow *window)
+{
+    Q_UNUSED(window);
+}
+
+QOpenHarmonyPlatformScreen *QOpenHarmonyPlatformWindow::platformScreen() const
+{
+    return static_cast<QOpenHarmonyPlatformScreen *>(window()->screen()->handle());
+}
+
+void QOpenHarmonyPlatformWindow::propagateSizeHints()
+{
+    //shut up warning from default implementation
+}
+
+void QOpenHarmonyPlatformWindow::requestActivateWindow()
+{
+    platformScreen()->topWindowChanged(window());
+}
+
+void QOpenHarmonyPlatformWindow::updateStatusBarVisibility()
+{
+    Qt::WindowFlags flags = window()->flags();
+    bool isNonRegularWindow = flags & (Qt::Popup | Qt::Dialog | Qt::Sheet) & ~Qt::Window;
+    if (!isNonRegularWindow) {
+    }
+}
+
+bool QOpenHarmonyPlatformWindow::isExposed() const
+{
+    return qApp->applicationState() > Qt::ApplicationHidden
+            && window()->isVisible()
+            && !window()->geometry().isEmpty();
+}
+
+void QOpenHarmonyPlatformWindow::applicationStateChanged(Qt::ApplicationState)
+{
+    QRegion region;
+    if (isExposed())
+        region = QRect(QPoint(), geometry().size());
+
+    QWindowSystemInterface::handleExposeEvent(window(), region);
+    QWindowSystemInterface::flushWindowSystemEvents();
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.h b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.h
new file mode 100644
index 0000000000..02a723f2c0
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.h
@@ -0,0 +1,64 @@
+#ifndef QOPENHARMONYPLATFORMWINDOW_H
+#define QOPENHARMONYPLATFORMWINDOW_H
+#include <qobject.h>
+#include <qrect.h>
+#include <qpa/qplatformwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformScreen;
+class QOpenHarmonyPlatformBackingStore;
+
+class QOpenHarmonyPlatformWindow: public QPlatformWindow
+{
+public:
+    explicit QOpenHarmonyPlatformWindow(QWindow *window);
+
+    void lower() override;
+    void raise() override;
+
+    void setVisible(bool visible) override;
+
+    void setWindowState(Qt::WindowStates state) override;
+    void setWindowFlags(Qt::WindowFlags flags) override;
+    Qt::WindowFlags windowFlags() const;
+    void setParent(const QPlatformWindow *window) override;
+    WId winId() const override { return m_windowId; }
+
+    QOpenHarmonyPlatformScreen *platformScreen() const;
+
+    void propagateSizeHints() override;
+    void requestActivateWindow() override;
+    void updateStatusBarVisibility();
+    inline bool isRaster() const {
+        if (isForeignWindow())
+            return false;
+
+        return window()->surfaceType() == QSurface::RasterSurface
+            || window()->surfaceType() == QSurface::RasterGLSurface;
+    }
+    bool isExposed() const override;
+
+    virtual void applicationStateChanged(Qt::ApplicationState);
+
+    void setBackingStore(QOpenHarmonyPlatformBackingStore *store) { m_backingStore = store; }
+    QOpenHarmonyPlatformBackingStore *backingStore() const { return m_backingStore; }
+
+    virtual void repaint(const QRegion &) { }
+
+    void setGeometry(const QRect &rect) override;
+
+    QRect geometry() const;
+
+protected:
+    Qt::WindowFlags m_windowFlags;
+    Qt::WindowStates m_windowState;
+
+    WId m_windowId;
+    QRect m_rect;
+
+    QOpenHarmonyPlatformBackingStore *m_backingStore = nullptr;
+};
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYPLATFORMWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonysurface.cpp b/src/plugins/platforms/openharmony/qopenharmonysurface.cpp
new file mode 100644
index 0000000000..3631305139
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonysurface.cpp
@@ -0,0 +1,180 @@
+#include "qopenharmonysurface.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyeglcore.h"
+
+#include <hilog/log.h>
+#include <ace/xcomponent/native_interface_xcomponent.h>
+
+QOpenHarmonySurface *QOpenHarmonySurface::m_self = nullptr;
+
+QOpenHarmonySurface::QOpenHarmonySurface(OH_NativeXComponent *component)
+    : m_nativeComponent(component)
+{
+    m_touchEventCallback = new OH_NativeXComponent_Callback;
+    m_touchEventCallback->OnSurfaceCreated = &QOpenHarmonySurface::onSurfaceCreated;
+    m_touchEventCallback->OnSurfaceChanged = &QOpenHarmonySurface::onSurfaceChanged;
+    m_touchEventCallback->OnSurfaceDestroyed = &QOpenHarmonySurface::onSurfaceDestroyed;
+    m_touchEventCallback->DispatchTouchEvent = &QOpenHarmonySurface::dispatchTouchEvent;
+    int32_t ret = OH_NativeXComponent_RegisterCallback(component, m_touchEventCallback);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+        LOGE("set surface touch callback failed");
+    }
+    m_mouseEventCallback = new OH_NativeXComponent_MouseEvent_Callback;
+    m_mouseEventCallback->DispatchMouseEvent = &QOpenHarmonySurface::dispatchMouseEvent;
+    m_mouseEventCallback->DispatchHoverEvent = &QOpenHarmonySurface::dispatchHoverEvent;
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+        LOGE("set surface mouse callback failed");
+    }
+    m_self = this;
+}
+
+QOpenHarmonySurface::~QOpenHarmonySurface()
+{
+    delete m_touchEventCallback;
+}
+
+void QOpenHarmonySurface::onSurfaceCreated(OH_NativeXComponent *component, void *window)
+{
+    m_self->m_nativeWindow = reinterpret_cast<EGLNativeWindowType>(window);
+    m_self->getSurfaceInfo(component, window);
+    QOpenHarmonyEGLCore::instance()->onSurfaceCreated(m_self->m_nativeWindow, m_self->m_width, m_self->m_height);
+}
+
+void QOpenHarmonySurface::onSurfaceChanged(OH_NativeXComponent *component, void *window)
+{
+    m_self->getSurfaceInfo(component, window);
+}
+
+void QOpenHarmonySurface::onSurfaceDestroyed(OH_NativeXComponent *component, void *window)
+{
+//    QOpenHarmonyEGLCore::instance()->onSurfaceDestroyed(m_self->m_nativeWindow);
+}
+
+void QOpenHarmonySurface::dispatchTouchEvent(OH_NativeXComponent *component, void *window)
+{
+    OH_NativeXComponent_TouchEvent touchEvent;
+    int32_t ret = OH_NativeXComponent_GetTouchEvent(component, window, &touchEvent);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+    QOpenHarmonyPlatformInputContext *context = QOpenHarmonyPlatformInputContext::openHarmonyInputContext();
+    context->touchBegin();
+    for (int i = 0; i < touchEvent.numPoints; i++) {
+        OH_NativeXComponent_TouchPoint &point = touchEvent.touchPoints[i];
+        context->touchAdd(touchEvent.deviceId, static_cast<int>(point.type), point.force, point.x, point.y);
+    }
+    OH_NativeXComponent_TouchEventType type = touchEvent.type;
+    switch (type) {
+    case OH_NATIVEXCOMPONENT_DOWN:
+        context->touchEnd(0);
+        break;
+    case OH_NATIVEXCOMPONENT_UP:
+        context->touchEnd(2);
+        break;
+
+    default:
+        context->touchEnd(1);
+    }
+}
+
+void QOpenHarmonySurface::dispatchMouseEvent(OH_NativeXComponent *component, void *window)
+{
+    OH_NativeXComponent_MouseEvent mouseEvent;
+    int32_t ret = OH_NativeXComponent_GetMouseEvent(component, window, &mouseEvent);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+    OH_NativeXComponent_MouseEventAction action = mouseEvent.action;
+    switch (action) {
+    case OH_NATIVEXCOMPONENT_MOUSE_RELEASE:
+        QOpenHarmonyPlatformInputContext::openHarmonyInputContext()->mouseRelease(mouseEvent.x, mouseEvent.y);
+        break;
+    case OH_NATIVEXCOMPONENT_MOUSE_PRESS:
+        QOpenHarmonyPlatformInputContext::openHarmonyInputContext()->mousePress(mouseEvent.x, mouseEvent.y);
+        break;
+    case OH_NATIVEXCOMPONENT_MOUSE_MOVE:
+        break;
+    }
+}
+
+void QOpenHarmonySurface::dispatchHoverEvent(OH_NativeXComponent *component, bool isHover)
+{
+
+}
+
+void QOpenHarmonySurface::getSurfaceInfo(OH_NativeXComponent *component, void *window)
+{
+    uint64_t w;
+    uint64_t h;
+    int32_t ret = OH_NativeXComponent_GetXComponentSize(component, window, &w, &h);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+        LOGE("Get surface size failed");
+        return;
+    }
+
+    LOGI("Get surface size (%{public}llu, %{public}llu)", w, h);
+    setWidth(w);
+    setHeight(h);
+}
+
+EGLNativeWindowType QOpenHarmonySurface::nativeWindow() const
+{
+    return m_nativeWindow;
+}
+
+int QOpenHarmonySurface::height() const
+{
+    return m_height;
+}
+
+void QOpenHarmonySurface::setHeight(int height)
+{
+    if (m_height != height) {
+        m_height = height;
+    }
+}
+
+QOpenHarmonySurface *QOpenHarmonySurface::instance()
+{
+    return m_self;
+}
+
+int QOpenHarmonySurface::width() const
+{
+    return m_width;
+}
+
+void QOpenHarmonySurface::setWidth(int width)
+{
+    if (m_width != width) {
+        m_width = width;
+    }
+}
+
+namespace QtOpenHarmonySurface {
+
+static QOpenHarmonySurface *m_surface;
+
+void init(napi_env env, napi_value exports)
+{
+    napi_value exportInstance = nullptr;
+    OH_NativeXComponent *nativeXComponent = nullptr;
+    int32_t ret;
+    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = { };
+    uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;
+
+    NAPI_CALL_RETURN_VOID(env, napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance));
+    NAPI_CALL_RETURN_VOID(env, napi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent)));
+
+    ret = OH_NativeXComponent_GetXComponentId(nativeXComponent, idStr, &idSize);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+        return;
+    }
+    m_surface = new QOpenHarmonySurface(nativeXComponent);
+}
+
+void unInit()
+{
+    delete m_surface;
+}
+
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonysurface.h b/src/plugins/platforms/openharmony/qopenharmonysurface.h
new file mode 100644
index 0000000000..f768f216f2
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonysurface.h
@@ -0,0 +1,55 @@
+#ifndef QOPENHARMONYSURFACE_H
+#define QOPENHARMONYSURFACE_H
+
+#include <QObject>
+#include <EGL/egl.h>
+#include <napi/native_api.h>
+
+struct OH_NativeXComponent;
+struct OH_NativeXComponent_Callback;
+struct OH_NativeXComponent_MouseEvent_Callback;
+
+class QOpenHarmonySurface
+{
+public:
+    QOpenHarmonySurface(OH_NativeXComponent *component);
+    ~QOpenHarmonySurface();
+    int width() const;
+    void setWidth(int width);
+
+    int height() const;
+    void setHeight(int height);
+
+    static QOpenHarmonySurface *instance();
+
+    EGLNativeWindowType nativeWindow() const;
+
+private:
+    static void onSurfaceCreated(OH_NativeXComponent* component, void* window);
+
+    static void onSurfaceChanged(OH_NativeXComponent* component, void* window);
+
+    static void onSurfaceDestroyed(OH_NativeXComponent* component, void* window);
+
+    static void dispatchTouchEvent(OH_NativeXComponent* component, void* window);
+
+    static void dispatchMouseEvent(OH_NativeXComponent* component, void* window);
+
+    static void dispatchHoverEvent(OH_NativeXComponent* component, bool isHover);
+
+private:
+    void getSurfaceInfo(OH_NativeXComponent* component, void* window);
+private:
+    OH_NativeXComponent *m_nativeComponent = nullptr;
+    OH_NativeXComponent_Callback *m_touchEventCallback = nullptr;
+    OH_NativeXComponent_MouseEvent_Callback *m_mouseEventCallback = nullptr;
+    int m_width = 0;
+    int m_height = 0;
+    EGLNativeWindowType m_nativeWindow;
+    static QOpenHarmonySurface *m_self;
+};
+namespace QtOpenHarmonySurface {
+void init(napi_env env, napi_value exports);
+void unInit();
+}
+#endif // QOPENHARMONYSURFACE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyxcomponent.cpp b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.cpp
new file mode 100644
index 0000000000..9e8085f886
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.cpp
@@ -0,0 +1,636 @@
+#include <QDebug>
+#include <QKeyEvent>
+
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonyxcomponentmanager.h"
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+#include <ace/xcomponent/native_interface_xcomponent.h>
+#include <ace/xcomponent/native_xcomponent_key_event.h>
+
+
+QOpenHarmonyXComponent::QOpenHarmonyXComponent(OH_NativeXComponent *component)
+    : m_nativeComponent(component)
+    , m_nativeWindow(0)
+{
+    m_egl.reset(new QOpenHarmonyEGLCore);
+    initXComponent(component);
+}
+
+QOpenHarmonyXComponent::~QOpenHarmonyXComponent()
+{
+    delete m_touchEventCallback;
+    delete m_mouseEventCallback;
+}
+
+void QOpenHarmonyXComponent::paint(const QImage &image)
+{
+    if (!m_surfaceCreated)
+        m_surfaceCreated = createEglSurface();
+    if (m_surfaceCreated)
+        m_egl->drawImage(image);
+}
+
+void QOpenHarmonyXComponent::onSurfaceCreated(OH_NativeXComponent *component, void *window)
+{
+    QOpenHarmonyXComponent *xc = QOpenHarmonyXComponentManager::instance()->xcomponent(component);
+    if (xc == nullptr)
+        return;
+   EGLNativeWindowType nativeWindow = reinterpret_cast<EGLNativeWindowType>(window);
+   xc->getSurfaceInfo(component, nativeWindow);
+}
+
+void QOpenHarmonyXComponent::onSurfaceChanged(OH_NativeXComponent *component, void *window)
+{
+    QOpenHarmonyXComponent *xc = QOpenHarmonyXComponentManager::instance()->xcomponent(component);
+    if (xc == nullptr)
+        return;
+    EGLNativeWindowType nativeWindow = reinterpret_cast<EGLNativeWindowType>(window);
+    xc->getSurfaceInfo(component, nativeWindow);
+}
+
+void QOpenHarmonyXComponent::onSurfaceDestroyed(OH_NativeXComponent *component, void *window)
+{
+  //    QOpenHarmonyEGLCore::instance()->onSurfaceDestroyed(m_nativeWindow);
+}
+
+void QOpenHarmonyXComponent::dispatchKeyEvent(OH_NativeXComponent *component, void *window)
+{
+    LOGW("<<<<<<<<::: dispatchKeyEvent:");
+    QOpenHarmonyXComponent *xc = QOpenHarmonyXComponentManager::instance()->xcomponent(component);
+    if (Q_NULLPTR == xc)
+        return;
+
+    OH_NativeXComponent_KeyEvent *keyEvent = Q_NULLPTR;
+    int32_t ret = OH_NativeXComponent_GetKeyEvent(component, &keyEvent);
+    if (OH_NATIVEXCOMPONENT_RESULT_SUCCESS != ret) {
+        LOGW("get key event failed");
+        delete keyEvent;
+        return;
+    }    
+
+    QOpenHarmonyPlatformInputContext *context = QOpenHarmonyPlatformInputContext::openHarmonyInputContext();
+    if (Q_NULLPTR == context)
+        return;
+
+    static QHash<OH_NativeXComponent_KeyAction, QEvent::Type> sKeyType{
+                                                                         { OH_NATIVEXCOMPONENT_KEY_ACTION_DOWN, QEvent::KeyPress },
+                                                                         { OH_NATIVEXCOMPONENT_KEY_ACTION_UP, QEvent::KeyRelease },
+                                                                         };
+
+    OH_NativeXComponent_KeyCode code;
+    OH_NativeXComponent_KeyAction keyAct;
+    OH_NativeXComponent_GetKeyEventCode(keyEvent, &code);
+    OH_NativeXComponent_GetKeyEventAction(keyEvent, &keyAct);
+
+    LOGW("<<<<<<<<::: key code:", code);
+    static QHash<OH_NativeXComponent_KeyCode, Qt::Key> sKeyMap{
+        { KEY_HOME, Qt::Key_Home },
+        { KEY_BACK, Qt::Key_Back },
+        { KEY_MEDIA_PLAY_PAUSE, Qt::Key_MediaTogglePlayPause },
+        { KEY_MEDIA_STOP, Qt::Key_MediaStop },
+        { KEY_MEDIA_NEXT, Qt::Key_MediaNext },
+        { KEY_MEDIA_PREVIOUS, Qt::Key_MediaPrevious },
+        { KEY_MEDIA_REWIND, Qt::Key_AudioRewind },
+        { KEY_MEDIA_FAST_FORWARD, Qt::Key_AudioForward },
+        { KEY_VOLUME_UP, Qt::Key_VolumeUp },
+        { KEY_VOLUME_DOWN, Qt::Key_VolumeDown },
+        { KEY_POWER, Qt::Key_PowerDown },
+        { KEY_CAMERA, Qt::Key_Camera },
+        { KEY_VOLUME_MUTE, Qt::Key_VolumeMute },
+        { KEY_MUTE, Qt::Key_MicMute },
+        { KEY_BRIGHTNESS_UP, Qt::Key_MonBrightnessUp },
+        { KEY_BRIGHTNESS_DOWN, Qt::Key_MonBrightnessDown },
+        { KEY_0, Qt::Key_0 },
+        { KEY_1, Qt::Key_1 },
+        { KEY_2, Qt::Key_2 },
+        { KEY_3, Qt::Key_3 },
+        { KEY_4, Qt::Key_4 },
+        { KEY_5, Qt::Key_5 },
+        { KEY_6, Qt::Key_6 },
+        { KEY_7, Qt::Key_7 },
+        { KEY_8, Qt::Key_8 },
+        { KEY_9, Qt::Key_9 },
+        { KEY_STAR, Qt::Key_Asterisk },
+        { KEY_POUND, Qt::Key_NumberSign },
+        { KEY_DPAD_UP, Qt::Key_Up },
+        { KEY_DPAD_DOWN, Qt::Key_Down },
+        { KEY_DPAD_LEFT, Qt::Key_Left },
+        { KEY_DPAD_RIGHT, Qt::Key_Right },
+        //{ KEY_DPAD_CENTER, Qt::Key_ },
+        { KEY_A, Qt::Key_A },
+        { KEY_B, Qt::Key_B },
+        { KEY_C, Qt::Key_C },
+        { KEY_D, Qt::Key_D },
+        { KEY_E, Qt::Key_E },
+        { KEY_F, Qt::Key_F },
+        { KEY_G, Qt::Key_G },
+        { KEY_H, Qt::Key_H },
+        { KEY_I, Qt::Key_I },
+        { KEY_J, Qt::Key_J },
+        { KEY_K, Qt::Key_K },
+        { KEY_L, Qt::Key_L },
+        { KEY_M, Qt::Key_M },
+        { KEY_N, Qt::Key_N },
+        { KEY_O, Qt::Key_O },
+        { KEY_P, Qt::Key_P },
+        { KEY_Q, Qt::Key_Q },
+        { KEY_R, Qt::Key_R },
+        { KEY_S, Qt::Key_S },
+        { KEY_T, Qt::Key_T },
+        { KEY_U, Qt::Key_U },
+        { KEY_V, Qt::Key_V },
+        { KEY_W, Qt::Key_W },
+        { KEY_X, Qt::Key_X },
+        { KEY_Y, Qt::Key_Y },
+        { KEY_Z, Qt::Key_Z },
+        { KEY_COMMA, Qt::Key_Comma },
+        { KEY_PERIOD, Qt::Key_Period },
+        { KEY_ALT_LEFT, Qt::Key_Alt },
+        { KEY_ALT_RIGHT, Qt::Key_Alt },
+        { KEY_SHIFT_LEFT, Qt::Key_Shift },
+        { KEY_SHIFT_RIGHT, Qt::Key_Shift },
+        { KEY_TAB, Qt::Key_Tab  },
+        { KEY_SPACE, Qt::Key_Space },
+        //{ KEY_SYM, Qt::KEY_},
+        { KEY_EXPLORER, Qt::Key_Explorer },
+        //{ KEY_ENVELOPE, Qt::Key_ },
+        { KEY_ENTER, Qt::Key_Return },
+        { KEY_DEL, Qt::Key_Back },
+        { KEY_GRAVE, Qt::Key_Apostrophe },
+        { KEY_MINUS, Qt::Key_Minus },
+        { KEY_EQUALS, Qt::Key_Equal },
+        { KEY_LEFT_BRACKET, Qt::Key_BracketLeft },
+        { KEY_RIGHT_BRACKET, Qt::Key_BracketRight },
+        { KEY_BACKSLASH, Qt::Key_Backslash },
+        { KEY_SEMICOLON, Qt::Key_Semicolon },
+        { KEY_APOSTROPHE, Qt::Key_Apostrophe },
+        { KEY_SLASH, Qt::Key_Slash },
+        { KEY_AT, Qt::Key_At },
+        { KEY_PLUS, Qt::Key_Plus },
+        { KEY_MENU, Qt::Key_Menu },
+        { KEY_PAGE_UP, Qt::Key_PageUp },
+        { KEY_PAGE_DOWN, Qt::Key_PageDown },
+        { KEY_ESCAPE, Qt::Key_Escape },
+        { KEY_FORWARD_DEL, Qt::Key_Delete },
+        { KEY_CTRL_LEFT, Qt::Key_Control },
+        { KEY_CTRL_RIGHT, Qt::Key_Control },
+        { KEY_CAPS_LOCK, Qt::Key_CapsLock },
+        { KEY_SCROLL_LOCK, Qt::Key_ScrollLock },
+        { KEY_META_LEFT, Qt::Key_Meta },
+        { KEY_META_RIGHT, Qt::Key_Meta },
+        //{ KEY_FUNCTION, Qt::Key_ },
+        { KEY_SYSRQ, Qt::Key_SysReq },
+        { KEY_BREAK, Qt::Key_Pause },
+        { KEY_MOVE_HOME, Qt::Key_Home },
+        { KEY_MOVE_END, Qt::Key_End },
+        { KEY_INSERT, Qt::Key_Insert },
+        { KEY_FORWARD, Qt::Key_Forward },
+        { KEY_MEDIA_PLAY, Qt::Key_MediaPlay },
+        { KEY_MEDIA_PAUSE, Qt::Key_MediaPause },
+        //{ KEY_MEDIA_CLOSE, Qt::Key_Media },
+        //{ KEY_MEDIA_EJECT, Qt::Key_Eject },
+        { KEY_MEDIA_RECORD, Qt::Key_MediaRecord },
+        { KEY_F1, Qt::Key_F1 },
+        { KEY_F2, Qt::Key_F2 },
+        { KEY_F3, Qt::Key_F3 },
+        { KEY_F4, Qt::Key_F4 },
+        { KEY_F5, Qt::Key_F5 },
+        { KEY_F6, Qt::Key_F6 },
+        { KEY_F7, Qt::Key_F7 },
+        { KEY_F8, Qt::Key_F8 },
+        { KEY_F9, Qt::Key_F9 },
+        { KEY_F10, Qt::Key_F10 },
+        { KEY_F11, Qt::Key_F11 },
+        { KEY_F12, Qt::Key_F12 },
+        { KEY_NUM_LOCK, Qt::Key_NumLock },
+        { KEY_NUMPAD_0, Qt::Key_0 },
+        { KEY_NUMPAD_1, Qt::Key_1 },
+        { KEY_NUMPAD_2, Qt::Key_2 },
+        { KEY_NUMPAD_3, Qt::Key_3 },
+        { KEY_NUMPAD_4, Qt::Key_4 },
+        { KEY_NUMPAD_5, Qt::Key_5 },
+        { KEY_NUMPAD_6, Qt::Key_6 },
+        { KEY_NUMPAD_7, Qt::Key_7 },
+        { KEY_NUMPAD_8, Qt::Key_8 },
+        { KEY_NUMPAD_9, Qt::Key_9 },
+        { KEY_NUMPAD_DIVIDE, Qt::Key_Slash },
+        { KEY_NUMPAD_MULTIPLY, Qt::Key_Asterisk },
+        { KEY_NUMPAD_SUBTRACT, Qt::Key_Minus },
+        { KEY_NUMPAD_ADD, Qt::Key_Plus },
+        { KEY_NUMPAD_DOT, Qt::Key_Period },
+        { KEY_NUMPAD_COMMA, Qt::Key_Comma },
+        { KEY_NUMPAD_ENTER, Qt::Key_Enter },
+        { KEY_NUMPAD_EQUALS, Qt::Key_Equal },
+        { KEY_NUMPAD_LEFT_PAREN, Qt::Key_ParenLeft },
+        { KEY_NUMPAD_RIGHT_PAREN, Qt::Key_ParenRight },
+        //{ KEY_VIRTUAL_MULTITASK, Qt::Key_ },
+        { KEY_SLEEP, Qt::Key_Sleep },
+        { KEY_ZENKAKU_HANKAKU, Qt::Key_Zenkaku_Hankaku },
+        //{ KEY_102ND,  Qt::Key_ },
+        //{ KEY_RO,  Qt::Key_ },
+        { KEY_KATAKANA, Qt::Key_Katakana },
+        { KEY_HIRAGANA, Qt::Key_Hiragana },
+        { KEY_HENKAN, Qt::Key_Henkan },
+        { KEY_KATAKANA_HIRAGANA, Qt::Key_Hiragana_Katakana },
+        { KEY_MUHENKAN, Qt::Key_Muhenkan },
+        { KEY_LINEFEED, Qt::Key_Return },
+        //{ KEY_MACRO, Qt::Key_macron },
+        //{ KEY_NUMPAD_PLUSMINUS, Qt::Key_ },
+        //{ KEY_SCALE, Qt::Key_ },
+        { KEY_HANGUEL, Qt::Key_Hangul },
+        { KEY_HANJA, Qt::Key_Hangul_Hanja },
+        { KEY_YEN, Qt::Key_yen },
+        { KEY_STOP, Qt::Key_Stop },
+        //{ KEY_AGAIN, Qt::Key_ },
+        //{ KEY_PROPS, Qt::Key_ },
+        { KEY_UNDO, Qt::Key_Undo },
+        { KEY_COPY, Qt::Key_Copy },
+        { KEY_OPEN, Qt::Key_Open },
+        { KEY_PASTE, Qt::Key_Paste },
+        { KEY_FIND, Qt::Key_Find },
+        { KEY_CUT, Qt::Key_Cut },
+        { KEY_HELP, Qt::Key_Help },
+        //{ KEY_CALC, Qt::Key_ },
+        //{ KEY_FILE, Qt::Key_ },
+        //{ KEY_BOOKMARKS, Qt::Key_Book },
+        //{ KEY_NEXT, Qt::Key_ },
+        //{ KEY_PLAYPAUSE, Qt::Key_MediaTogglePlayPause }
+        //{ KEY_PREVIOUS, Qt::Key_ },
+        //{ KEY_STOPCD, Qt::Key_ },
+        //{ KEY_CONFIG, Qt::Key_ },
+        { KEY_REFRESH, Qt::Key_Refresh },
+        { KEY_EXIT, Qt::Key_Exit },
+        //{ KEY_EDIT, Qt::Key_ },
+        //{ KEY_SCROLLUP, Qt::Key_ },
+        //{ KEY_SCROLLDOWN, Qt::Key_ },
+        { KEY_NEW, Qt::Key_New },
+        { KEY_REDO, Qt::Key_Redo },
+        { KEY_CLOSE, Qt::Key_Close },
+        { KEY_PLAY, Qt::Key_Play },
+        //{ KEY_BASSBOOST, Qt::Key_ },
+        { KEY_PRINT, Qt::Key_Print },
+        //{ KEY_CHAT, Qt::Key_ },
+        { KEY_FINANCE, Qt::Key_Finance },
+        { KEY_CANCEL, Qt::Key_Cancel },
+        //{ KEY_KBDILLUM_TOGGLE, Qt::Key_ },
+        { KEY_KBDILLUM_DOWN, Qt::Key_KeyboardBrightnessDown },
+        { KEY_KBDILLUM_UP, Qt::Key_KeyboardBrightnessUp },
+        { KEY_SEND, Qt::Key_Send },
+        { KEY_REPLY, Qt::Key_Reply },
+        { KEY_FORWARDMAIL, Qt::Key_Forward },
+        { KEY_SAVE, Qt::Key_Save },
+        { KEY_DOCUMENTS, Qt::Key_Documents },
+        //{ KEY_VIDEO_NEXT, Qt::Key_ },
+        //{ KEY_VIDEO_PREV, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_CYCLE, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_ZERO, Qt::Key_ },
+        //{ KEY_DISPLAY_OFF, Qt::Key_ },
+        //{ KEY_BTN_MISC, Qt::Key_ },
+        { KEY_GOTO, Qt::Key_Go },
+        { KEY_INFO, Qt::Key_Info },
+        //{ KEY_PROGRAM, Qt::Key_ },
+        //{ KEY_PVR, Qt::Key_ },
+        { KEY_SUBTITLE, Qt::Key_Subtitle },
+        //{ KEY_FULL_SCREEN, Qt::Key_ },
+        //{ KEY_KEYBOARD, Qt::Key_ },
+        //{ KEY_ASPECT_RATIO, Qt::Key_ },
+        //{ KEY_PC, Qt::Key_ },
+        //{ KEY_TV, Qt::Key_ },
+        //{ KEY_TV2, Qt::Key_ },
+        //{ KEY_VCR, Qt::Key_ },
+        //{ KEY_VCR2, Qt::Key_ },
+        //{ KEY_SAT, Qt::Key_ },
+        { KEY_CD, Qt::Key_CD },
+        //{ KEY_TAPE, Qt::Key_ },
+        //{ KEY_TUNER, Qt::Key_ },
+        { KEY_PLAYER, Qt::Key_Play },
+        //{ KEY_DVD, Qt::Key_ },
+        //{ KEY_AUDIO, Qt::Key_ },
+        { KEY_VIDEO, Qt::Key_Video },
+        { KEY_MEMO, Qt::Key_Memo },
+        { KEY_CALENDAR, Qt::Key_Calendar },
+        { KEY_RED, Qt::Key_Red },
+        { KEY_GREEN, Qt::Key_Green },
+        { KEY_YELLOW, Qt::Key_Yellow },
+        { KEY_BLUE, Qt::Key_Blue },
+        { KEY_CHANNELUP, Qt::Key_ChannelUp },
+        { KEY_CHANNELDOWN, Qt::Key_ChannelDown },
+        //{ KEY_LAST, Qt::Key_ },
+        //{ KEY_RESTART, Qt::Key_ },
+        //{ KEY_SLOW, Qt::Key_ },
+        //{ KEY_SHUFFLE, Qt::Key_ },
+        //{ KEY_VIDEOPHONE, Qt::Key_ },
+        { KEY_GAMES, Qt::Key_Game },
+        { KEY_ZOOMIN, Qt::Key_ZoomIn },
+        { KEY_ZOOMOUT, Qt::Key_ZoomOut },
+        //{ KEY_ZOOMRESET, Qt::Key_ },
+        //{ KEY_WORDPROCESSOR, Qt::Key_ },
+        //{ KEY_EDITOR, Qt::Key_ },
+        //{ KEY_SPREADSHEET, Qt::Key_ },
+        //{ KEY_GRAPHICSEDITOR, Qt::Key_ },
+        //{ KEY_PRESENTATION, Qt::Key_ },
+        //{ KEY_DATABASE, Qt::Key_ },
+        { KEY_NEWS, Qt::Key_News },
+        //{ KEY_VOICEMAIL, Qt::Key_ },
+        //{ KEY_ADDRESSBOOK, Qt::Key_ },
+        { KEY_MESSENGER, Qt::Key_Messenger },
+        //{ KEY_BRIGHTNESS_TOGGLE, Qt::Key_BrightnessAdjust }
+        //{ KEY_SPELLCHECK, Qt::Key_Spell }
+        //{ KEY_COFFEE, Qt::Key_ },
+        //{ KEY_MEDIA_REPEAT, Qt::Key_ },
+        //{ KEY_IMAGES, Qt::Key_ },
+        //{ KEY_BUTTONCONFIG, Qt::Key_ },
+        //{ KEY_TASKMANAGER, Qt::Key_TaskPane }
+        //{ KEY_JOURNAL, Qt::Key_ },
+        //{ KEY_CONTROLPANEL, Qt::Key_ },
+        //{ KEY_APPSELECT, Qt::Key_ },
+        { KEY_SCREENSAVER, Qt::Key_ScreenSaver },
+        //{ KEY_ASSISTANT, Qt::Key_ },
+        //{ KEY_KBD_LAYOUT_NEXT, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_MIN, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_MAX, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_PREV, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_NEXT, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_PREVGROUP, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_NEXTGROUP, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_ACCEPT, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_CANCEL, Qt::Key_ },
+        //{ KEY_FRONT, Qt::Key_ }
+        //{ KEY_SETUP, Qt::Key_Settings },
+        { KEY_WAKEUP, Qt::Key_WakeUp },
+        //{ KEY_SENDFILE, Qt::Key_ },
+        //{ KEY_DELETEFILE, Qt::Key_ },
+        { KEY_XFER, Qt::Key_Xfer },
+        //{ KEY_PROG1, Qt::Key_ },
+        //{ KEY_PROG2, Qt::Key_ },
+        //{ KEY_MSDOS, Qt::Key_ },
+        //{ KEY_SCREENLOCK, Qt::Key_ },
+        //{ KEY_DIRECTION_ROTATE_DISPLAY, Qt::Key },
+        //{ KEY_CYCLEWINDOWS, Qt::Key_ },
+        //{ KEY_COMPUTER, Qt::Key },
+        { KEY_EJECTCLOSECD, Qt::Key_Eject },
+        //{ KEY_ISO, Qt::Key_ },
+        //{ KEY_MOVE, Qt::Key_ },
+        { KEY_F13, Qt::Key_F13 },
+        { KEY_F14, Qt::Key_F14 },
+        { KEY_F15, Qt::Key_F15 },
+        { KEY_F16, Qt::Key_F16 },
+        { KEY_F17, Qt::Key_F17 },
+        { KEY_F18, Qt::Key_F18 },
+        { KEY_F19, Qt::Key_F19 },
+        { KEY_F20, Qt::Key_F20 },
+        { KEY_F21, Qt::Key_F21 },
+        { KEY_F22, Qt::Key_F22 },
+        { KEY_F23, Qt::Key_F23 },
+        { KEY_F24, Qt::Key_F24 },
+        //{ KEY_PROG3, Qt::Key_ },
+        //{ KEY_PROG4, Qt::Key_ },
+        //{ KEY_DASHBOARD, Qt::Key_ },
+        { KEY_SUSPEND, Qt::Key_Suspend },
+        //{ KEY_HP, Qt::Key_ },
+        //{ KEY_SOUND, Qt::Key_ },
+        { KEY_QUESTION, Qt::Key_Question },
+        //{ KEY_CONNECT, Qt::Key_ },
+        //{ KEY_SPORT, Qt::Key_ },
+        { KEY_SHOP, Qt::Key_Shop },
+        //{ KEY_ALTERASE, Qt::Key_ },
+        //{ KEY_SWITCHVIDEOMODE, Qt::Key_Mode_switch }
+        { KEY_BATTERY, Qt::Key_Battery },
+        { KEY_BLUETOOTH, Qt::Key_Bluetooth },
+        { KEY_WLAN, Qt::Key_WLAN },
+        { KEY_UWB, Qt::Key_UWB },
+        //{ KEY_WWAN_WIMAX, Qt::Key_ },
+        //{ KEY_RFKILL, Qt::Key_ },
+        //{ KEY_CHANNEL, Qt::Key_ },
+        { KEY_BTN_0, Qt::Key_0 },
+        { KEY_BTN_1, Qt::Key_1 },
+        { KEY_BTN_2, Qt::Key_2 },
+        { KEY_BTN_3, Qt::Key_3 },
+        { KEY_BTN_4, Qt::Key_4 },
+        { KEY_BTN_5, Qt::Key_5 },
+        { KEY_BTN_6, Qt::Key_6 },
+        { KEY_BTN_7, Qt::Key_7 },
+        { KEY_BTN_8, Qt::Key_8 },
+        { KEY_BTN_9, Qt::Key_9 }
+    };
+
+    static QHash<OH_NativeXComponent_KeyCode, Qt::KeyboardModifiers> sKeyModifers{
+        { KEY_SHIFT_LEFT, Qt::ShiftModifier },
+        { KEY_SHIFT_RIGHT, Qt::ShiftModifier },
+        { KEY_CTRL_LEFT, Qt::ControlModifier },
+        { KEY_CTRL_RIGHT, Qt::ControlModifier },
+        { KEY_ALT_LEFT, Qt::AltModifier },
+        { KEY_ALT_RIGHT, Qt::AltModifier },
+        { KEY_META_LEFT, Qt::MetaModifier },
+        { KEY_META_RIGHT, Qt::MetaModifier },
+        { KEY_NUM_LOCK, Qt::KeypadModifier },
+        { KEY_NUMPAD_0, Qt::KeypadModifier },
+        { KEY_NUMPAD_1, Qt::KeypadModifier },
+        { KEY_NUMPAD_2, Qt::KeypadModifier },
+        { KEY_NUMPAD_3, Qt::KeypadModifier },
+        { KEY_NUMPAD_4, Qt::KeypadModifier },
+        { KEY_NUMPAD_5, Qt::KeypadModifier },
+        { KEY_NUMPAD_6, Qt::KeypadModifier },
+        { KEY_NUMPAD_7, Qt::KeypadModifier },
+        { KEY_NUMPAD_8, Qt::KeypadModifier },
+        { KEY_NUMPAD_9, Qt::KeypadModifier },
+        { KEY_NUMPAD_DIVIDE, Qt::KeypadModifier },
+        { KEY_NUMPAD_MULTIPLY, Qt::KeypadModifier },
+        { KEY_NUMPAD_SUBTRACT, Qt::KeypadModifier },
+        { KEY_NUMPAD_ADD, Qt::KeypadModifier },
+        { KEY_NUMPAD_DOT, Qt::KeypadModifier },
+        { KEY_NUMPAD_COMMA, Qt::KeypadModifier },
+        { KEY_NUMPAD_ENTER, Qt::KeypadModifier },
+        { KEY_NUMPAD_EQUALS, Qt::KeypadModifier },
+        { KEY_NUMPAD_LEFT_PAREN, Qt::KeypadModifier },
+        { KEY_NUMPAD_RIGHT_PAREN, Qt::KeypadModifier},
+    };
+    static int nativeModifier = Qt::NoModifier;
+    if (sKeyModifers.keys().contains(code))
+        nativeModifier |= code;
+
+    Qt::Key k = sKeyMap.value(code, Qt::Key_unknown);
+    QEvent::Type t = sKeyType.value(keyAct, QEvent::None);
+    Qt::KeyboardModifiers modifiers(Qt::NoModifier);
+    modifiers |= sKeyModifers.value(code, Qt::NoModifier);
+
+    QKeyEvent kEvent(t, k, modifiers, code, code, nativeModifier);
+    context->sendKeyEvent(&kEvent);
+}
+
+void QOpenHarmonyXComponent::dispatchTouchEvent(OH_NativeXComponent *component, void *window)
+{
+    QOpenHarmonyXComponent *xc = QOpenHarmonyXComponentManager::instance()->xcomponent(component);
+    if (xc == nullptr)
+        return;
+    OH_NativeXComponent_TouchEvent touchEvent;
+    int32_t ret = OH_NativeXComponent_GetTouchEvent(component, window, &touchEvent);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+    QOpenHarmonyPlatformInputContext *context = QOpenHarmonyPlatformInputContext::openHarmonyInputContext();
+    context->touchBegin();
+    int left = xc->m_geometry.left();
+    int top = xc->m_geometry.top();
+    for (int i = 0; i < touchEvent.numPoints; i++) {
+        OH_NativeXComponent_TouchPoint &point = touchEvent.touchPoints[i];
+        float x = point.x + left;
+        float y = point.y + top;
+        context->touchAdd(touchEvent.deviceId, touchEvent.type, point.force, x, y);
+    }
+    context->touchEnd(0);
+}
+
+void QOpenHarmonyXComponent::dispatchMouseEvent(OH_NativeXComponent *component, void *window)
+{
+    QOpenHarmonyXComponent *xc = QOpenHarmonyXComponentManager::instance()->xcomponent(component);
+    if (xc == nullptr)
+        return;
+    OH_NativeXComponent_MouseEvent mouseEvent;
+    int32_t ret = OH_NativeXComponent_GetMouseEvent(component, window, &mouseEvent);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+    int left = xc->m_geometry.left();
+    int top = xc->m_geometry.top();
+    float x = mouseEvent.x + left;
+    float y = mouseEvent.y + top;
+    OH_NativeXComponent_MouseEventAction action = mouseEvent.action;
+    switch (action) {
+    case OH_NATIVEXCOMPONENT_MOUSE_RELEASE:
+        QOpenHarmonyPlatformInputContext::openHarmonyInputContext()->mouseRelease(x, y);
+        break;
+    case OH_NATIVEXCOMPONENT_MOUSE_PRESS:
+        QOpenHarmonyPlatformInputContext::openHarmonyInputContext()->mousePress(x, y);
+        break;
+    case OH_NATIVEXCOMPONENT_MOUSE_MOVE:
+        break;
+    }
+}
+
+void QOpenHarmonyXComponent::dispatchHoverEvent(OH_NativeXComponent *component, bool isHover)
+{
+
+}
+
+void QOpenHarmonyXComponent::getSurfaceInfo(OH_NativeXComponent *component, EGLNativeWindowType window)
+{
+    m_nativeWindow = window;
+    uint64_t w;
+    uint64_t h;
+    int32_t ret = OH_NativeXComponent_GetXComponentSize(component, (void *)window, &w, &h);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+        LOGE("Get surface size failed");
+        return;
+    }
+
+    LOGI("Get surface size %{public}llu, %{public}llu", w, h);
+    updateGeometry(w, h);
+}
+
+void QOpenHarmonyXComponent::initXComponent(OH_NativeXComponent *component)
+{
+    if (m_nativeComponent != nullptr) {
+        m_touchEventCallback = new OH_NativeXComponent_Callback;
+        m_touchEventCallback->OnSurfaceCreated = &QOpenHarmonyXComponent::onSurfaceCreated;
+        m_touchEventCallback->OnSurfaceChanged = &QOpenHarmonyXComponent::onSurfaceChanged;
+        m_touchEventCallback->OnSurfaceDestroyed = &QOpenHarmonyXComponent::onSurfaceDestroyed;
+        m_touchEventCallback->DispatchTouchEvent = &QOpenHarmonyXComponent::dispatchTouchEvent;
+        int32_t ret = OH_NativeXComponent_RegisterCallback(component, m_touchEventCallback);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            LOGI("set surface touch callback failed");
+        }
+
+        m_mouseEventCallback = new OH_NativeXComponent_MouseEvent_Callback;
+        m_mouseEventCallback->DispatchMouseEvent = &QOpenHarmonyXComponent::dispatchMouseEvent;
+        m_mouseEventCallback->DispatchHoverEvent = &QOpenHarmonyXComponent::dispatchHoverEvent;
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            LOGI("set surface mouse callback failed");
+        }
+
+        ret = OH_NativeXComponent_RegisterKeyEventCallback(component, &QOpenHarmonyXComponent::dispatchKeyEvent);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+            LOGI("set surface keybord callback failed");
+    }
+}
+
+QImage QOpenHarmonyXComponent::image() const
+{
+    return m_egl->image();
+}
+
+void QOpenHarmonyXComponent::setGeometry(const QRect &rect)
+{
+    m_geometry = rect;
+    updateEglSurface();
+    if (m_window != nullptr)
+        m_window->setGeometry(m_geometry);
+}
+
+QRect QOpenHarmonyXComponent::geometry() const
+{
+    return m_geometry;
+}
+
+bool QOpenHarmonyXComponent::isInUse() const
+{
+    return m_isInUsed;
+}
+
+void QOpenHarmonyXComponent::setInUsed(bool inUse)
+{
+    m_isInUsed = inUse;
+}
+
+void QOpenHarmonyXComponent::setWindow(QOpenHarmonyPlatformWindow *window)
+{
+    m_window = window;
+}
+
+QString QOpenHarmonyXComponent::componentName() const
+{
+    return m_componentName;
+}
+
+void QOpenHarmonyXComponent::setComponentName(const QString &componentName)
+{
+    m_componentName = componentName;
+}
+
+OH_NativeXComponent *QOpenHarmonyXComponent::nativeComponent() const
+{
+    return m_nativeComponent;
+}
+
+bool QOpenHarmonyXComponent::createEglSurface()
+{
+    if (m_nativeWindow == 0)
+        return false;
+    m_egl->createSurface(m_nativeWindow, m_geometry.width(), m_geometry.height());
+    return true;
+}
+
+void QOpenHarmonyXComponent::updateEglSurface()
+{
+    m_egl->updateSurfaceSize(m_geometry.width(), m_geometry.height());
+}
+
+void QOpenHarmonyXComponent::updateGeometry(int w, int h)
+{
+    m_geometry.setWidth(w);
+    m_geometry.setHeight(h);
+    updateEglSurface();
+}
+
+EGLSurface QOpenHarmonyXComponent::eglSurface() const
+{
+    return m_egl->eglSurface();
+}
+
+void QOpenHarmonyXComponent::setNativeXComponent(OH_NativeXComponent *component)
+{
+    m_nativeComponent = component;
+    initXComponent(component);
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyxcomponent.h b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.h
new file mode 100644
index 0000000000..3771faa096
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.h
@@ -0,0 +1,80 @@
+#ifndef QOPENHARMONYXCOMPONENT_H
+#define QOPENHARMONYXCOMPONENT_H
+
+#include <QRect>
+#include <QImage>
+#include <QObject>
+#include <EGL/egl.h>
+#include <QScopedPointer>
+
+class QOpenHarmonyEGLCore;
+struct OH_NativeXComponent;
+class QOpenHarmonyPlatformWindow;
+struct OH_NativeXComponent_Callback;
+struct OH_NativeXComponent_MouseEvent_Callback;
+
+class QOpenHarmonyXComponent
+{
+public:
+    QOpenHarmonyXComponent(OH_NativeXComponent *component = nullptr);
+    virtual ~QOpenHarmonyXComponent();
+
+    void paint(const QImage &image);
+
+    EGLSurface eglSurface() const;
+
+    void setNativeXComponent(OH_NativeXComponent *component);
+    OH_NativeXComponent *nativeComponent() const;
+
+    QString componentName() const;
+    void setComponentName(const QString &componentName);
+
+    QImage image() const;
+
+    void setGeometry(const QRect &rect);
+    QRect geometry() const;
+
+    bool isInUse() const;
+
+    void setInUsed(bool inUse);
+
+    void setWindow(QOpenHarmonyPlatformWindow *window);
+
+private:
+    bool createEglSurface();
+
+    void updateEglSurface();
+
+    void updateGeometry(int w, int h);
+
+    static void onSurfaceCreated(OH_NativeXComponent* component, void* window);
+
+    static void onSurfaceChanged(OH_NativeXComponent* component, void* window);
+
+    static void onSurfaceDestroyed(OH_NativeXComponent* component, void* window);
+
+    static void dispatchKeyEvent(OH_NativeXComponent *component, void *window);
+
+    static void dispatchTouchEvent(OH_NativeXComponent* component, void* window);
+
+    static void dispatchMouseEvent(OH_NativeXComponent* component, void* window);
+
+    static void dispatchHoverEvent(OH_NativeXComponent* component, bool isHover);
+
+private:
+    void getSurfaceInfo(OH_NativeXComponent* component, EGLNativeWindowType window);
+    void initXComponent(OH_NativeXComponent *component);
+private:
+    OH_NativeXComponent *m_nativeComponent = nullptr;
+    OH_NativeXComponent_Callback *m_touchEventCallback = nullptr;
+    OH_NativeXComponent_MouseEvent_Callback *m_mouseEventCallback = nullptr;
+    QString m_componentName;
+    EGLNativeWindowType m_nativeWindow;
+    QScopedPointer<QOpenHarmonyEGLCore> m_egl;
+    QOpenHarmonyPlatformWindow *m_window = nullptr;
+    QRect m_geometry;
+    bool m_visible = true;
+    bool m_surfaceCreated = false;
+    bool m_isInUsed = false;
+};
+#endif // QOPENHARMONYXCOMPONENT_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyxcomponentmanager.cpp b/src/plugins/platforms/openharmony/qopenharmonyxcomponentmanager.cpp
new file mode 100644
index 0000000000..289b63c270
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyxcomponentmanager.cpp
@@ -0,0 +1,229 @@
+#include "qopenharmonyxcomponentmanager.h"
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+
+#include <ace/xcomponent/native_interface_xcomponent.h>
+
+#include <QElapsedTimer>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QDebug>
+#include <QTimer>
+#include <QThread>
+
+
+Q_GLOBAL_STATIC(QOpenHarmonyXComponentManager, manager)
+
+QOpenHarmonyXComponentManager::QOpenHarmonyXComponentManager()
+{
+
+}
+
+QOpenHarmonyXComponentManager::~QOpenHarmonyXComponentManager()
+{
+    qDeleteAll(m_components);
+}
+
+static QString xCompnentName()
+{
+    static int index = 1;
+    QString name = QString("openharmony_window_%1").arg(index++);
+    return name;
+}
+
+QOpenHarmonyXComponent *QOpenHarmonyXComponentManager::getXComponent()
+{
+    QOpenHarmonyXComponent *xc = availableXComponent();
+    if (xc != nullptr)
+        return xc;
+    QString name = xCompnentName();
+    qDebug() << "create open harmony platfrom window for" << name;
+    m_xComponentCreated.storeRelease(false);
+    m_jsWindowManager = qJsObjectLoader->create("JsWindowManager");
+    if (m_jsWindowManager.isNull()) {
+        qWarning() << "create open harmony platfrom window failed";
+        return nullptr;
+    }
+    bool result = m_jsWindowManager->call<bool>("createWindow", name);
+    //  window has created, but the xcomponent maybe not, js will create xcomponent and callback
+    if (!result) {
+        qWarning() << "create open harmony platfrom window failed";
+        return nullptr;
+    }
+    if (wait())
+        qDebug() << "create open harmony platfrom window succeeded";
+    else {
+        qWarning() << "create open harmony platfrom window failed";
+        return nullptr;
+    }
+    xc = availableXComponent();
+    if (xc != nullptr)
+        return xc;
+    qWarning() << "create open harmony platfrom window failed";
+    return nullptr;
+}
+
+void QOpenHarmonyXComponentManager::releaseXComponent(QOpenHarmonyXComponent *component)
+{
+    if (component == nullptr)
+        return;
+    component->setInUsed(false);
+    //    m_jsWindowManager->call("destroyWindow", component->componentName());
+    //    delete component;
+    //   Todo to many component delete some
+}
+
+QOpenHarmonyXComponentManager *QOpenHarmonyXComponentManager::instance()
+{
+    return manager();
+}
+
+void QOpenHarmonyXComponentManager::add(QOpenHarmonyXComponent *component)
+{
+    if (component == nullptr || m_components.contains(component))
+        return;
+    m_components << component;
+}
+
+QOpenHarmonyXComponent *QOpenHarmonyXComponentManager::xcomponent(OH_NativeXComponent *component) const
+{
+    return find([component](QOpenHarmonyXComponent *xc){
+        return xc->nativeComponent() == component;
+    });
+}
+
+QOpenHarmonyXComponent *QOpenHarmonyXComponentManager::xcomponent(const QString &name) const
+{
+    return find([name](QOpenHarmonyXComponent *xc){
+        return xc->componentName() == name;
+    });
+}
+
+void QOpenHarmonyXComponentManager::setNativeXComponent(const QString &name, void *component)
+{
+    QByteArray nameArray = name.toUtf8();
+    LOGI("set native xcomponent for: %{public}s", nameArray.constData());
+    QOpenHarmonyXComponent *xcomponent = createXComponent(name);
+    Q_ASSERT(xcomponent != nullptr);
+    xcomponent->setNativeXComponent(static_cast<OH_NativeXComponent *>(component));
+    m_xComponentCreated.storeRelease(true);
+}
+
+QOpenHarmonyXComponent *QOpenHarmonyXComponentManager::createXComponent(const QString &name)
+{
+    QOpenHarmonyXComponent *xcomponent = new QOpenHarmonyXComponent;
+    xcomponent->setComponentName(name);
+    add(xcomponent);
+    return xcomponent;
+}
+
+QOpenHarmonyXComponent *QOpenHarmonyXComponentManager::availableXComponent()
+{
+    if (QtOpenHarmony::isPhone() && !m_components.isEmpty())
+        return m_components.first();
+    QOpenHarmonyXComponent *result = find([](QOpenHarmonyXComponent *xc){
+        return !xc->isInUse();
+    });
+    if (result != nullptr)
+        result->setInUsed(true);
+    return result;
+}
+
+QOpenHarmonyXComponent *QOpenHarmonyXComponentManager::find(std::function<bool (QOpenHarmonyXComponent *)> function) const
+{
+    auto it = std::find_if(m_components.constBegin(), m_components.constEnd(), function);
+    return it == m_components.constEnd() ? nullptr : *it;
+}
+
+bool QOpenHarmonyXComponentManager::wait(int timeout)
+{
+    QElapsedTimer start;
+    start.start();
+    while (!m_xComponentCreated.loadAcquire()) {
+        QThread::sleep(0);
+        if (start.elapsed() > timeout)
+            return false;
+    }
+    return true;
+}
+
+static napi_value handleJsGeometryChange(napi_env env, napi_callback_info info)
+{
+    size_t argc = 5;
+    napi_value args[5];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 5) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    QString name = qJs::getString(args[0]);
+    int left = qJs::getInt32(args[1]);
+    int top = qJs::getInt32(args[2]);
+    int w = qJs::getInt32(args[3]);
+    int h = qJs::getInt32(args[4]);
+    QOpenHarmonyXComponentManager::instance()->handleGeometryChange(name, QRect(left, top, w, h));
+    return nullptr;
+}
+
+void QOpenHarmonyXComponentManager::init(napi_env env, napi_value exports)
+{
+    LOGI("888888888888888888888888888888888888");
+    static bool inited = false;
+    if (!inited) {
+        inited = true;
+        napi_property_descriptor desc[] ={
+            DECLARE_NAPI_FUNCTION("handleGeometryChange", handleJsGeometryChange),
+        };
+        napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
+    }
+    napi_value exportInstance = nullptr;
+    OH_NativeXComponent *nativeXComponent = nullptr;
+    int32_t ret;
+    char idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = { };
+    uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;
+
+    NAPI_CALL_RETURN_VOID_NO_THROW(env, napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance));
+    NAPI_CALL_RETURN_VOID_NO_THROW(env, napi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent)));
+
+    ret = OH_NativeXComponent_GetXComponentId(nativeXComponent, idStr, &idSize);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+        return;
+    }
+    LOGI("get xcomponent succeded %{public}s", idStr);
+
+    QOpenHarmonyXComponentManager::instance()->setNativeXComponent(QString::fromUtf8(idStr), nativeXComponent);
+}
+
+void QOpenHarmonyXComponentManager::handleGeometryChange(const QString &name, const QRect &rect)
+{
+    QOpenHarmonyXComponent *xc = xcomponent(name);
+    if (xc == nullptr)
+        return;
+    xc->setGeometry(rect);
+
+}
+
+void QOpenHarmonyXComponentManager::setVisible(QOpenHarmonyXComponent *component, bool visible)
+{
+    if (component == nullptr)
+        return;
+    if (m_jsWindowManager.isNull())
+        m_jsWindowManager = qJsObjectLoader->create("JsWindowManager");
+    m_jsWindowManager->call<bool>("setVisible", component->componentName(), visible);
+}
+
+void QOpenHarmonyXComponentManager::setGeometry(QOpenHarmonyXComponent *component, const QRect &rect)
+{
+    if (component == nullptr)
+        return;
+    component->setGeometry(rect);
+    if (m_jsWindowManager.isNull())
+        m_jsWindowManager = qJsObjectLoader->create("JsWindowManager");
+    m_jsWindowManager->call<bool>("setGeometry", component->componentName(), rect.left(), rect.top(), rect.width(), rect.height());
+}
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyxcomponentmanager.h b/src/plugins/platforms/openharmony/qopenharmonyxcomponentmanager.h
new file mode 100644
index 0000000000..9241884061
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyxcomponentmanager.h
@@ -0,0 +1,55 @@
+#ifndef QOPENHARMONYXCOMPONENTMANAGER_H
+#define QOPENHARMONYXCOMPONENTMANAGER_H
+
+#include <QList>
+#include <QHash>
+#include <QSharedPointer>
+#include <QMutex>
+#include <QWaitCondition>
+#include <napi/native_api.h>
+
+class QOpenHarmonyXComponent;
+class QOpenHarmonyJsObject;
+struct OH_NativeXComponent;
+
+class QOpenHarmonyXComponentManager
+{
+public:
+    QOpenHarmonyXComponentManager();
+    virtual ~QOpenHarmonyXComponentManager();
+
+    QOpenHarmonyXComponent *getXComponent();
+
+    void releaseXComponent(QOpenHarmonyXComponent *component);
+
+    static QOpenHarmonyXComponentManager *instance();
+
+    void add(QOpenHarmonyXComponent *component);
+
+    void setVisible(QOpenHarmonyXComponent *component, bool visible);
+
+    void setGeometry(QOpenHarmonyXComponent *component, const QRect &rect);
+
+    QOpenHarmonyXComponent *xcomponent(OH_NativeXComponent *component) const;
+
+    QOpenHarmonyXComponent *xcomponent(const QString &name) const;
+
+    static void init(napi_env env, napi_value exports);
+
+    void handleGeometryChange(const QString &name, const QRect &rect);
+private slots:
+    void setNativeXComponent(const QString &name, void *component);
+private:
+    QOpenHarmonyXComponent *createXComponent(const QString &name);
+    QOpenHarmonyXComponent *availableXComponent();
+    QOpenHarmonyXComponent *find(std::function<bool(QOpenHarmonyXComponent *)> function) const;
+    bool wait(int timeout = 2000);
+private:
+    QList<QOpenHarmonyXComponent *> m_components;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsWindowManager;
+    QMutex m_mutex;
+    QWaitCondition m_waitCondition;
+    QBasicAtomicInt m_xComponentCreated;
+};
+
+#endif // QOPENHARMONYXCOMPONENTMANAGER_H
diff --git a/src/plugins/platforms/platforms.pro b/src/plugins/platforms/platforms.pro
index 23f838a7fe..f13ef8b9cd 100644
--- a/src/plugins/platforms/platforms.pro
+++ b/src/plugins/platforms/platforms.pro
@@ -7,6 +7,12 @@ android:!android-embedded: SUBDIRS += android
 
 !wasm:!android:qtConfig(freetype): SUBDIRS += offscreen
 
+openharmony: SUBDIRS += openharmony
+
+!android:!openharmony: SUBDIRS += minimal
+
+!android:!openharmony:qtConfig(freetype): SUBDIRS += offscreen
+
 qtConfig(xcb) {
     SUBDIRS += xcb
 }
diff --git a/src/src.pro b/src/src.pro
index 8990109743..ffa3ca0dcc 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -152,6 +152,8 @@ src_plugins.target = sub-plugins
 
 src_android.subdir = $$PWD/android
 
+src_openharmony.subdir = $$PWD/openharmony
+
 # this order is important
 !qtConfig(system-zlib)|cross_compile {
     SUBDIRS += src_qtzlib
@@ -250,6 +252,8 @@ nacl: SUBDIRS -= src_network src_testlib
 
 android:!android-embedded: SUBDIRS += src_android src_3rdparty_gradle
 
+openharmony: SUBDIRS += src_openharmony
+
 qtConfig(private_tests) {
      qtConfig(network):qtConfig(gui) {
         src_network_doc_snippets.subdir = network/doc/snippets
diff --git a/src/testlib/qplaintestlogger.cpp b/src/testlib/qplaintestlogger.cpp
index 851a284678..2154f97ba7 100644
--- a/src/testlib/qplaintestlogger.cpp
+++ b/src/testlib/qplaintestlogger.cpp
@@ -66,6 +66,10 @@
 #  include <android/log.h>
 #endif
 
+#ifdef Q_OS_OPENHARMONY
+#include <QDebug>
+#endif
+
 #ifdef Q_OS_WIN
 #  include <qt_windows.h>
 #endif
@@ -221,6 +225,9 @@ void QPlainTestLogger::outputMessage(const char *str)
     }
 #elif defined(Q_OS_ANDROID)
     __android_log_write(ANDROID_LOG_INFO, "QTestLib", str);
+#elif defined(Q_OS_OPENHARMONY)
+        /* wanghao TODO */
+        qInfo() << str;
 #endif
     outputString(str);
 }
diff --git a/src/testlib/qtestlog.cpp b/src/testlib/qtestlog.cpp
index 8917f0dc0e..7042f00f2d 100644
--- a/src/testlib/qtestlog.cpp
+++ b/src/testlib/qtestlog.cpp
@@ -420,8 +420,10 @@ void QTestLog::startLogging()
     elapsedTotalTime.start();
     elapsedFunctionTime.start();
     FOREACH_TEST_LOGGER
-        logger->startLogging();
+            logger->startLogging();
+#ifndef Q_OS_OPENHARMONY
     QTest::oldMessageHandler = qInstallMessageHandler(QTest::messageHandler);
+#endif
 }
 
 void QTestLog::stopLogging()
diff --git a/src/widgets/dialogs/qfiledialog.cpp b/src/widgets/dialogs/qfiledialog.cpp
index 711effefe2..03ced89c4c 100644
--- a/src/widgets/dialogs/qfiledialog.cpp
+++ b/src/widgets/dialogs/qfiledialog.cpp
@@ -2218,10 +2218,18 @@ QString QFileDialog::getOpenFileName(QWidget *parent,
     const QStringList schemes = QStringList(QStringLiteral("file"));
     const QUrl selectedUrl = getOpenFileUrl(parent, caption, QUrl::fromLocalFile(dir), filter,
                                             selectedFilter, options, schemes);
+#ifdef Q_OS_OPENHARMONY
+    QString fileName = selectedUrl.toLocalFile();
+    if (!fileName.isEmpty()) {
+        fileName.prepend("datashare://");
+    }
+    return fileName;
+#else
     if (selectedUrl.isLocalFile() || selectedUrl.isEmpty())
         return selectedUrl.toLocalFile();
     else
         return selectedUrl.toString();
+#endif
 }
 
 /*!
@@ -2581,10 +2589,18 @@ QString QFileDialog::getSaveFileName(QWidget *parent,
     const QStringList schemes = QStringList(QStringLiteral("file"));
     const QUrl selectedUrl = getSaveFileUrl(parent, caption, QUrl::fromLocalFile(dir), filter,
                                             selectedFilter, options, schemes);
+#ifdef Q_OS_OPENHARMONY
+    QString fileName = selectedUrl.toLocalFile();
+    if (!fileName.isEmpty()) {
+        fileName.prepend("datashare://");
+    }
+    return fileName;
+#else
     if (selectedUrl.isLocalFile() || selectedUrl.isEmpty())
         return selectedUrl.toLocalFile();
     else
         return selectedUrl.toString();
+#endif
 }
 
 /*!
diff --git a/src/widgets/widgets/qtextbrowser.cpp b/src/widgets/widgets/qtextbrowser.cpp
index 122a8529e8..138a6a5b4e 100644
--- a/src/widgets/widgets/qtextbrowser.cpp
+++ b/src/widgets/widgets/qtextbrowser.cpp
@@ -177,6 +177,11 @@ QString QTextBrowserPrivate::findFile(const QUrl &name) const
         if (name.scheme() == QLatin1String("assets"))
             fileName = QLatin1String("assets:") + name.path();
         else
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            if (name.scheme() == QLatin1String("rawfile"))
+                fileName = QLatin1String("rawfile:") + name.path();
+            else
 #endif
             fileName = name.toLocalFile();
     }
@@ -247,6 +252,9 @@ void QTextBrowserPrivate::_q_activateAnchor(const QString &href)
             url.scheme() == QLatin1String("file")
 #if defined(Q_OS_ANDROID)
             || url.scheme() == QLatin1String("assets")
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            || url.scheme() == QLatin1String("rawfile")
 #endif
             || url.scheme() == QLatin1String("qrc");
     if ((openExternalLinks && !isFileScheme && !url.isRelative())
diff --git a/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp b/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp
index 2e2209ac5d..b6b872fc24 100644
--- a/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp
+++ b/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp
@@ -368,7 +368,7 @@ protected:
             const QByteArray name = "Bar" + QByteArray::number(i) + postFix;
             const char *nm = name.constData();
             int tp = qRegisterMetaType<Bar>(nm);
-#if defined(Q_OS_LINUX) && !defined(Q_OS_ANDROID)
+#if defined(Q_OS_LINUX) && !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
             sched_yield();
 #endif
             QMetaType info(tp);
diff --git a/tests/auto/corelib/text/qlocale/tst_qlocale.cpp b/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
index 84901f8f75..282150e327 100644
--- a/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
+++ b/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
@@ -46,7 +46,7 @@
 #include <private/qlocale_tools_p.h>
 #include <qnumeric.h>
 
-#if defined(Q_OS_LINUX) && !defined(__UCLIBC__)
+#if defined(Q_OS_LINUX) && !defined(__UCLIBC__) && !defined(Q_OS_OPENHARMONY)
 #    define QT_USE_FENV
 #endif
 
