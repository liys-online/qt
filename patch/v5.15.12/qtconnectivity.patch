diff --git a/src/bluetooth/bluetooth.pro b/src/bluetooth/bluetooth.pro
index b7f9a198..f1dd6777 100644
--- a/src/bluetooth/bluetooth.pro
+++ b/src/bluetooth/bluetooth.pro
@@ -157,6 +157,21 @@ qtConfig(bluez) {
 
     HEADERS += qlowenergycontroller_android_p.h \
                        qbluetoothsocket_android_p.h
+} else:openharmony {
+    include(openharmony/openharmony.pri)
+    DEFINES += QT_OPENHARMONY_BLUETOOTH
+
+    SOURCES += \
+               qbluetoothserver_ohos.cpp \
+               qbluetoothsocket_ohos.cpp \
+               qbluetoothlocaldevice_ohos.cpp \
+               qbluetoothserviceinfo_ohos.cpp \
+               qlowenergycontroller_ohos.cpp \
+               qbluetoothdevicediscoveryagent_ohos.cpp \
+               qbluetoothservicediscoveryagent_ohos.cpp
+
+    HEADERS += qbluetoothsocket_ohos_p.h \
+                       qlowenergycontroller_ohos_p.h
 } else:osx {
     QT_PRIVATE = concurrent
     DEFINES += QT_OSX_BLUETOOTH
diff --git a/src/bluetooth/openharmony/bluetoothdatareceiver.cpp b/src/bluetooth/openharmony/bluetoothdatareceiver.cpp
new file mode 100644
index 00000000..f900e52d
--- /dev/null
+++ b/src/bluetooth/openharmony/bluetoothdatareceiver.cpp
@@ -0,0 +1,55 @@
+#include <QtCore/QLoggingCategory>
+
+#include "openharmony/bluetoothdatareceiver_p.h"
+#include "qbluetoothsocket_ohos_p.h"
+#include "qopenharmonydefines.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+BluetoothDataReceiver::BluetoothDataReceiver(QBluetoothSocketPrivateOpenHarmony *socket)
+    : QObject(), m_socket_p(socket)
+{
+}
+
+bool BluetoothDataReceiver::start()
+{
+    QMutexLocker lock(&m_mutex);
+
+    return m_socket_p->start();
+}
+
+qint64 BluetoothDataReceiver::bytesAvailable() const
+{
+    QMutexLocker locker(&m_mutex);
+    return m_socket_p->buffer.size();
+}
+
+bool BluetoothDataReceiver::canReadLine() const
+{
+    QMutexLocker locker(&m_mutex);
+    return m_socket_p->buffer.canReadLine();
+}
+
+qint64 BluetoothDataReceiver::readData(char *data, qint64 maxSize)
+{
+    QMutexLocker locker(&m_mutex);
+
+    if (!m_socket_p->buffer.isEmpty())
+        return m_socket_p->buffer.read(data, maxSize);
+
+    return 0;
+}
+
+//inside the js thread
+void BluetoothDataReceiver::jsReadyRead(const QByteArray &data)
+{
+    QMutexLocker lock(&m_mutex);
+    int bufferLength = data.length();
+    char *writePtr = m_socket_p->buffer.reserve(bufferLength);
+    memcpy(writePtr, data.constData(), bufferLength);
+    emit dataAvailable();
+}
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/openharmony/bluetoothdatareceiver_p.h b/src/bluetooth/openharmony/bluetoothdatareceiver_p.h
new file mode 100644
index 00000000..a290148c
--- /dev/null
+++ b/src/bluetooth/openharmony/bluetoothdatareceiver_p.h
@@ -0,0 +1,34 @@
+#ifndef BLUETOOTHDATARECEIVER_P_H
+#define BLUETOOTHDATARECEIVER_P_H
+
+
+#include <QtCore/QObject>
+#include <QtCore/QMutex>
+QT_BEGIN_NAMESPACE
+
+class QBluetoothSocketPrivateOpenHarmony;
+
+class BluetoothDataReceiver : public QObject
+{
+    Q_OBJECT
+public:
+    explicit BluetoothDataReceiver(QBluetoothSocketPrivateOpenHarmony *socket_p);
+
+    qint64 bytesAvailable() const;
+    bool canReadLine() const;
+    bool start();
+
+    qint64 readData(char *data, qint64 maxSize);
+    void jsReadyRead(const QByteArray &buffer);
+
+signals:
+    void dataAvailable();
+
+private:
+    QBluetoothSocketPrivateOpenHarmony *m_socket_p;
+    mutable QMutex m_mutex;
+};
+
+QT_END_NAMESPACE
+
+#endif // BLUETOOTHDATARECEIVER_P_H
diff --git a/src/bluetooth/openharmony/jsclass/jsclass.pri b/src/bluetooth/openharmony/jsclass/jsclass.pri
new file mode 100644
index 00000000..d5045126
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/jsclass.pri
@@ -0,0 +1,17 @@
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/qjsaccess.h \
+    $$PWD/qjsble.h \
+    $$PWD/qjsconnect.h \
+    $$PWD/qjsdevice.h \
+    $$PWD/qjssocket.h \
+
+
+SOURCES += \
+    $$PWD/qjsaccess.cpp \
+    $$PWD/qjsble.cpp \
+    $$PWD/qjsconnect.cpp \
+    $$PWD/qjsdevice.cpp \
+    $$PWD/qjssocket.cpp \
+
diff --git a/src/bluetooth/openharmony/jsclass/qjsaccess.cpp b/src/bluetooth/openharmony/jsclass/qjsaccess.cpp
new file mode 100644
index 00000000..ff0eb480
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsaccess.cpp
@@ -0,0 +1,40 @@
+#include "qjsaccess.h"
+#include <private/qopenharmony_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QJsAccess::QJsAccess()
+    :QJsModule("@ohos.bluetooth.access")
+{
+}
+
+QJsAccess::~QJsAccess()
+{
+}
+
+QJsAccess::BluetoothState QJsAccess::getState()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        Napi::Value result = call("getState");
+        return (QJsAccess::BluetoothState)result.ToNumber().Int32Value();
+    });
+}
+
+void QJsAccess::enableBluetooth()
+{
+    QtOh::runOnJsUIThreadNoWait([this](){
+        call("enableBluetooth");
+    });
+}
+
+bool QJsAccess::disableBluetooth()
+{
+    //todo：暂时屏蔽执行openharmony单元测试
+//    QtOh::runOnJsUIThreadNoWait([this](){
+//        call("disableBluetooth");
+//    });
+    return true;
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/openharmony/jsclass/qjsaccess.h b/src/bluetooth/openharmony/jsclass/qjsaccess.h
new file mode 100644
index 00000000..91e04d58
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsaccess.h
@@ -0,0 +1,31 @@
+#ifndef QJSACCESS_H
+#define QJSACCESS_H
+
+#include <QJsModule>
+
+QT_BEGIN_NAMESPACE
+
+class QJsAccess : public QJsModule
+{
+public:
+    enum BluetoothState
+    {
+        STATE_OFF,
+        STATE_TURNING_ON,
+        STATE_ON,
+        STATE_TURNING_OFF,
+        STATE_BLE_TURNING_ON,
+        STATE_BLE_ON,
+        STATE_BLE_TURNING_OFF,
+    };
+
+    QJsAccess();
+    ~QJsAccess();
+
+    BluetoothState getState();
+    void enableBluetooth();
+    bool disableBluetooth();
+};
+
+QT_END_NAMESPACE
+#endif // QJSACCESS_H
diff --git a/src/bluetooth/openharmony/jsclass/qjsble.cpp b/src/bluetooth/openharmony/jsclass/qjsble.cpp
new file mode 100644
index 00000000..f05e0ac2
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsble.cpp
@@ -0,0 +1,360 @@
+#include "qjsble.h"
+#include "openharmonybluetoothdiscoveryreceiver_p.h"
+
+#include <private/qjspromise_p.h>
+#include <private/qopenharmony_p.h>
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+
+
+QList<QJsGattServer *> QJsBle::m_GattServes;
+QList<QJsGattClientDevice *> QJsBle::m_clientDevices;
+
+
+QJsGattServer::QJsGattServer(Napi::Object jsObject)
+    :QJsObject(jsObject)
+{
+    m_jsConnect = QSharedPointer<QJsConnect>::create();
+}
+
+void QJsGattServer::addDevice(QString deviceId)
+{
+    m_devices.insert(deviceId);
+    m_deviceId = deviceId;
+}
+
+QJsGattServer::~QJsGattServer()
+{
+}
+
+bool QJsGattServer::addService(Napi::Object gattService)
+{
+    bool result = true;
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        call("addService", {gattService});
+    });
+    return result;
+}
+
+QString QJsGattServer::removeService(){
+
+}
+
+void QJsGattServer::close(){
+    QtOh::runOnJsUIThreadNoWait([this](){
+        call("close");
+    });
+}
+
+void QJsGattServer::notifyCharacteristicChanged(Napi::Object notifyChar)
+{
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        for(const QString &device : m_devices){
+            auto res = call("notifyCharacteristicChanged", {Napi::String::New(env(), device.toStdString()), notifyChar});
+            QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+            promise.onThen([&](const Napi::CallbackInfo &info){
+                       qWarning() << "QJsGattServer notifyCharacteristicChanged success";
+                   }).onCatch([](const Napi::CallbackInfo &info){
+                        int code = info[0].ToObject().Get("code").ToNumber();
+                        qWarning() << "QJsGattServer notifyCharacteristicChanged failed：" << code;
+                    });
+        }
+    });
+}
+
+QString QJsGattServer::remoteName()
+{
+    if(m_deviceId.isEmpty())
+        return QString();
+    return m_jsConnect->remoteDeviceName(m_deviceId);
+}
+
+QString QJsGattServer::remoteAddress()
+{
+    return m_deviceId;
+}
+
+QJsGattClientDevice::QJsGattClientDevice(Napi::Object jsObject)
+    :QJsObject(jsObject)
+{
+}
+
+QJsGattClientDevice::~QJsGattClientDevice()
+{
+}
+
+bool QJsGattClientDevice::connect(){
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        call("connect");
+    });
+    return true;
+}
+
+void QJsGattClientDevice::disconnect(){
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        call("disconnect");
+    });
+}
+
+void QJsGattClientDevice::close(){
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        call("close");
+    });
+}
+
+bool QJsGattClientDevice::getServices(QString *uuid)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("getServices");
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&,p](const Napi::CallbackInfo &info){
+                   if(info[0].IsArray()){
+                       Napi::Array gattServices = info[0].As<Napi::Array>();
+                       QStringList strList;
+                       for (uint32_t i = 0; i < gattServices.Length(); ++i) {
+                           Napi::Value val = gattServices.Get(i);
+                           if(val.IsObject()){
+                               strList << QString::fromStdString(val.As<Napi::Object>().
+                                                                 Get("serviceUuid").ToString());
+                           }
+                       }
+                       QString strs = strList.join(" ");
+                       *uuid = strs;
+                       p->set_value(true);
+                   }
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice getServices failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+bool QJsGattClientDevice::discoverServiceDetails(Napi::Array &detailsInfo)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("getServices");
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&,p](const Napi::CallbackInfo &info){
+                   if(info[0].IsArray()){
+                       p->set_value(true);
+                       detailsInfo = info[0].As<Napi::Array>();
+                   }
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice discoverServiceDetails failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+bool QJsGattClientDevice::readCharacteristicValue(const Napi::Object &characteristic, Napi::Object &outputCharacteristic)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("readCharacteristicValue", {characteristic});
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&,p](const Napi::CallbackInfo &info){
+                   if(info[0].IsObject()){
+                       p->set_value(true);
+                       outputCharacteristic = info[0].As<Napi::Object>();
+                   }
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice writeCharacteristicValue failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+bool QJsGattClientDevice::readDescriptorValue(const Napi::Object &descriptor, Napi::Object &outputDescriptor)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("readDescriptorValue", {descriptor});
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&,p](const Napi::CallbackInfo &info){
+                   if(info[0].IsObject()){
+                       p->set_value(true);
+                       outputDescriptor = info[0].As<Napi::Object>();
+                   }
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice readDescriptorValue failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+bool QJsGattClientDevice::writeCharacteristicValue(Napi::Object &characteristic, int writeType)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("writeCharacteristicValue", {characteristic, Napi::Number::New(env(), writeType)});
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([p](const Napi::CallbackInfo &info){
+                   p->set_value(true);
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice writeCharacteristicValue failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+bool QJsGattClientDevice::writeDescriptorValue(Napi::Object &descriptor)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("writeDescriptorValue", {descriptor});
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([p](const Napi::CallbackInfo &info){
+                   p->set_value(true);
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice writeDescriptorValue failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+QString QJsGattClientDevice::includedServices(const QString &targetUuid)
+{
+    QString result;
+    result = QtOh::runOnJsUIThreadWithPromise<QString>([&, this](auto p){
+        auto res = call("getServices");
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&,p](const Napi::CallbackInfo &info){
+                   if(info[0].IsArray()){
+                       Napi::Array gattServices = info[0].As<Napi::Array>();
+                       QStringList strList;
+                       for (uint32_t i = 0; i < gattServices.Length(); ++i) {
+                           Napi::Object gattService = gattServices.Get(i).As<Napi::Object>();
+                           QString uuid = QString::fromStdString(gattService.Get("serviceUuid").ToString());
+                           if(targetUuid == uuid){
+                               Napi::Array includeServices = gattService.Get("includeServices").As<Napi::Array>();
+                               for(uint32_t j = 0; j < includeServices.Length(); ++j){
+                                   Napi::Object includeGattService = includeServices.Get(j).As<Napi::Object>();
+                                   strList << QString::fromStdString(includeGattService.Get("serviceUuid").ToString());
+                               }
+                               break;
+                           }
+                       }
+                       QString strs = strList.join(" ");
+                       p->set_value(strs);
+                   }
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "GattClientDevice includedServices failed：" << code;
+                    p->set_value(QString());
+                });
+    });
+    return result;
+}
+
+
+QJsBle::QJsBle()
+    :QJsModule("@ohos.bluetooth.ble")
+{
+}
+
+
+QJsBle::~QJsBle()
+{
+}
+
+bool QJsBle::startAdvertising(Napi::Object advertisingParams, int &advertisingId)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        auto res = call("startAdvertising", {advertisingParams});
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&, p](const Napi::CallbackInfo &info){
+                   advertisingId = info[0].ToNumber();
+                   p->set_value(true);
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "QJsBle startAdvertising failed：" << code;
+                    p->set_value(false);
+                });
+    });
+    return result;
+}
+
+bool QJsBle::startBLEScan()
+{
+    QtOh::runOnJsUIThreadNoWait([this](){
+        Napi::Function callback = Napi::Function::New(env(), [&](const Napi::CallbackInfo& info) {
+            Napi::Array scanResultArr = info[0].As<Napi::Array>();
+            auto discoveryReceiver = OpenHarmonyBluetoothDiscoveryReceiver::ohDiscoveryReceiver();
+            for(int i = 0; i < scanResultArr.Length(); i++){
+                Napi::Object scanResult = scanResultArr.Get(i).ToObject();
+                QMetaObject::invokeMethod(discoveryReceiver, "received", Qt::QueuedConnection,
+                                          Q_ARG(bool, true),
+                                          Q_ARG(QString,  QString::fromStdString(scanResult.Get("deviceId").ToString())));
+            }
+        });
+
+        call("on", {Napi::String::New(env(), "BLEDeviceFind"), callback});
+        Napi::Object scanOptions = Napi::Object::New(env());
+        scanOptions.Set("interval", Napi::Number::New(env(), 500));
+        call("startBLEScan", {env().Null(), scanOptions});
+    });
+    return true;
+}
+
+bool QJsBle::stopBLEScan()
+{
+    QtOh::runOnJsUIThreadNoWait([this](){
+        call("off", {Napi::String::New(env(), "BLEDeviceFind")});
+        call("stopBLEScan");
+    });
+    return true;
+}
+
+void QJsBle::stopAdvertising(int advertisingId)
+{
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        auto res = call("stopAdvertising", {Napi::Number::New(env(), advertisingId)});
+        QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+        promise.onThen([&](const Napi::CallbackInfo &info){
+               }).onCatch([&](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "QJsBle stopAdvertising failed：" << code;
+                });
+    });
+}
+
+QJsGattServer *QJsBle::createGattServer()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        Napi::Value result = call("createGattServer");
+        QJsGattServer *gattServer = result.IsObject() ? new QJsGattServer(result.As<Napi::Object>()) : nullptr;
+        if(gattServer)
+            m_GattServes << gattServer;
+        return gattServer;
+    });
+}
+
+QJsGattClientDevice *QJsBle::createGattClientDevice(QString deviceId)
+{
+    return QtOh::runOnJsUIThreadWithResult([&, this](){
+        Napi::Value result = call("createGattClientDevice", {Napi::String::New(env(), deviceId.toStdString())});
+        QJsGattClientDevice *gattClientDevice = result.IsObject() ? new QJsGattClientDevice(result.As<Napi::Object>()) : nullptr;
+        if(gattClientDevice)
+            m_clientDevices << gattClientDevice;
+        return gattClientDevice;
+    });
+}
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/openharmony/jsclass/qjsble.h b/src/bluetooth/openharmony/jsclass/qjsble.h
new file mode 100644
index 00000000..90ff4ba6
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsble.h
@@ -0,0 +1,86 @@
+#ifndef QJSBLE_H
+#define QJSBLE_H
+
+#include <QJsModule>
+#include <QSharedPointer>
+#include <QSet>
+#include <functional>
+
+#include "qjsconnect.h"
+
+
+QT_BEGIN_NAMESPACE
+
+
+
+class QJsGattServer : public QJsObject{
+public:
+    QJsGattServer(Napi::Object jsObject);
+    ~QJsGattServer();
+
+    void addDevice(QString deviceId);
+    bool addService(Napi::Object gattService);
+    QString removeService();
+    void close();
+
+    void notifyCharacteristicChanged(Napi::Object notifyChar);
+
+    QString remoteName();
+    QString remoteAddress();
+
+
+
+private:
+    QSet<QString> m_devices;
+    //最近连接的设备
+    QString m_deviceId;
+    QSharedPointer<QJsConnect> m_jsConnect;
+};
+
+
+class QJsGattClientDevice : public QJsObject{
+public:
+    QJsGattClientDevice(Napi::Object jsObject);
+    ~QJsGattClientDevice();
+
+    bool connect();
+    void disconnect();
+    void close();
+
+    bool getServices(QString *uuid);
+    bool discoverServiceDetails(Napi::Array &detailsInfo);
+
+    bool readCharacteristicValue(const Napi::Object &characteristic, Napi::Object &outputCharacteristic);
+    bool readDescriptorValue(const Napi::Object &descriptor, Napi::Object &outputDescriptor);
+
+    bool writeCharacteristicValue(Napi::Object &characteristic, int writeType);
+    bool writeDescriptorValue(Napi::Object &descriptor);
+
+    QString includedServices(const QString &targetUuid);
+};
+
+
+class QJsBle : public QJsModule
+{
+public:
+    QJsBle();
+    ~QJsBle();
+
+    QJsGattServer *createGattServer();
+    QJsGattClientDevice *createGattClientDevice(QString deviceId);
+    bool startAdvertising(Napi::Object advertisingParams, int &advertisingId);
+    void stopAdvertising(const int advertisingId);
+
+    bool startBLEScan();
+    bool stopBLEScan();
+
+private:
+    static QList<QJsGattServer *> m_GattServes;
+    static QList<QJsGattClientDevice *> m_clientDevices;
+};
+
+
+
+QT_END_NAMESPACE
+
+#endif // QJSBLE_H
diff --git a/src/bluetooth/openharmony/jsclass/qjsconnect.cpp b/src/bluetooth/openharmony/jsclass/qjsconnect.cpp
new file mode 100644
index 00000000..5f11c4b6
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsconnect.cpp
@@ -0,0 +1,129 @@
+#include "qjsconnect.h"
+#include "openharmonybluetoothdiscoveryreceiver_p.h"
+
+#include <QDebug>
+#include <private/qjspromise_p.h>
+#include <private/qopenharmony_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QJsConnect::QJsConnect()
+    :QJsModule("@ohos.bluetooth.connection")
+{
+
+}
+
+QJsConnect::~QJsConnect()
+{
+
+}
+
+QString QJsConnect::localName()
+{
+    qWarning() << Q_FUNC_INFO << this;
+    return QtOh::runOnJsUIThreadWithResult([this]() {
+        qWarning() << "QJsConnect::localName()" << this;
+        if (!this) {
+            return QString();
+        } else {
+            return QString::fromStdString(call("getLocalName").ToString());
+        }
+    });
+}
+
+QString QJsConnect::remoteDeviceName(const QString &deviceId)
+{
+    return QtOh::runOnJsUIThreadWithResult([&, this](){
+        return QString::fromStdString(call("getRemoteDeviceName",
+                                           {Napi::String::New(env(), deviceId.toStdString())}).ToString());
+    });
+}
+
+int QJsConnect::remoteClassOfDevice(const QString &deviceId)
+{
+    return QtOh::runOnJsUIThreadWithResult([&, this](){
+        Napi::Object deviceClass = call("getRemoteDeviceClass",
+                                        {Napi::String::New(env(), deviceId.toStdString())}).As<Napi::Object>();
+        return deviceClass.Get("classOfDevice").ToNumber().Int32Value();
+    });
+}
+
+bool QJsConnect::startBluetoothDiscovery()
+{
+    QtOh::runOnJsUIThreadNoWait([this](){
+        Napi::Function callback = Napi::Function::New(env(), [&](const Napi::CallbackInfo& info) {
+            Napi::Array devicesFinded = info[0].As<Napi::Array>();
+            auto discoveryReceiver = OpenHarmonyBluetoothDiscoveryReceiver::ohDiscoveryReceiver();
+            for(int i = 0; i < devicesFinded.Length(); i++){
+                QMetaObject::invokeMethod(discoveryReceiver, "received", Qt::QueuedConnection,
+                                          Q_ARG(bool, false), Q_ARG(QString,  QString::fromStdString(devicesFinded.Get(i).ToString())));
+            }
+        });
+
+        call("on", {Napi::String::New(env(), "bluetoothDeviceFind"), callback});
+        call("startBluetoothDiscovery");
+    });
+    return true;
+}
+
+bool QJsConnect::stopBluetoothDiscovery()
+{
+    QtOh::runOnJsUIThreadNoWait([this](){
+        call("off", {Napi::String::New(env(), "bluetoothDeviceFind")});
+        call("stopBluetoothDiscovery");
+    });
+    return true;
+}
+
+void QJsConnect::setBluetoothScanMode(int scanMode, int duration)
+{
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        call("setBluetoothScanMode", {Napi::Number::New(env(), scanMode), Napi::Number::New(env(), duration)});
+    });
+}
+
+int QJsConnect::getBluetoothScanMode()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        return call("getBluetoothScanMode").ToNumber().Int32Value();
+    });
+}
+
+bool QJsConnect::pairDevice(QString deviceId, bool isPairing)
+{
+    bool result = false;
+    result = QtOh::runOnJsUIThreadWithPromise<bool>([&, this](auto p){
+        if(isPairing){
+            auto res = call("pairDevice", {Napi::String::New(env(), deviceId.toStdString())});
+            QJsPromise promise = QJsPromise(res.As<Napi::Promise>());
+            promise.onThen([p](const Napi::CallbackInfo &info){
+                       p->set_value(true);
+                   }).onCatch([p](const Napi::CallbackInfo &info){
+                        int code = info[0].ToObject().Get("code").ToNumber();
+                        qWarning() << "QJsConnect pairDevice failed：" << code;
+                        p->set_value(false);
+                    });
+        }else{
+            /*没有cancelpairDevice接口*/
+            p->set_value(false);
+        }
+    });
+    return result;
+}
+
+QStringList QJsConnect::getPairedDevices()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        Napi::Value res = call("getBluetoothScanMode");
+        QStringList result;
+        if(res.IsArray()){
+            Napi::Array pairedDevices = res.As<Napi::Array>();
+            for(int i = 0; i < pairedDevices.Length(); ++i){
+                result << QString::fromStdString(pairedDevices.Get(i).ToString());
+            }
+        }
+        return result;
+    });
+}
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/openharmony/jsclass/qjsconnect.h b/src/bluetooth/openharmony/jsclass/qjsconnect.h
new file mode 100644
index 00000000..3acb675d
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsconnect.h
@@ -0,0 +1,35 @@
+#ifndef QJSCONNECT_H
+#define QJSCONNECT_H
+
+#include <QJsModule>
+
+QT_BEGIN_NAMESPACE
+
+class QJsConnect : public QJsModule
+{
+public:
+    QJsConnect();
+    ~QJsConnect();
+
+    QString localName();
+    QString remoteDeviceName(const QString &deviceId);
+    int remoteClassOfDevice(const QString &deviceId);
+
+    bool startBluetoothDiscovery();
+    bool stopBluetoothDiscovery();
+
+    void setBluetoothScanMode(int scanMode, int duration);
+    int getBluetoothScanMode();
+
+    bool pairDevice(QString deviceId, bool isPairing);
+
+    QStringList getPairedDevices();
+
+
+
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QJSCONNECT_H
diff --git a/src/bluetooth/openharmony/jsclass/qjsdevice.cpp b/src/bluetooth/openharmony/jsclass/qjsdevice.cpp
new file mode 100644
index 00000000..4120f35b
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsdevice.cpp
@@ -0,0 +1,8 @@
+#include "qjsdevice.h"
+
+QT_BEGIN_NAMESPACE
+
+QJsDevice::QJsDevice() { }
+
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/openharmony/jsclass/qjsdevice.h b/src/bluetooth/openharmony/jsclass/qjsdevice.h
new file mode 100644
index 00000000..0dff185b
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjsdevice.h
@@ -0,0 +1,22 @@
+#ifndef QJSDEVICE_H
+#define QJSDEVICE_H
+
+#include <QJsObject>
+
+QT_BEGIN_NAMESPACE
+
+class QJsDevice : public QJsObject
+{
+public:
+    QJsDevice();
+
+private:
+    QString deviceId;
+
+
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QJSDEVICE_H
diff --git a/src/bluetooth/openharmony/jsclass/qjssocket.cpp b/src/bluetooth/openharmony/jsclass/qjssocket.cpp
new file mode 100644
index 00000000..70764eca
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjssocket.cpp
@@ -0,0 +1,225 @@
+#include "qjssocket.h"
+
+#include "serveracceptancethread_p.h"
+#include <private/qopenharmony_p.h>
+#include <QPointer>
+
+#include <QDebug>
+
+
+QT_BEGIN_NAMESPACE
+
+QJsSocket::QJsSocket()
+    : QJsModule("@ohos.bluetooth.socket")
+{
+}
+
+QJsSocket::~QJsSocket()
+{
+    serverAlive = false;
+}
+
+QString QJsSocket::localAddress()
+{
+    if(m_clientSocket == -1)
+        return QString();
+
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        Napi::Value result = call("getDeviceId", {Napi::Number::New(env(), m_clientSocket)});
+        return QString::fromStdString(result.ToString());
+    });
+}
+
+bool QJsSocket::listen(QString uuid, QString serviceName, bool isSecure)
+{
+    bool result = false;
+    QtOh::runOnJsUIThreadAndWait([=, &result, jsScoket = QPointer<QJsSocket>(this)]{
+        Napi::Object sppOptions = Napi::Object::New(env());
+        sppOptions.Set("uuid", uuid.toStdString());
+        sppOptions.Set("secure", isSecure);
+        sppOptions.Set("type", 0);
+
+        if(jsScoket.isNull())
+            return;
+
+        Napi::Function ListenCallback = Napi::Function::New(jsScoket->env(), [&, jsScoket](const Napi::CallbackInfo& info) {
+            if (info.Length() < 2) {
+                qWarning() << "sppListen failed, error unkonwn";
+                return;
+            }
+            
+            if (!info[0].IsNull()) {
+                Napi::Object error = info[0].As<Napi::Object>();
+                int code = (int)error.Get("code").ToNumber();
+                if (code != 0) {
+                    qWarning() << "sppListen failed" << code << error.Get("message").ToString();
+                    return;
+                }
+            }
+       
+            qWarning() << "sppListen res socketId" << info[1].ToNumber().Int32Value();
+            m_ServerSocket = info[1].ToNumber();
+            serverAlive = true;
+            
+            if(jsScoket.isNull())
+                return;
+            
+            Napi::Function acceptCallback = Napi::Function::New(jsScoket->env(), [&](const Napi::CallbackInfo& info) {
+                if (info.Length() < 2) {
+                    qWarning() << "sppAccept failed, error unkonwn";
+                    return;
+                }
+
+                if (!info[0].IsNull()) {
+                    Napi::Object error = info[0].As<Napi::Object>();
+                    int code = (int)error.Get("code").ToNumber();
+                    if (code != 0){
+                        qWarning() << "sppAccept failed" << code << error.Get("message").ToString();
+                        return;
+                    }
+                }
+
+                qWarning() << "sppAccept res socketId" << info[1].ToNumber().Int32Value();
+                m_clientSocket = info[1].ToNumber();
+                result = true;
+
+                auto serverAcceptanceThread = ServerAcceptanceThread::theServerAcceptanceThread();
+                QMetaObject::invokeMethod(serverAcceptanceThread, "jsNewSocket", Qt::QueuedConnection, Q_ARG(int32_t, m_clientSocket));
+            });
+
+            call("sppAccept", {Napi::Number::New(jsScoket->env(), m_ServerSocket), acceptCallback});
+        });
+
+        call("sppListen", {Napi::String::New(jsScoket->env(), serviceName.toStdString()), sppOptions, ListenCallback});
+    });
+
+    return result;
+}
+
+bool QJsSocket::connect(QString deviceId, QString uuid, bool secure, int sppType)
+{
+    bool result = false;
+
+    QtOh::runOnJsUIThreadAndWait([=, &result, this]{
+        Napi::Object sppOptions = Napi::Object::New(env());
+        sppOptions.Set("uuid", uuid.toStdString());
+        sppOptions.Set("secure", secure);
+        sppOptions.Set("type", sppType);
+
+        Napi::Function callback = Napi::Function::New(env(), [&](const Napi::CallbackInfo& info) {
+            if (info.Length() < 2) {
+                qWarning() << "sppConnect failed, error unkonwn";
+            }
+
+            if (!info[0].IsNull()) {
+                Napi::Object error = info[0].As<Napi::Object>();
+                int code = (int)error.Get("code").ToNumber();
+                if (code != 0){
+                    qWarning() << "sppConnect failed" << code << error.Get("message").ToString();
+                    return;
+                }
+            }
+
+            result = true;
+            qWarning() << "sppConnect res socketId" << info[1].ToNumber().Int32Value();
+            m_clientSocket = info[1].ToNumber();
+        });
+
+        call("sppConnect", {Napi::String::New(env(), deviceId.toStdString()), sppOptions, callback});
+        this->m_remoteDeviceId = deviceId;
+    });
+
+    return result;
+}
+
+bool QJsSocket::read(std::function<void (QByteArray)> &func)
+{
+    if(m_clientSocket == -1)
+        return false;
+
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        Napi::Function callback = Napi::Function::New(env(), [&](const Napi::CallbackInfo& info) {
+            if (info.Length() < 2) {
+                qWarning() << "sppRead failed, error unkonwn";
+                return;
+            }
+
+            if (!info[0].IsNull()) {
+                Napi::Object error = info[0].As<Napi::Object>();
+                int code = (int)error.Get("code").ToNumber();
+                if (code != 0){
+                    qWarning() << "sppRead failed" << code << error.Get("message").ToString();
+                    return;
+                }
+            }
+
+            auto receiveData = info[1];
+            if(receiveData.IsArrayBuffer()){
+                Napi::ArrayBuffer arrayBuffer = receiveData.As<Napi::ArrayBuffer>();
+                char *data = (char *)arrayBuffer.Data();
+                size_t bufferSize = arrayBuffer.ByteLength();
+                func(QByteArray(data, bufferSize));
+            }
+        });
+
+        call("on", {Napi::String::New(env(), "sppRead"),
+                     Napi::Number::New(env(), m_clientSocket), callback});
+    });
+
+    return true;
+}
+
+bool QJsSocket::write(QByteArray data)
+{
+    if(m_clientSocket == -1)
+        return false;
+
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        int size = data.length();
+        Napi::ArrayBuffer arrayBuffer = Napi::ArrayBuffer::New(env(), size);
+        char *jsData = (char *)arrayBuffer.Data();
+        size_t bufferSize = arrayBuffer.ByteLength();
+        if(bufferSize < (size_t)size){
+            qWarning() << "QJsSocket::write create arrayBuffer error";
+            return false;
+        }
+        memcpy(jsData, data.constData(), size);
+        call("sppWrite", {Napi::Number::New(env(), m_clientSocket), arrayBuffer});
+    });
+
+    return true;
+}
+
+bool QJsSocket::closeClient(int clientSocket)
+{
+    int theSocket;
+
+    if(clientSocket > 0){
+        theSocket = clientSocket;
+    }else{
+        theSocket = m_clientSocket;
+    }
+
+    if(theSocket != -1 && theSocket != 0){
+        QtOh::runOnJsUIThreadNoWait([&, this](){
+            call("sppCloseClientSocket", {Napi::Number::New(env(), theSocket)});
+        });
+    }
+    return true;
+}
+
+bool QJsSocket::closeServer()
+{
+    if(m_clientSocket != -1){
+        serverAlive = false;
+        QtOh::runOnJsUIThreadNoWait([this](){
+            call("sppCloseServerSocket", {Napi::Number::New(env(), m_clientSocket)});
+        });
+    }
+
+    return true;
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qjssocket.cpp"
diff --git a/src/bluetooth/openharmony/jsclass/qjssocket.h b/src/bluetooth/openharmony/jsclass/qjssocket.h
new file mode 100644
index 00000000..b2105af6
--- /dev/null
+++ b/src/bluetooth/openharmony/jsclass/qjssocket.h
@@ -0,0 +1,39 @@
+#ifndef QJSSOCKET_H
+#define QJSSOCKET_H
+
+#include <QJsModule>
+#include <QObject>
+#include <functional>
+
+QT_BEGIN_NAMESPACE
+
+class QJsSocket : public QObject, public QJsModule
+{
+    Q_OBJECT
+
+public:
+    QJsSocket();
+    ~QJsSocket();
+
+    bool serverIsAlive(){return serverAlive;}
+
+    QString localAddress();
+    QString remoteAddress(){return m_remoteDeviceId;}
+
+    bool listen(QString uuid, QString serviceName, bool isSecure);
+    bool connect(QString deviceId, QString uuid, bool secure, int sppType);
+    bool read(std::function<void (QByteArray)> &func);
+    bool write(QByteArray data);
+    bool closeClient(int clientSocket = -1);
+    bool closeServer();
+
+
+private:
+    int m_clientSocket = -1;
+    int m_ServerSocket = -1;
+    QString m_remoteDeviceId;
+    bool serverAlive;
+};
+
+QT_END_NAMESPACE
+#endif // QJSSOCKET_H
diff --git a/src/bluetooth/openharmony/lowenergynotificationhub.cpp b/src/bluetooth/openharmony/lowenergynotificationhub.cpp
new file mode 100644
index 00000000..9212f639
--- /dev/null
+++ b/src/bluetooth/openharmony/lowenergynotificationhub.cpp
@@ -0,0 +1,337 @@
+#include "lowenergynotificationhub_p.h"
+
+#include <QtCore/qopenharmonydefines.h>
+
+QT_BEGIN_NAMESPACE
+
+QSharedPointer<QJsBle> LowEnergyNotificationHub::m_jsBluetoothLe;
+
+LowEnergyNotificationHub::LowEnergyNotificationHub(const QBluetoothAddress &remote,
+                                                   bool isPeripheral, QObject *parent)
+    : QObject(parent)
+{
+    if(!m_jsBluetoothLe)
+        m_jsBluetoothLe = QSharedPointer<QJsBle>::create();
+
+    if (isPeripheral) {
+        m_jsGattServer = QSharedPointer<QJsGattServer>(m_jsBluetoothLe->createGattServer());
+    } else {
+        m_jsGattClientDevice = QSharedPointer<QJsGattClientDevice>(m_jsBluetoothLe->createGattClientDevice(remote.toString()));
+    }
+}
+
+LowEnergyNotificationHub::~LowEnergyNotificationHub()
+{
+}
+
+// // runs in Js thread
+// static napi_value lowEnergy_connectionChanged(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 3;
+//     napi_value args[3];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 3) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_connectionChange");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     int errorCode = qJs::getInt32(args[1]);
+//     int newState = qJs::getInt32(args[2]);
+
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QMetaObject::invokeMethod(hub, "connectionUpdated", Qt::QueuedConnection,
+//                               Q_ARG(QLowEnergyController::ControllerState,
+//                                     (QLowEnergyController::ControllerState)newState),
+//                               Q_ARG(QLowEnergyController::Error,
+//                                     (QLowEnergyController::Error)errorCode));
+//     return nullptr;
+// }
+
+// static void lowEnergy_servicesDiscovered
+
+
+// static napi_value lowEnergy_servicesDiscovered(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 3;
+//     napi_value args[3];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 3) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_connectionChange");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     QString uuids = qJs::getString(args[1]);
+//     int errorCode = qJs::getInt32(args[2]);
+
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QMetaObject::invokeMethod(hub, "servicesDiscovered", Qt::QueuedConnection,
+//                               Q_ARG(QLowEnergyController::Error,
+//                                     (QLowEnergyController::Error)errorCode),
+//                               Q_ARG(QString, uuids));
+//     return nullptr;
+// }
+
+// static napi_value lowEnergy_characteristicRead(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 6;
+//     napi_value args[6];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 6) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_characteristicRead");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     QBluetoothUuid serviceUuid = QBluetoothUuid(qJs::getString(args[1]));
+//     int handle = qJs::getInt32(args[2]);
+//     QBluetoothUuid charUuid = QBluetoothUuid(qJs::getString(args[3]));
+//     int properties = qJs::getInt32(args[4]);
+//     QByteArray payload = qJs::getByteArray(args[5]);
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QMetaObject::invokeMethod(hub, "characteristicRead", Qt::QueuedConnection,
+//                               Q_ARG(QBluetoothUuid, serviceUuid),
+//                               Q_ARG(int, handle),
+//                               Q_ARG(QBluetoothUuid, charUuid),
+//                               Q_ARG(int, properties),
+//                               Q_ARG(QByteArray, payload));
+//     return nullptr;
+
+// }
+
+// static napi_value lowEnergy_descriptorRead(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 6;
+//     napi_value args[6];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 6) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_descriptorRead");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     QBluetoothUuid serviceUuid = QBluetoothUuid(qJs::getString(args[1]));
+//     QBluetoothUuid charUuid = QBluetoothUuid(qJs::getString(args[2]));
+//     QBluetoothUuid descUuid = QBluetoothUuid(qJs::getString(args[3]));
+//     int handle = qJs::getInt32(args[4]);
+//     QByteArray payload = qJs::getByteArray(args[5]);
+
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+
+//     QMetaObject::invokeMethod(hub, "descriptorRead", Qt::QueuedConnection,
+//                               Q_ARG(QBluetoothUuid, serviceUuid),
+//                               Q_ARG(QBluetoothUuid, charUuid),
+//                               Q_ARG(int, handle),
+//                               Q_ARG(QBluetoothUuid, descUuid),
+//                               Q_ARG(QByteArray, payload));
+// }
+
+// static napi_value lowEnergy_serverDescriptorWritten(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 5;
+//     napi_value args[5];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 5) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_serverDescriptorWritten");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     QBluetoothUuid serviceUuid = QBluetoothUuid(qJs::getString(args[1]));
+//     QBluetoothUuid charUuid = QBluetoothUuid(qJs::getString(args[2]));
+//     QBluetoothUuid descUuid = QBluetoothUuid(qJs::getString(args[3]));
+//     QByteArray payload = qJs::getByteArray(args[4]);
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QMetaObject::invokeMethod(hub, "serverDescriptorWritten", Qt::QueuedConnection,
+//                               Q_ARG(QBluetoothUuid, serviceUuid),
+//                               Q_ARG(QBluetoothUuid, charUuid),
+//                               Q_ARG(QBluetoothUuid, descUuid),
+//                               Q_ARG(QByteArray, payload));
+// }
+
+// static napi_value characteristicChanged(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 3;
+//     napi_value args[3];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 3) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in characteristicChanged");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     int charHandle = qJs::getInt32(args[1]);
+//     QByteArray payload = qJs::getByteArray(args[2]);
+
+
+//     QMetaObject::invokeMethod(hub, "characteristicChanged", Qt::QueuedConnection,
+//                               Q_ARG(int, charHandle), Q_ARG(QByteArray, payload));
+// }
+
+// static napi_value lowEnergy_serverCharacteristicChanged(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 4;
+//     napi_value args[4];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 4) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in characteristicChanged");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QBluetoothUuid serviceUuid = QBluetoothUuid(qJs::getString(args[1]));
+//     QBluetoothUuid charUuid = QBluetoothUuid(qJs::getString(args[2]));
+//     QByteArray payload = qJs::getByteArray(args[3]);
+
+//     QMetaObject::invokeMethod(hub, "serverCharacteristicChanged", Qt::QueuedConnection,
+//                               Q_ARG(QBluetoothUuid, serviceUuid),
+//                               Q_ARG(QBluetoothUuid, charUuid),
+//                               Q_ARG(QByteArray, payload));
+// }
+
+// static napi_value lowEnergy_serviceDetailDiscoveryFinished(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 4;
+//     napi_value args[4];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 4) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in characteristicChanged");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QString serviceUuid = qJs::getString(args[1]);
+//     int startHandle = qJs::getInt32(args[2]);
+//     int endHandle = qJs::getInt32(args[3]);
+
+//     QMetaObject::invokeMethod(hub, "serviceDetailsDiscoveryFinished",
+//                               Qt::QueuedConnection,
+//                               Q_ARG(QString, serviceUuid),
+//                               Q_ARG(int, startHandle),
+//                               Q_ARG(int, endHandle));
+// }
+
+// static napi_value lowEnergy_serviceError(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 3;
+//     napi_value args[3];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 3) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_serviceError");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     int attributeHandle = qJs::getInt32(args[1]);
+//     int errorCode = qJs::getInt32(args[2]);
+
+//     QMetaObject::invokeMethod(hub, "serviceError", Qt::QueuedConnection,
+//                               Q_ARG(int, attributeHandle),
+//                               Q_ARG(QLowEnergyService::ServiceError,
+//                                     (QLowEnergyService::ServiceError)errorCode));
+// }
+
+
+// static napi_value lowEnergy_advertisementError(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 2;
+//     napi_value args[2];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 2) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in lowEnergy_advertisementError");
+//         return nullptr;
+//     }
+
+//     int qtObject = qJs::getInt32(args[0]);
+//     lock.lockForRead();
+//     LowEnergyNotificationHub *hub = hubMap()->value(qtObject);
+//     lock.unlock();
+//     if (!hub)
+//         return nullptr;
+
+//     QString errorString = qJs::getString(args[1]);
+
+//     QMetaObject::invokeMethod(hub, "advertisementError", Qt::QueuedConnection,
+//                               Q_ARG(QString, errorString));
+// }
+
+// napi_value LowEnergyNotificationHub::init(napi_env env, napi_value exports)
+// {
+//     napi_property_descriptor desc[] ={
+//         DECLARE_NAPI_FUNCTION("connectionChanged", lowEnergy_connectionChanged),
+//         DECLARE_NAPI_FUNCTION("servicesDiscovered", lowEnergy_servicesDiscovered),
+//         DECLARE_NAPI_FUNCTION("characteristicRead", lowEnergy_characteristicRead),
+//         DECLARE_NAPI_FUNCTION("descriptorRead", lowEnergy_descriptorRead),
+//         DECLARE_NAPI_FUNCTION("serverCharacteristicChanged", lowEnergy_serverCharacteristicChanged),
+//         DECLARE_NAPI_FUNCTION("serverDescriptorWritten", lowEnergy_serverDescriptorWritten),
+//         DECLARE_NAPI_FUNCTION("advertisementError", lowEnergy_advertisementError),
+//         DECLARE_NAPI_FUNCTION("serviceDetailDiscoveryFinished", lowEnergy_serviceDetailDiscoveryFinished),
+//         DECLARE_NAPI_FUNCTION("serviceError", lowEnergy_serviceError)
+//     };
+//     NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+//     return nullptr;
+// }
+
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/openharmony/lowenergynotificationhub_p.h b/src/bluetooth/openharmony/lowenergynotificationhub_p.h
new file mode 100644
index 00000000..b5e679e0
--- /dev/null
+++ b/src/bluetooth/openharmony/lowenergynotificationhub_p.h
@@ -0,0 +1,66 @@
+#ifndef LOWENERGYNOTIFICATIONHUB_H
+#define LOWENERGYNOTIFICATIONHUB_H
+
+#include <QtCore/QObject>
+#include <QtCore/QSharedPointer>
+#include <QtBluetooth/QBluetoothAddress>
+#include <QtBluetooth/QLowEnergyController>
+#include <QtBluetooth/QLowEnergyService>
+
+#include "qjsble.h"
+
+#include <QtBluetooth/QLowEnergyCharacteristic>
+
+QT_BEGIN_NAMESPACE
+class LowEnergyNotificationHub : public QObject
+{
+    Q_OBJECT
+public:
+    explicit LowEnergyNotificationHub(const QBluetoothAddress &remote, bool isPeripheral,
+                                      QObject *parent = nullptr);
+    ~LowEnergyNotificationHub();
+
+    QSharedPointer<QJsBle> jsBleObject() const
+    {
+        return m_jsBluetoothLe;
+    }
+    QSharedPointer<QJsGattServer> jsGattServer() const
+    {
+        return m_jsGattServer;
+    }
+    QSharedPointer<QJsGattClientDevice> jsGattClientDevice() const
+    {
+        return m_jsGattClientDevice;
+    }
+
+signals:
+    void connectionUpdated(QLowEnergyController::ControllerState newState,
+            QLowEnergyController::Error errorCode);
+    void servicesDiscovered(QLowEnergyController::Error errorCode, const QString &uuids);
+    void serviceDetailsDiscoveryFinished(const QString& serviceUuid,
+            int startHandle, int endHandle);
+    void characteristicRead(const QBluetoothUuid &serviceUuid,
+            int handle, const QBluetoothUuid &charUuid,
+            int properties, const QByteArray &data);
+    void descriptorRead(const QBluetoothUuid &serviceUuid, const QBluetoothUuid &charUuid,
+            int handle, const QBluetoothUuid &descUuid, const QByteArray &data);
+    void characteristicWritten(int charHandle, const QByteArray &data,
+                               QLowEnergyService::ServiceError errorCode);
+    void descriptorWritten(int descHandle, const QByteArray &data,
+                           QLowEnergyService::ServiceError errorCode);
+    void serverDescriptorWritten(const QBluetoothUuid &serviceUuid, const QBluetoothUuid &characteristicUuid, const QBluetoothUuid &descriptorUuid, const QByteArray &newValue);
+    void characteristicChanged(int charHandle, const QByteArray &data);
+    void serverCharacteristicChanged(const QBluetoothUuid &serviceUuid, const QBluetoothUuid &charUuid, const QByteArray &newValue);
+    void serviceError(int attributeHandle, QLowEnergyService::ServiceError errorCode);
+    void advertisementError(const QString &errorString);
+
+private:
+    static QSharedPointer<QJsBle> m_jsBluetoothLe;
+    QSharedPointer<QJsGattServer> m_jsGattServer;
+    QSharedPointer<QJsGattClientDevice> m_jsGattClientDevice;
+};
+
+QT_END_NAMESPACE
+
+#endif // LOWENERGYNOTIFICATIONHUB_H
+
diff --git a/src/bluetooth/openharmony/openharmony.pri b/src/bluetooth/openharmony/openharmony.pri
new file mode 100644
index 00000000..eb8a0325
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmony.pri
@@ -0,0 +1,24 @@
+INCLUDEPATH += $$PWD
+
+HEADERS +=  \
+        $$PWD/openharmonyload_p.h \
+        $$PWD/bluetoothdatareceiver_p.h \
+        $$PWD/serveracceptancethread_p.h \
+        $$PWD/openharmonybroadcastreceiver_p.h \
+        $$PWD/openharmonyservicediscoveryreceiver_p.h \
+        $$PWD/openharmonybluetoothdiscoveryreceiver_p.h \
+        $$PWD/openharmonylocaldevicebroadcastreceiver_p.h \
+        $$PWD/lowenergynotificationhub_p.h
+
+SOURCES += \
+        $$PWD/openharmonyload.cpp \
+        $$PWD/bluetoothdatareceiver.cpp \
+        $$PWD/serveracceptancethread.cpp \
+        $$PWD/openharmonybroadcastreceiver.cpp \
+        $$PWD/openharmonyservicediscoveryreceiver.cpp \
+        $$PWD/openharmonybluetoothdiscoveryreceiver.cpp \
+        $$PWD/openharmonylocaldevicebroadcastreceiver.cpp \
+        $$PWD/lowenergynotificationhub.cpp
+
+
+include(jsclass/jsclass.pri)
diff --git a/src/bluetooth/openharmony/openharmonybluetoothdiscoveryreceiver.cpp b/src/bluetooth/openharmony/openharmonybluetoothdiscoveryreceiver.cpp
new file mode 100644
index 00000000..3f83c0d4
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonybluetoothdiscoveryreceiver.cpp
@@ -0,0 +1,64 @@
+#include "openharmonybluetoothdiscoveryreceiver_p.h"
+#include "qopenharmonydefines.h"
+#include <QRunnable>
+#include <QBluetoothAddress>
+#include <QBluetoothDeviceInfo>
+#include <QDebug>
+
+static OpenHarmonyBluetoothDiscoveryReceiver *receiver = nullptr;
+
+OpenHarmonyBluetoothDiscoveryReceiver::OpenHarmonyBluetoothDiscoveryReceiver()
+{
+    receiver = this;
+    m_thread = new ParseThread;
+}
+
+OpenHarmonyBluetoothDiscoveryReceiver::~OpenHarmonyBluetoothDiscoveryReceiver()
+{
+    receiver = nullptr;
+}
+
+OpenHarmonyBluetoothDiscoveryReceiver *OpenHarmonyBluetoothDiscoveryReceiver::ohDiscoveryReceiver()
+{
+    return receiver;
+}
+
+void OpenHarmonyBluetoothDiscoveryReceiver::received(bool isBle, const QString &target)
+{
+    m_targets.append({isBle, target});
+    if (!m_thread->isRunning())
+        m_thread->start();
+}
+
+void ParseThread::run()
+{
+    if(!m_jsConnect){
+        m_jsConnect = QSharedPointer<QJsConnect>::create();
+    }
+    while (true) {
+        if(!receiver)
+            break;
+        QString target;
+        bool isBle;
+        if (!receiver->m_targets.isEmpty()){
+            auto deviceInfo = receiver->m_targets.takeFirst();
+            target = deviceInfo.deviceId;
+            isBle = deviceInfo.isble;
+        }
+
+        if (!target.isEmpty()) {
+            int classOfDevice = m_jsConnect->remoteClassOfDevice(target);
+            QString name = m_jsConnect->remoteDeviceName(target);
+            QBluetoothDeviceInfo info(QBluetoothAddress(target), name, classOfDevice);
+            emit receiver->deviceDiscovered(info, isBle);
+        } else {
+            QThread::sleep(1);
+            static int index = 0;
+            index++;
+            if (index > 10) {
+                index = 0;
+                break;
+            }
+        }
+    }
+}
diff --git a/src/bluetooth/openharmony/openharmonybluetoothdiscoveryreceiver_p.h b/src/bluetooth/openharmony/openharmonybluetoothdiscoveryreceiver_p.h
new file mode 100644
index 00000000..59b62730
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonybluetoothdiscoveryreceiver_p.h
@@ -0,0 +1,52 @@
+#ifndef OPENHARMONYBLUETOOTHDISCOVERYRECEIVER_P_H
+#define OPENHARMONYBLUETOOTHDISCOVERYRECEIVER_P_H
+
+#include <QObject>
+#include <QSharedPointer>
+#include <QMutex>
+#include <QThread>
+
+#include "qjsconnect.h"
+
+QT_BEGIN_NAMESPACE
+class QBluetoothDeviceInfo;
+
+struct deviceInfo
+{
+    bool isble;
+    QString deviceId;
+};
+
+class ParseThread : public QThread
+{
+    Q_OBJECT
+    virtual void run();
+
+    QSharedPointer<QJsConnect> m_jsConnect;
+};
+
+class OpenHarmonyBluetoothDiscoveryReceiver : public QObject
+{
+    Q_OBJECT
+    friend class ParseThread;
+public:
+    OpenHarmonyBluetoothDiscoveryReceiver();
+    ~OpenHarmonyBluetoothDiscoveryReceiver();
+
+    static OpenHarmonyBluetoothDiscoveryReceiver *ohDiscoveryReceiver();
+
+private slots:
+    void received(bool received, const QString &target);
+
+signals:
+    void deviceDiscovered(const QBluetoothDeviceInfo &info, bool isLeScanResult);
+    void finished();
+
+private:
+    QList<deviceInfo> m_targets;
+    QMutex m_mutex;
+    ParseThread *m_thread;
+};
+
+QT_END_NAMESPACE
+#endif // OPENHARMONYBLUETOOTHDISCOVERYRECEIVER_P_H
diff --git a/src/bluetooth/openharmony/openharmonybroadcastreceiver.cpp b/src/bluetooth/openharmony/openharmonybroadcastreceiver.cpp
new file mode 100644
index 00000000..659f2316
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonybroadcastreceiver.cpp
@@ -0,0 +1,49 @@
+#include <QMetaObject>
+#include <QJsonDocument>
+#include <QJsonParseError>
+
+#include "qopenharmonydefines.h"
+#include "openharmonybroadcastreceiver_p.h"
+
+// static napi_value servicesReceiver(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 1;
+//     napi_value args[1];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 1) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments in discoveryResult");
+//         return nullptr;
+//     }
+
+//     int64_t value0 = qJs::getInt64(args[0]);
+//     QByteArray value1 = qJs::getByteArray(args[1]);
+
+//     QJsonParseError err;
+//     QJsonDocument doc = QJsonDocument::fromJson(value1, &err);
+//     if (QJsonParseError::NoError != err.error)
+//         return nullptr;
+
+
+//     OPenHarmonyBroadcastReceiver *jsThread = reinterpret_cast<OPenHarmonyBroadcastReceiver *>(value0);
+//     if (jsThread != nullptr) {
+//         QMetaObject::invokeMethod(jsThread, "onReceive", Qt::QueuedConnection, Q_ARG(QJsonObject, doc.object()));
+//     }
+
+//     return nullptr;
+// }
+
+OPenHarmonyBroadcastReceiver::OPenHarmonyBroadcastReceiver(QObject *parent)
+    : QObject{parent}
+{
+
+}
+
+// napi_value OPenHarmonyBroadcastReceiver::init(napi_env env, napi_value exports)
+// {
+//     napi_property_descriptor desc[] ={
+//         DECLARE_NAPI_FUNCTION("servicesReceiver", servicesReceiver),
+//     };
+//     NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+//     return nullptr;
+// }
diff --git a/src/bluetooth/openharmony/openharmonybroadcastreceiver_p.h b/src/bluetooth/openharmony/openharmonybroadcastreceiver_p.h
new file mode 100644
index 00000000..494b2107
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonybroadcastreceiver_p.h
@@ -0,0 +1,20 @@
+
+#ifndef OPENHARMONYBROADCASTRECEIVER_P_H
+#define OPENHARMONYBROADCASTRECEIVER_P_H
+
+
+#include <QObject>
+#include <QJsonObject>
+
+class OPenHarmonyBroadcastReceiver : public QObject
+{
+    Q_OBJECT
+public:
+    explicit OPenHarmonyBroadcastReceiver(QObject *parent = nullptr);
+
+protected:
+    virtual void onReceive(const QJsonObject &json) = 0;
+    virtual void onReceiveLeScan(const QJsonObject &json) = 0;
+};
+
+#endif // OPENHARMONYBROADCASTRECEIVER_P_H
diff --git a/src/bluetooth/openharmony/openharmonyload.cpp b/src/bluetooth/openharmony/openharmonyload.cpp
new file mode 100644
index 00000000..44640777
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonyload.cpp
@@ -0,0 +1,47 @@
+// #include <napi/native_api.h>
+#include "qopenharmonydefines.h"
+#include "bluetoothdatareceiver_p.h"
+#include "serveracceptancethread_p.h"
+#include "openharmonybroadcastreceiver_p.h"
+#include "openharmonybluetoothdiscoveryreceiver_p.h"
+#include "lowenergynotificationhub_p.h"
+/*
+ * function for module exports
+ */
+// EXTERN_C_START
+// static napi_value Init(napi_env env, napi_value exports)
+// {
+//     static bool inited = false;
+//     if (!inited) {
+
+//         BluetoothDataReceiver::init(env, exports);
+//         ServerAcceptanceThread::init(env, exports);
+//         LowEnergyNotificationHub::init(env, exports);
+//         OPenHarmonyBroadcastReceiver::init(env, exports);
+//         OpenHarmonyBluetoothDiscoveryReceiver::init(env, exports);
+//         LOGI("init bluetooth module");
+//         inited = true;
+//     }
+//     return exports;
+// }
+// EXTERN_C_END
+
+// /*
+//  * Napi Module define
+//  */
+// static napi_module openharmonyQtBluetoothModule = {
+//     .nm_version = 1,
+//     .nm_flags = 0,
+//     .nm_filename = nullptr,
+//     .nm_register_func = Init,
+//     .nm_modname = "openharmony_qt_bluetooth",
+//     .nm_priv = ((void*)0),
+//     .reserved = { 0 },
+// };
+// /*
+//  * Module register function
+//  */
+// extern "C" __attribute__((constructor)) void RegisterModule(void)
+// {
+//     napi_module_register(&openharmonyQtBluetoothModule);
+// }
diff --git a/src/bluetooth/openharmony/openharmonyload_p.h b/src/bluetooth/openharmony/openharmonyload_p.h
new file mode 100644
index 00000000..ba9bbb47
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonyload_p.h
@@ -0,0 +1,5 @@
+#ifndef OPENHARMONYLOAD_P_H
+#define OPENHARMONYLOAD_P_H
+
+
+#endif // OPENHARMONYLOAD_P_H
diff --git a/src/bluetooth/openharmony/openharmonylocaldevicebroadcastreceiver.cpp b/src/bluetooth/openharmony/openharmonylocaldevicebroadcastreceiver.cpp
new file mode 100644
index 00000000..952e2be8
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonylocaldevicebroadcastreceiver.cpp
@@ -0,0 +1,45 @@
+#include <QtCore/QLoggingCategory>
+#include "openharmonylocaldevicebroadcastreceiver_p.h"
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_ANDROID)
+
+/* 扫描模式
+ *
+ * SCAN_MODE_NONE                               0	没有扫描模式
+ * SCAN_MODE_CONNECTABLE                        1	可连接扫描模式
+ * SCAN_MODE_GENERAL_DISCOVERABLE               2	general发现模式
+ * SCAN_MODE_LIMITED_DISCOVERABLE               3	limited发现模式
+ * SCAN_MODE_CONNECTABLE_GENERAL_DISCOVERABLE	4	可连接general发现模式
+ * SCAN_MODE_CONNECTABLE_LIMITED_DISCOVERABLE	5	可连接limited发现模式
+ */
+
+/* 配对状态
+ *
+ * BOND_STATE_INVALID	0	无效的配对
+ * BOND_STATE_BONDING	1	正在配对
+ * BOND_STATE_BONDED	2	已配对
+ */
+
+OPenHarmonyLocalDeviceBroadcastReceiver::OPenHarmonyLocalDeviceBroadcastReceiver(QObject *parent)
+    : OPenHarmonyBroadcastReceiver{parent}
+{
+    for (int i = 0; i < 6; ++i) {
+        hostModePreset[i] = i;
+        if (i <= 2)
+            bondingModePreset[i] = i;
+    }
+}
+
+void OPenHarmonyLocalDeviceBroadcastReceiver::onReceive(const QJsonObject &json)
+{
+    qCDebug(QT_BT_ANDROID) << QStringLiteral("LocalDeviceBroadcastReceiver::onReceive()");
+
+
+}
+
+bool OPenHarmonyLocalDeviceBroadcastReceiver::pairingConfirmation(bool accept)
+{
+    Q_UNUSED(accept);
+    return false;
+}
+
diff --git a/src/bluetooth/openharmony/openharmonylocaldevicebroadcastreceiver_p.h b/src/bluetooth/openharmony/openharmonylocaldevicebroadcastreceiver_p.h
new file mode 100644
index 00000000..aaae3db7
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonylocaldevicebroadcastreceiver_p.h
@@ -0,0 +1,34 @@
+#ifndef OPENHARMONYLOCALDEVICEBROADCASTRECEIVER_H
+#define OPENHARMONYLOCALDEVICEBROADCASTRECEIVER_H
+
+#include <QtBluetooth/QBluetoothAddress>
+#include <QtBluetooth/QBluetoothLocalDevice>
+
+#include "openharmonybroadcastreceiver_p.h"
+
+class OPenHarmonyLocalDeviceBroadcastReceiver : public OPenHarmonyBroadcastReceiver
+{
+    Q_OBJECT
+
+public:
+    explicit OPenHarmonyLocalDeviceBroadcastReceiver(QObject *parent = nullptr);
+    bool pairingConfirmation(bool accept);
+
+public Q_SLOTS:
+    void onReceive(const QJsonObject &json) override;
+    void onReceiveLeScan(const QJsonObject &json) override {}
+
+signals:
+    void hostModeStateChanged(QBluetoothLocalDevice::HostMode state);
+    void pairingStateChanged(const QBluetoothAddress &address, QBluetoothLocalDevice::Pairing pairing);
+    void connectDeviceChanges(const QBluetoothAddress &address, bool isConnectEvent);
+    void pairingDisplayConfirmation(const QBluetoothAddress &address, const QString& pin);
+    void pairingDisplayPinCode(const QBluetoothAddress &address, const QString& pin);
+
+private:
+    int previousScanMode;
+    int bondingModePreset[3];
+    int hostModePreset[6];
+};
+
+#endif // OPENHARMONYLOCALDEVICEBROADCASTRECEIVER_H
diff --git a/src/bluetooth/openharmony/openharmonyservicediscoveryreceiver.cpp b/src/bluetooth/openharmony/openharmonyservicediscoveryreceiver.cpp
new file mode 100644
index 00000000..d9cea954
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonyservicediscoveryreceiver.cpp
@@ -0,0 +1,20 @@
+#include <QDebug>
+#include "openharmonyservicediscoveryreceiver_p.h"
+
+OPenHarmonyServiceDiscoveryReceiver::OPenHarmonyServiceDiscoveryReceiver(QObject *parent)
+    : OPenHarmonyBroadcastReceiver(parent)
+{
+
+}
+
+void OPenHarmonyServiceDiscoveryReceiver::onReceive(const QJsonObject &json)
+{
+    qWarning() << "<<<<<<<<--------::" << json;
+}
+
+QList<QBluetoothUuid> OPenHarmonyServiceDiscoveryReceiver::convertParcelableArray(const QJsonObject &json)
+{
+    QList<QBluetoothUuid> result;
+    return result;
+}
+
diff --git a/src/bluetooth/openharmony/openharmonyservicediscoveryreceiver_p.h b/src/bluetooth/openharmony/openharmonyservicediscoveryreceiver_p.h
new file mode 100644
index 00000000..5ddd0e36
--- /dev/null
+++ b/src/bluetooth/openharmony/openharmonyservicediscoveryreceiver_p.h
@@ -0,0 +1,27 @@
+
+#ifndef OPENHARMONYSERVICEDISCOVERYRECEIVER_H
+#define OPENHARMONYSERVICEDISCOVERYRECEIVER_H
+
+
+#include <QtCore/QList>
+#include <QtBluetooth/QBluetoothUuid>
+#include <QtBluetooth/QBluetoothDeviceDiscoveryAgent>
+
+#include "openharmonybroadcastreceiver_p.h"
+
+class OPenHarmonyServiceDiscoveryReceiver : public OPenHarmonyBroadcastReceiver
+{
+    Q_OBJECT
+public:
+    OPenHarmonyServiceDiscoveryReceiver(QObject* parent = nullptr);
+    static QList<QBluetoothUuid> convertParcelableArray(const QJsonObject &json);
+
+public Q_SLOTS:
+    void onReceive(const QJsonObject &json) override;
+    void onReceiveLeScan(const QJsonObject &json) override {}
+
+signals:
+    void uuidFetchFinished(const QBluetoothAddress &addr, const QList<QBluetoothUuid> &serviceUuid);
+};
+
+#endif // OPENHARMONYSERVICEDISCOVERYRECEIVER_H
diff --git a/src/bluetooth/openharmony/serveracceptancethread.cpp b/src/bluetooth/openharmony/serveracceptancethread.cpp
new file mode 100644
index 00000000..b3e735c8
--- /dev/null
+++ b/src/bluetooth/openharmony/serveracceptancethread.cpp
@@ -0,0 +1,133 @@
+#include <QMetaObject>
+#include <QtCore/QLoggingCategory>
+#include "QtCore/qopenharmonydefines.h"
+#include "openharmony/serveracceptancethread_p.h"
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+static ServerAcceptanceThread* m_serverAcceptanceThread;
+
+ServerAcceptanceThread *ServerAcceptanceThread::theServerAcceptanceThread()
+{
+    return m_serverAcceptanceThread;
+}
+
+ServerAcceptanceThread::ServerAcceptanceThread(QObject *parent) :
+      QObject(parent), maxPendingConnections(1)
+{
+    // qRegisterMetaType<QBluetoothServer::Error>();
+    m_jsConnect = QSharedPointer<QJsConnect>::create();
+    m_jsSocket = QSharedPointer<QJsSocket>::create();
+    m_serverAcceptanceThread = this;
+}
+
+ServerAcceptanceThread::~ServerAcceptanceThread()
+{
+    if(!isRunning())
+       return;
+    QMutexLocker lock(&m_mutex);
+    shutdownPendingConnections();
+}
+
+void ServerAcceptanceThread::setServiceDetails(const QBluetoothUuid &uuid,
+                                               const QString &serviceName,
+                                               QBluetooth::SecurityFlags securityFlags)
+{
+    QMutexLocker lock(&m_mutex);
+    m_uuid = uuid;
+    m_serviceName = serviceName;
+    secFlags = securityFlags;
+}
+
+bool ServerAcceptanceThread::hasPendingConnections() const
+{
+    QMutexLocker lock(&m_mutex);
+    return (pendingSockets.count() > 0);
+}
+
+int ServerAcceptanceThread::nextPendingConnection()
+{
+    QMutexLocker lock(&m_mutex);
+    if (pendingSockets.isEmpty())
+        return -1;
+    else
+        return pendingSockets.takeFirst();
+}
+
+void ServerAcceptanceThread::setMaxPendingConnections(int maximumCount)
+{
+    QMutexLocker lock(&m_mutex);
+    maxPendingConnections = maximumCount;
+}
+
+void ServerAcceptanceThread::run()
+{
+    QMutexLocker lock(&m_mutex);
+
+    if (!validSetup()) {
+        qCWarning(QT_BT_OPENHARMONY) << "Invalid Server Socket setup";
+        return;
+    }
+
+    if (isRunning()) {
+        stop();
+        shutdownPendingConnections();
+    }
+
+    QString tempUuid = m_uuid.toString();
+    tempUuid.chop(1); //remove trailing '}'
+    tempUuid.remove(0,1); //remove first '{'
+
+    bool isSecure = !(secFlags == QBluetooth::NoSecurity);
+    bool listenRes = m_jsSocket->listen(tempUuid, m_serviceName, isSecure);
+    if(!listenRes)
+        jsThreadErrorOccurred(1);
+}
+
+void ServerAcceptanceThread::stop()
+{
+    qCDebug(QT_BT_OPENHARMONY) << "Closing server socket";
+    m_jsSocket->closeServer();
+}
+
+bool ServerAcceptanceThread::isRunning()
+{
+    if (m_jsSocket)
+        return m_jsSocket->serverIsAlive();
+
+    return false;
+}
+
+void ServerAcceptanceThread::jsThreadErrorOccurred(int errorCode)
+{
+    qCDebug(QT_BT_OPENHARMONY) << "jsThread error:" << errorCode;
+    emit error(QBluetoothServer::InputOutputError);
+}
+
+void ServerAcceptanceThread::jsNewSocket(int32_t s)
+{
+    QMutexLocker lock(&m_mutex);
+    if (-1 == s)
+        return;
+
+    if (pendingSockets.count() < maxPendingConnections) {
+        qCDebug(QT_BT_OPENHARMONY) << "New incoming js socket detected";
+        pendingSockets.append(s);
+        emit newConnection();
+    } else {
+        qCWarning(QT_BT_OPENHARMONY) << "Refusing connection due to limited pending socket queue";
+    }
+}
+
+bool ServerAcceptanceThread::validSetup() const
+{
+    return (!m_uuid.isNull() && !m_serviceName.isEmpty());
+}
+
+void ServerAcceptanceThread::shutdownPendingConnections()
+{
+    while (!pendingSockets.isEmpty()) {
+        int socket = pendingSockets.takeFirst();
+        m_jsSocket->closeClient(socket);
+    }
+}
diff --git a/src/bluetooth/openharmony/serveracceptancethread_p.h b/src/bluetooth/openharmony/serveracceptancethread_p.h
new file mode 100644
index 00000000..d140ce7e
--- /dev/null
+++ b/src/bluetooth/openharmony/serveracceptancethread_p.h
@@ -0,0 +1,53 @@
+#ifndef SERVERACCEPTANCETHREAD_P_H
+#define SERVERACCEPTANCETHREAD_P_H
+
+#include <QtCore/QMutex>
+#include <QtBluetooth/QBluetoothServer>
+#include <QtBluetooth/QBluetoothUuid>
+
+#include "qbluetooth.h"
+#include "qjssocket.h"
+#include "qjsconnect.h"
+
+class ServerAcceptanceThread : public QObject
+{
+    Q_OBJECT
+public:
+    explicit ServerAcceptanceThread(QObject *parent = nullptr);
+    ~ServerAcceptanceThread();
+
+    static ServerAcceptanceThread* theServerAcceptanceThread();
+    void setServiceDetails(const QBluetoothUuid &uuid, const QString &serviceName,
+                           QBluetooth::SecurityFlags securityFlags);
+
+    int nextPendingConnection();
+    bool hasPendingConnections() const;
+    void setMaxPendingConnections(int maximumCount);
+
+    Q_INVOKABLE void jsThreadErrorOccurred(int errorCode);
+    Q_INVOKABLE void jsNewSocket(int32_t socket);
+
+    void run();
+    void stop();
+    bool isRunning();
+
+signals:
+    void newConnection();
+    void error(QBluetoothServer::Error);
+
+private:
+    bool validSetup() const;
+    void shutdownPendingConnections();
+
+    QList<int> pendingSockets;
+    mutable QMutex m_mutex;
+    QString m_serviceName;
+    QBluetoothUuid m_uuid;
+    int maxPendingConnections;
+    QBluetooth::SecurityFlags secFlags;
+
+    QSharedPointer<QJsSocket> m_jsSocket;
+    QSharedPointer<QJsConnect> m_jsConnect;
+
+};
+#endif // SERVERACCEPTANCETHREAD_P_H
diff --git a/src/bluetooth/qbluetooth.cpp b/src/bluetooth/qbluetooth.cpp
index 1e8ce0b8..5e9cf19b 100644
--- a/src/bluetooth/qbluetooth.cpp
+++ b/src/bluetooth/qbluetooth.cpp
@@ -104,6 +104,7 @@ Q_LOGGING_CATEGORY(QT_BT_ANDROID, "qt.bluetooth.android")
 Q_LOGGING_CATEGORY(QT_BT_BLUEZ, "qt.bluetooth.bluez")
 Q_LOGGING_CATEGORY(QT_BT_WINDOWS, "qt.bluetooth.windows")
 Q_LOGGING_CATEGORY(QT_BT_WINRT, "qt.bluetooth.winrt")
+Q_LOGGING_CATEGORY(QT_BT_OPENHARMONY, "qt.bluetooth.openharmony")
 Q_LOGGING_CATEGORY(QT_BT_WINRT_SERVICE_THREAD, "qt.bluetooth.winrt.service.thread")
 
 QT_END_NAMESPACE
diff --git a/src/bluetooth/qbluetoothdevicediscoveryagent_ohos.cpp b/src/bluetooth/qbluetoothdevicediscoveryagent_ohos.cpp
new file mode 100644
index 00000000..9d5ea592
--- /dev/null
+++ b/src/bluetooth/qbluetoothdevicediscoveryagent_ohos.cpp
@@ -0,0 +1,272 @@
+#include <QtCore/QLoggingCategory>
+#include <QtBluetooth/QBluetoothAddress>
+#include <QtBluetooth/QBluetoothDeviceInfo>
+
+// #include <QtCore/QOpenHarmonyJsObject>
+// #include <QtCore/QOpenHarmonyJsObjectLoader>
+// #include <QtCore/QOpenHarmonyJsEnvironment>
+#include "qbluetoothdevicediscoveryagent_p.h"
+#include "openharmony/openharmonybluetoothdiscoveryreceiver_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+enum {
+    NoScanActive = 0,
+    SDPScanActive = 1,
+    BtleScanActive = 2
+};
+
+// enum {
+//     STATE_OFF = 0,          /* 表示蓝牙已关闭 */
+//     STATE_TURNING_ON,       /* 表示蓝牙正在打开 */
+//     STATE_ON,               /* 表示蓝牙已打开 */
+//     STATE_TURNING_OFF,      /* 表示蓝牙正在关闭 */
+//     STATE_BLE_TURNING_ON,   /* 表示蓝牙正在打开LE-only模式 */
+//     STATE_BLE_ON,           /* 表示蓝牙正处于LE-only模式 */
+//     STATE_BLE_TURNING_OFF   /* 表示蓝牙正在关闭LE-only模式 */
+// };
+
+QBluetoothDeviceDiscoveryAgentPrivate::QBluetoothDeviceDiscoveryAgentPrivate(
+        const QBluetoothAddress &deviceAdapter, QBluetoothDeviceDiscoveryAgent *parent) :
+      inquiryType(QBluetoothDeviceDiscoveryAgent::GeneralUnlimitedInquiry),
+      lastError(QBluetoothDeviceDiscoveryAgent::NoError),
+      receiver(0),
+      m_adapterAddress(deviceAdapter),
+      m_active(NoScanActive),
+      leScanTimeout(Q_NULLPTR),
+      pendingCancel(false),
+      pendingStart(false),
+      lowEnergySearchTimeout(25000),
+      q_ptr(parent)
+{
+    m_jsConnect = QSharedPointer<QJsConnect>::create();
+    m_jsBle = QSharedPointer<QJsBle>::create();
+}
+
+QBluetoothDeviceDiscoveryAgentPrivate::~QBluetoothDeviceDiscoveryAgentPrivate()
+{
+    if (receiver) {
+        delete receiver;
+    }
+}
+
+bool QBluetoothDeviceDiscoveryAgentPrivate::isActive() const
+{
+    if (pendingStart)
+        return true;
+    if (pendingCancel)
+        return false;
+    return m_active != NoScanActive;
+}
+
+QBluetoothDeviceDiscoveryAgent::DiscoveryMethods QBluetoothDeviceDiscoveryAgent::supportedDiscoveryMethods()
+{
+    return (LowEnergyMethod | ClassicMethod);
+}
+
+void QBluetoothDeviceDiscoveryAgentPrivate::start(QBluetoothDeviceDiscoveryAgent::DiscoveryMethods methods)
+{    
+    requestedMethods = methods;
+
+    if (pendingCancel) {
+        pendingStart = true;
+        return;
+    }
+
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+
+    if (!m_adapterAddress.isNull() && m_jsConnect->localName() != m_adapterAddress.toString()) {
+        qCWarning(QT_BT_OPENHARMONY) << "Incorrect local adapter passed.";
+        lastError = QBluetoothDeviceDiscoveryAgent::InvalidBluetoothAdapterError;
+        errorString = QBluetoothDeviceDiscoveryAgent::tr("Passed address is not a local device.");
+        emit q->error(lastError);
+        return;
+    }
+
+    if(!m_jsAccess)
+        m_jsAccess = QSharedPointer<QJsAccess>::create();
+
+    const QJsAccess::BluetoothState state = m_jsAccess->getState();
+    if (state !=  QJsAccess::STATE_ON) {
+        lastError = QBluetoothDeviceDiscoveryAgent::PoweredOffError;
+        errorString = QBluetoothDeviceDiscoveryAgent::tr("Device is powered off");
+        emit q->error(lastError);
+        return;
+    }
+
+    if (!receiver) {
+        receiver = new OpenHarmonyBluetoothDiscoveryReceiver();
+        qRegisterMetaType<QBluetoothDeviceInfo>();
+        QObject::connect(receiver, SIGNAL(deviceDiscovered(QBluetoothDeviceInfo,bool)),
+                         this, SLOT(processDiscoveredDevices(QBluetoothDeviceInfo,bool)));
+        QObject::connect(receiver, SIGNAL(finished()), this, SLOT(processSdpDiscoveryFinished()));
+    }
+
+    discoveredDevices.clear();
+         // by arbitrary definition we run classic search first
+    if (requestedMethods & QBluetoothDeviceDiscoveryAgent::ClassicMethod) {
+        const bool success = m_jsConnect->startBluetoothDiscovery();
+        if (!success) {
+            qCDebug(QT_BT_OPENHARMONY) << "Classic Discovery cannot be started";
+            if (requestedMethods == QBluetoothDeviceDiscoveryAgent::ClassicMethod) {
+                //only classic discovery requested -> error out
+                lastError = QBluetoothDeviceDiscoveryAgent::InputOutputError;
+                errorString = QBluetoothDeviceDiscoveryAgent::tr("Classic Discovery cannot be started");                
+                emit q->error(lastError);
+                return;
+            } // else fall through to LE discovery
+        } else {
+            m_active = SDPScanActive;
+            qCDebug(QT_BT_OPENHARMONY)
+                    << "QBluetoothDeviceDiscoveryAgentPrivate::start() - Classic search successfully started.";            
+            return;
+        }
+    }
+
+    if (requestedMethods & QBluetoothDeviceDiscoveryAgent::LowEnergyMethod) {
+        // LE search only requested or classic discovery failed but lets try LE scan anyway
+        Q_ASSERT(requestedMethods & QBluetoothDeviceDiscoveryAgent::LowEnergyMethod);
+
+        startLowEnergyScan();
+    }    
+}
+
+void QBluetoothDeviceDiscoveryAgentPrivate::processSdpDiscoveryFinished()
+{    
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+    emit q->finished();
+}
+
+void QBluetoothDeviceDiscoveryAgentPrivate::processDiscoveredDevices(const QBluetoothDeviceInfo &info, bool isLeResult)
+{
+    // If we have two active agents both receive the same signal.
+    // If this one is not active ignore the device information
+    if (m_active != SDPScanActive && !isLeResult)
+        return;
+    if (m_active != BtleScanActive && isLeResult)
+        return;
+
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+
+    // OpenHarmony Classic scan and LE scan can find the same device under different names
+    // The classic name finds the SDP based device name, the LE scan finds the name in
+    // the advertisement package.
+    // If address is same but name different then we keep both entries.
+
+    for (int i = 0; i < discoveredDevices.size(); i++) {
+        if (discoveredDevices[i].address() == info.address()) {
+            QBluetoothDeviceInfo::Fields updatedFields = QBluetoothDeviceInfo::Field::None;
+            if (discoveredDevices[i].rssi() != info.rssi()) {
+                qCDebug(QT_BT_OPENHARMONY()) << "Updating RSSI for" << info.address()
+                                       << info.rssi();
+                discoveredDevices[i].setRssi(info.rssi());
+                updatedFields.setFlag(QBluetoothDeviceInfo::Field::RSSI);
+            }
+            if (discoveredDevices[i].manufacturerData() != info.manufacturerData()) {
+                qCDebug(QT_BT_OPENHARMONY) << "Updating manufacturer data for" << info.address();
+                const QVector<quint16> keys = info.manufacturerIds();
+                for (auto key: keys)
+                    discoveredDevices[i].setManufacturerData(key, info.manufacturerData(key));
+                updatedFields.setFlag(QBluetoothDeviceInfo::Field::ManufacturerData);
+            }
+
+            if (lowEnergySearchTimeout > 0) {
+                if (discoveredDevices[i] != info) {
+                    if (discoveredDevices.at(i).name() == info.name()) {
+                        qCDebug(QT_BT_OPENHARMONY) << "Almost Duplicate " << info.address()
+                                               << info.name() << "- replacing in place";
+                        discoveredDevices.replace(i, info);
+                        emit q->deviceDiscovered(info);
+                    }
+                } else {
+                    if (!updatedFields.testFlag(QBluetoothDeviceInfo::Field::None))
+                        emit q->deviceUpdated(discoveredDevices[i], updatedFields);
+                }
+
+                return;
+            }
+
+            discoveredDevices.replace(i, info);
+            emit q->deviceDiscovered(info);
+
+            if (!updatedFields.testFlag(QBluetoothDeviceInfo::Field::None))
+                emit q->deviceUpdated(discoveredDevices[i], updatedFields);
+
+            return;
+        }
+    }
+
+    discoveredDevices.append(info);
+    qCDebug(QT_BT_OPENHARMONY) << "Device found: " << info.name() << info.address().toString()
+                           << "isLeScanResult:" << isLeResult;
+    emit q->deviceDiscovered(info);
+}
+
+void QBluetoothDeviceDiscoveryAgentPrivate::stop()
+{
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+
+    if (m_active == NoScanActive)
+        return;
+
+    if (m_active == SDPScanActive) {
+        if (pendingCancel)
+            return;
+
+        pendingCancel = true;
+        pendingStart = false;
+        bool success = m_jsConnect->stopBluetoothDiscovery();
+        if (!success) {
+            lastError = QBluetoothDeviceDiscoveryAgent::InputOutputError;
+            errorString = QBluetoothDeviceDiscoveryAgent::tr("Discovery cannot be stopped");
+            emit q->error(lastError);
+            return;
+        }
+    } else if (m_active == BtleScanActive) {
+        stopLowEnergyScan();
+    }    
+}
+void QBluetoothDeviceDiscoveryAgentPrivate::startLowEnergyScan()
+{
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+
+    m_active = BtleScanActive;
+
+    m_jsBle->startBLEScan();
+
+         // wait interval and sum up what was found
+    if (!leScanTimeout) {
+        leScanTimeout = new QTimer(this);
+        leScanTimeout->setSingleShot(true);
+        connect(leScanTimeout, &QTimer::timeout,
+                this, &QBluetoothDeviceDiscoveryAgentPrivate::stopLowEnergyScan);
+    }
+
+    if (lowEnergySearchTimeout > 0) { // otherwise no timeout and stop() required
+        leScanTimeout->setInterval(lowEnergySearchTimeout);
+        leScanTimeout->start();
+    }
+
+    qCDebug(QT_BT_OPENHARMONY)
+            << "QBluetoothDeviceDiscoveryAgentPrivate::start() - Low Energy search successfully started.";
+}
+
+void QBluetoothDeviceDiscoveryAgentPrivate::stopLowEnergyScan()
+{
+    m_jsBle->stopBLEScan();
+
+    m_active = NoScanActive;
+
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+    if (leScanTimeout->isActive()) {
+        // still active if this function was called from stop()
+        leScanTimeout->stop();
+        emit q->canceled();
+    } else {
+        // timeout -> regular stop
+        emit q->finished();
+    }
+}
+QT_END_NAMESPACE
diff --git a/src/bluetooth/qbluetoothdevicediscoveryagent_p.h b/src/bluetooth/qbluetoothdevicediscoveryagent_p.h
index ca93d839..fa957001 100644
--- a/src/bluetooth/qbluetoothdevicediscoveryagent_p.h
+++ b/src/bluetooth/qbluetoothdevicediscoveryagent_p.h
@@ -59,6 +59,16 @@
 #include <QtCore/QTimer>
 #endif
 
+#ifdef QT_OPENHARMONY_BLUETOOTH
+#include <QtCore/QTimer>
+#include <QSharedPointer>
+
+#include "qjsconnect.h"
+#include "qjsaccess.h"
+#include "qjsble.h"
+class OpenHarmonyBluetoothDiscoveryReceiver;
+#endif
+
 #ifdef Q_OS_DARWIN
 #include "osx/btdelegates_p.h"
 #include "osx/btraii_p.h"
@@ -113,7 +123,7 @@ class QWinRTBluetoothDeviceDiscoveryWorker;
 
 class QBluetoothDeviceDiscoveryAgentPrivate
 #if defined(QT_ANDROID_BLUETOOTH) || defined(QT_WINRT_BLUETOOTH) || defined(QT_WIN_BLUETOOTH) \
-            || defined(Q_OS_DARWIN)
+            || defined(Q_OS_DARWIN) || defined(QT_OPENHARMONY_BLUETOOTH)
     : public QObject
 #if defined(Q_OS_MACOS)
     , public DarwinBluetooth::DeviceInquiryDelegate
@@ -196,6 +206,27 @@ private:
     QMap<QString, QVariantMap> devicesProperties;
 #endif
 
+#ifdef QT_OPENHARMONY_BLUETOOTH
+private slots:
+    void processSdpDiscoveryFinished();
+    void processDiscoveredDevices(const QBluetoothDeviceInfo &info, bool isLeResult);
+    void stopLowEnergyScan();
+
+private:
+    void startLowEnergyScan();
+
+private:
+    OpenHarmonyBluetoothDiscoveryReceiver *receiver;
+    QBluetoothAddress m_adapterAddress;
+    short m_active;
+    QTimer *leScanTimeout;
+    bool pendingCancel, pendingStart;
+    QSharedPointer<QJsConnect> m_jsConnect;
+    QSharedPointer<QJsAccess> m_jsAccess;
+    QSharedPointer<QJsBle> m_jsBle;
+
+#endif
+
 #ifdef QT_WIN_BLUETOOTH
 public:
     static QString discoveredLeDeviceSystemPath(const QBluetoothAddress &deviceAddress);
diff --git a/src/bluetooth/qbluetoothlocaldevice.h b/src/bluetooth/qbluetoothlocaldevice.h
index 9f6d1e1b..59bdd36b 100644
--- a/src/bluetooth/qbluetoothlocaldevice.h
+++ b/src/bluetooth/qbluetoothlocaldevice.h
@@ -69,6 +69,11 @@ public:
         HostConnectable,
         HostDiscoverable,
         HostDiscoverableLimitedInquiry
+#ifdef Q_OS_OPENHARMONY
+        ,
+        HostConnectableGeneralDiscoverable,
+        HostConnectableLimitedDiscoverable
+#endif
     };
     Q_ENUM(HostMode)
 
diff --git a/src/bluetooth/qbluetoothlocaldevice_ohos.cpp b/src/bluetooth/qbluetoothlocaldevice_ohos.cpp
new file mode 100644
index 00000000..c7689b62
--- /dev/null
+++ b/src/bluetooth/qbluetoothlocaldevice_ohos.cpp
@@ -0,0 +1,322 @@
+#include <QtCore/QLoggingCategory>
+#include <QtBluetooth/QBluetoothLocalDevice>
+#include <QtBluetooth/QBluetoothAddress>
+
+#include "qbluetoothlocaldevice_p.h"
+//#include "openharmony/localdevicebroadcastreceiver_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+QBluetoothLocalDevicePrivate::QBluetoothLocalDevicePrivate(
+        QBluetoothLocalDevice *q, const QBluetoothAddress &address) :
+      q_ptr(q)
+{
+
+    initialize(address);
+    m_jsConnect = QSharedPointer<QJsConnect>::create();
+    m_jsAccess = QSharedPointer<QJsAccess>::create();
+    m_jsSocket = QSharedPointer<QJsSocket>::create();
+
+    //    receiver = new LocalDeviceBroadcastReceiver(q_ptr);
+    //    connect(receiver, &LocalDeviceBroadcastReceiver::hostModeStateChanged,
+    //            this, &QBluetoothLocalDevicePrivate::processHostModeChange);
+    //    connect(receiver, &LocalDeviceBroadcastReceiver::pairingStateChanged,
+    //            this, &QBluetoothLocalDevicePrivate::processPairingStateChanged);
+    //    connect(receiver, &LocalDeviceBroadcastReceiver::connectDeviceChanges,
+    //            this, &QBluetoothLocalDevicePrivate::processConnectDeviceChanges);
+    //    connect(receiver, &LocalDeviceBroadcastReceiver::pairingDisplayConfirmation,
+    //            this, &QBluetoothLocalDevicePrivate::processDisplayConfirmation);
+}
+
+QBluetoothLocalDevicePrivate::~QBluetoothLocalDevicePrivate()
+{
+
+}
+
+void QBluetoothLocalDevicePrivate::initialize(const QBluetoothAddress &address)
+{
+    if (!address.isNull()) {
+        const QString localAddress = m_jsConnect->localName();
+        if (localAddress != address.toString()) {
+            // passed address not local one -> invalid
+        }
+    }
+}
+
+bool QBluetoothLocalDevicePrivate::isValid() const
+{
+    return true;
+}
+
+void QBluetoothLocalDevicePrivate::processHostModeChange(QBluetoothLocalDevice::HostMode newMode)
+{
+    if (!pendingHostModeTransition) {
+        // if not in transition -> pass data on
+        emit q_ptr->hostModeStateChanged(newMode);
+        return;
+    }
+
+    if (isValid() && newMode == QBluetoothLocalDevice::HostPoweredOff) {
+        const QJsAccess::BluetoothState state = m_jsAccess->getState();
+        if (state != QJsAccess::STATE_ON && state != QJsAccess::STATE_TURNING_ON) {
+            emit q_ptr->error(QBluetoothLocalDevice::UnknownError);
+        }
+    }
+
+    pendingHostModeTransition = false;
+}
+
+// Return -1 if address is not part of a pending pairing request
+// Otherwise it returns the index of address in pendingPairings
+int QBluetoothLocalDevicePrivate::pendingPairing(const QBluetoothAddress &address)
+{
+    for (int i = 0; i < pendingPairings.count(); i++) {
+        if (pendingPairings.at(i).first == address)
+            return i;
+    }
+
+    return -1;
+}
+
+void QBluetoothLocalDevicePrivate::processPairingStateChanged(
+        const QBluetoothAddress &address, QBluetoothLocalDevice::Pairing pairing)
+{
+    int index = pendingPairing(address);
+
+    if (index < 0)
+        return; // ignore unrelated pairing signals
+
+    QPair<QBluetoothAddress, bool> entry = pendingPairings.takeAt(index);
+    if ((entry.second && pairing == QBluetoothLocalDevice::Paired)
+        || (!entry.second && pairing == QBluetoothLocalDevice::Unpaired)) {
+        emit q_ptr->pairingFinished(address, pairing);
+    } else {
+        emit q_ptr->error(QBluetoothLocalDevice::PairingError);
+    }
+}
+
+void QBluetoothLocalDevicePrivate::processConnectDeviceChanges(const QBluetoothAddress &address,
+                                                               bool isConnectEvent)
+{
+    int index = -1;
+    for (int i = 0; i < connectedDevices.count(); i++) {
+        if (connectedDevices.at(i) == address) {
+            index = i;
+            break;
+        }
+    }
+
+    if (isConnectEvent) { // connect event
+        if (index >= 0)
+            return;
+        connectedDevices.append(address);
+        emit q_ptr->deviceConnected(address);
+    } else { // disconnect event
+        connectedDevices.removeAll(address);
+        emit q_ptr->deviceDisconnected(address);
+    }
+}
+
+void QBluetoothLocalDevicePrivate::processDisplayConfirmation(const QBluetoothAddress &address,
+                                                              const QString &pin)
+{
+    // only send pairing notification for pairing requests issued by
+    // this QBluetoothLocalDevice instance
+    if (pendingPairing(address) == -1)
+        return;
+
+    emit q_ptr->pairingDisplayConfirmation(address, pin);
+    emit q_ptr->pairingDisplayPinCode(address, pin);
+}
+
+QBluetoothLocalDevice::QBluetoothLocalDevice(QObject *parent) :
+      QObject(parent),
+      d_ptr(new QBluetoothLocalDevicePrivate(this, QBluetoothAddress()))
+{
+}
+
+QBluetoothLocalDevice::QBluetoothLocalDevice(const QBluetoothAddress &address, QObject *parent) :
+      QObject(parent),
+      d_ptr(new QBluetoothLocalDevicePrivate(this, address))
+{
+}
+
+QString QBluetoothLocalDevice::name() const
+{
+    if (d_ptr->isValid())
+        return d_ptr->m_jsConnect->localName();
+
+    return QString();
+}
+
+QBluetoothAddress QBluetoothLocalDevice::address() const
+{
+    QString result;
+    if (d_ptr->isValid()) {
+        result = d_ptr->m_jsSocket->localAddress();
+    }
+
+    QBluetoothAddress address(result);
+    return address;
+}
+
+void QBluetoothLocalDevice::powerOn()
+{
+    if (hostMode() != HostPoweredOff)
+        return;
+
+    const QJsAccess::BluetoothState state = d_ptr->m_jsAccess->getState();
+    if (state != QJsAccess::STATE_ON && state != QJsAccess::STATE_TURNING_ON) {
+        emit error(QBluetoothLocalDevice::UnknownError);
+    }
+}
+
+void QBluetoothLocalDevice::setHostMode(QBluetoothLocalDevice::HostMode requestedMode)
+{
+    QBluetoothLocalDevice::HostMode mode = requestedMode;
+    if (requestedMode == HostDiscoverableLimitedInquiry)
+        mode = HostDiscoverable;
+
+    if (mode == hostMode())
+        return;
+
+    if (mode == QBluetoothLocalDevice::HostPoweredOff) {
+        bool success = false;
+        if (d_ptr->isValid())
+            success = d_ptr->m_jsAccess->disableBluetooth();
+
+        if (!success)
+            emit error(QBluetoothLocalDevice::UnknownError);
+    } else if (mode == QBluetoothLocalDevice::HostConnectable) {
+        if (hostMode() == QBluetoothLocalDevice::HostDiscoverable) {
+            // cannot directly go from Discoverable to Connectable
+            // we need to go to disabled mode and enable once disabling came through
+
+            setHostMode(QBluetoothLocalDevice::HostPoweredOff);
+            d_ptr->pendingHostModeTransition = true;
+        } else {
+            d_ptr->m_jsConnect->setBluetoothScanMode(1, 0);
+        }
+    } else if (mode == QBluetoothLocalDevice::HostDiscoverable) {
+        d_ptr->m_jsConnect->setBluetoothScanMode(2, 0);
+    } else if (mode == QBluetoothLocalDevice::HostDiscoverableLimitedInquiry) {
+        d_ptr->m_jsConnect->setBluetoothScanMode(3, 0);
+    }
+}
+
+QBluetoothLocalDevice::HostMode QBluetoothLocalDevice::hostMode() const
+{
+    if (d_ptr->isValid()) {
+        int scanMode = d_ptr->m_jsConnect->getBluetoothScanMode();
+
+        switch (scanMode) {
+        case 0:     // SCAN_MODE_NONE
+            return HostPoweredOff;
+        case 1:     // SCAN_MODE_CONNECTABLE
+            return HostConnectable;
+        case 2:     // SCAN_MODE_GENERAL_DISCOVERABLE
+            return HostDiscoverable;
+        case 3:     // SCAN_MODE_LIMITED_DISCOVERABLE
+            return HostDiscoverableLimitedInquiry;
+        case 4:
+            return HostConnectableGeneralDiscoverable;
+        case 5:
+            return HostConnectableLimitedDiscoverable;
+        default:
+            break;
+        }
+    }
+
+    return HostPoweredOff;
+}
+
+QList<QBluetoothHostInfo> QBluetoothLocalDevice::allDevices()
+{
+    QList<QBluetoothHostInfo> localDevices;
+
+    QBluetoothHostInfo info;
+    QSharedPointer<QJsSocket> jsSocket = QSharedPointer<QJsSocket>::create();
+    QSharedPointer<QJsConnect> jsConnect = QSharedPointer<QJsConnect>::create();
+    info.setName(jsConnect->localName());
+    info.setAddress(QBluetoothAddress(jsSocket->localAddress()));
+    localDevices.append(info);
+
+    return localDevices;
+}
+
+void QBluetoothLocalDevice::requestPairing(const QBluetoothAddress &address, Pairing pairing)
+{
+    if (address.isNull()) {
+        QMetaObject::invokeMethod(this, "error", Qt::QueuedConnection,
+                                  Q_ARG(QBluetoothLocalDevice::Error,
+                                        QBluetoothLocalDevice::PairingError));
+        return;
+    }
+
+    const Pairing previousPairing = pairingStatus(address);
+    Pairing newPairing = pairing;
+    if (pairing == AuthorizedPaired)
+        newPairing = Paired;
+
+    if (previousPairing == newPairing) {
+        QMetaObject::invokeMethod(this, "pairingFinished", Qt::QueuedConnection,
+                                  Q_ARG(QBluetoothAddress, address),
+                                  Q_ARG(QBluetoothLocalDevice::Pairing, pairing));
+        return;
+    }
+
+    if (isValid()) {
+        bool success = d_ptr->m_jsConnect->pairDevice(address.toString(), newPairing == Paired);
+        if (!success) {
+            QMetaObject::invokeMethod(this, "error", Qt::QueuedConnection,
+                                      Q_ARG(QBluetoothLocalDevice::Error,
+                                            QBluetoothLocalDevice::PairingError));
+        }
+    } else {
+        d_ptr->pendingPairings.append(qMakePair(address, newPairing == Paired ? true : false));
+    }
+}
+
+QBluetoothLocalDevice::Pairing QBluetoothLocalDevice::pairingStatus(
+        const QBluetoothAddress &address) const
+{
+    if (!isValid())
+        return Unpaired;
+
+    QStringList pairedDevices = d_ptr->m_jsConnect->getPairedDevices();
+
+    if(pairedDevices.contains(address.toString())){
+        return Paired;
+    }
+
+    return Unpaired;
+}
+
+void QBluetoothLocalDevice::pairingConfirmation(bool confirmation)
+{
+    //    bool success = d_ptr->receiver->pairingConfirmation(confirmation);
+    //    if (!success)
+    //        emit error(PairingError);
+}
+
+QList<QBluetoothAddress> QBluetoothLocalDevice::connectedDevices() const
+{
+    if (!isValid())
+        return QList<QBluetoothAddress>();
+
+    QList<QBluetoothAddress> knownAddresses;
+
+    QStringList devices = d_ptr->m_jsConnect->getPairedDevices();
+    int size = devices.size();
+    for (int i = 0; i < size; i++) {
+        QBluetoothAddress address(devices.at(i));
+        if (!address.isNull() && !knownAddresses.contains(address))
+            knownAddresses.append(address);
+    }
+
+    return knownAddresses;
+}
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/qbluetoothlocaldevice_p.h b/src/bluetooth/qbluetoothlocaldevice_p.h
index 6bb74737..a20eff8d 100644
--- a/src/bluetooth/qbluetoothlocaldevice_p.h
+++ b/src/bluetooth/qbluetoothlocaldevice_p.h
@@ -85,6 +85,15 @@ QT_END_NAMESPACE
 #include <QtCore/QPair>
 #endif
 
+#ifdef QT_OPENHARMONY_BLUETOOTH
+// #include "QtCore/qopenharmonyjsobject.h"
+#include <QSharedPointer>
+
+#include "qjsconnect.h"
+#include "qjsaccess.h"
+#include "qjssocket.h"
+#endif
+
 #ifdef QT_WINRT_BLUETOOTH
 #include <wrl.h>
 
@@ -263,6 +272,44 @@ private:
     Microsoft::WRL::ComPtr<ABI::Windows::Devices::Bluetooth::IBluetoothDeviceStatics> mStatics;
     Microsoft::WRL::ComPtr<ABI::Windows::Devices::Bluetooth::IBluetoothLEDeviceStatics> mLEStatics;
 };
+#elif QT_OPENHARMONY_BLUETOOTH
+class LocalDeviceBroadcastReceiver;
+class QBluetoothLocalDevicePrivate : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PUBLIC(QBluetoothLocalDevice)
+
+public:
+    QBluetoothLocalDevicePrivate(
+            QBluetoothLocalDevice *q, const QBluetoothAddress &address = QBluetoothAddress());
+    ~QBluetoothLocalDevicePrivate();
+
+    void initialize(const QBluetoothAddress &address);
+    static bool startDiscovery();
+    static bool cancelDiscovery();
+    static bool isDiscovering();
+    bool isValid() const;
+
+private slots:
+    void processHostModeChange(QBluetoothLocalDevice::HostMode newMode);
+    void processPairingStateChanged(const QBluetoothAddress &address,
+                                    QBluetoothLocalDevice::Pairing pairing);
+    void processConnectDeviceChanges(const QBluetoothAddress &address, bool isConnectEvent);
+    void processDisplayConfirmation(const QBluetoothAddress &address, const QString &pin);
+
+public:
+    LocalDeviceBroadcastReceiver *receiver;
+    bool pendingHostModeTransition = false;
+    QList<QPair<QBluetoothAddress, bool> > pendingPairings;
+
+    QList<QBluetoothAddress> connectedDevices;
+private:
+    int pendingPairing(const QBluetoothAddress &address);
+    QBluetoothLocalDevice *q_ptr;
+    QSharedPointer<QJsConnect> m_jsConnect;
+    QSharedPointer<QJsAccess> m_jsAccess;
+    QSharedPointer<QJsSocket> m_jsSocket;
+};
 #elif !defined(QT_OSX_BLUETOOTH) // dummy backend
 class QBluetoothLocalDevicePrivate : public QObject
 {
diff --git a/src/bluetooth/qbluetoothserver.cpp b/src/bluetooth/qbluetoothserver.cpp
index daed5dc2..b12447d4 100644
--- a/src/bluetooth/qbluetoothserver.cpp
+++ b/src/bluetooth/qbluetoothserver.cpp
@@ -265,7 +265,7 @@ bool QBluetoothServer::isListening() const
 {
     Q_D(const QBluetoothServer);
 
-#if defined(QT_ANDROID_BLUETOOTH) || defined(QT_WINRT_BLUETOOTH) || defined(QT_OSX_BLUETOOTH)
+#if defined(QT_ANDROID_BLUETOOTH) || defined(QT_WINRT_BLUETOOTH) || defined(QT_OSX_BLUETOOTH) || defined(QT_OPENHARMONY_BLUETOOTH)
     return d->isListening();
 #endif
 
diff --git a/src/bluetooth/qbluetoothserver_ohos.cpp b/src/bluetooth/qbluetoothserver_ohos.cpp
new file mode 100644
index 00000000..b17430bd
--- /dev/null
+++ b/src/bluetooth/qbluetoothserver_ohos.cpp
@@ -0,0 +1,230 @@
+#include <QCoreApplication>
+#include <QtCore/QLoggingCategory>
+
+#include "qbluetoothserver.h"
+#include "qbluetoothserver_p.h"
+#include "qbluetoothsocket.h"
+#include "qbluetoothsocket_ohos_p.h"
+#include "qbluetoothlocaldevice.h"
+#include "openharmony/serveracceptancethread_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+QHash<QBluetoothServerPrivate*, int> __fakeServerPorts;
+QBluetoothServerPrivate::QBluetoothServerPrivate(QBluetoothServiceInfo::Protocol sType,  QBluetoothServer *parent)
+    : socket(0),maxPendingConnections(1), securityFlags(QBluetooth::NoSecurity), serverType(sType),
+      m_lastError(QBluetoothServer::NoError), q_ptr(parent)
+{
+    thread = new ServerAcceptanceThread();
+    thread->setMaxPendingConnections(maxPendingConnections);
+}
+
+QBluetoothServerPrivate::~QBluetoothServerPrivate()
+{
+    Q_Q(QBluetoothServer);
+    if (isListening())
+        q->close();
+
+    __fakeServerPorts.remove(this);
+
+    thread->deleteLater();
+    thread = nullptr;
+}
+
+bool QBluetoothServerPrivate::initiateActiveListening(
+        const QBluetoothUuid& uuid, const QString &serviceName)
+{
+    qCDebug(QT_BT_OPENHARMONY) << "Initiate active listening" << uuid.toString() << serviceName;
+
+    if (uuid.isNull() || serviceName.isEmpty())
+        return false;
+
+    //no change of SP profile details -> do nothing
+    if (uuid == m_uuid && serviceName == m_serviceName && thread->isRunning())
+        return true;
+
+    m_uuid = uuid;
+    m_serviceName = serviceName;
+    thread->setServiceDetails(m_uuid, m_serviceName, securityFlags);
+
+    thread->run();
+    if (!thread->isRunning())
+        return false;
+
+    return true;
+}
+
+bool QBluetoothServerPrivate::deactivateActiveListening()
+{
+    if (isListening()) {
+        //suppress last error signal due to intended closure
+        thread->disconnect();
+        thread->stop();
+    }
+    return true;
+}
+
+bool QBluetoothServerPrivate::isListening() const
+{
+    return __fakeServerPorts.contains(const_cast<QBluetoothServerPrivate *>(this));
+}
+
+void QBluetoothServer::close()
+{
+    Q_D(QBluetoothServer);
+
+    __fakeServerPorts.remove(d);
+    if (d->thread->isRunning()) {
+        //suppress last error signal due to intended closure
+        d->thread->disconnect();
+        d->thread->stop();
+    }
+}
+
+bool QBluetoothServer::listen(const QBluetoothAddress &localAdapter, quint16 port)
+{
+    Q_D(QBluetoothServer);
+    if (serverType() != QBluetoothServiceInfo::RfcommProtocol) {
+        d->m_lastError = UnsupportedProtocolError;
+        emit error(d->m_lastError);
+        return false;
+    }
+
+    const QList<QBluetoothHostInfo> localDevices = QBluetoothLocalDevice::allDevices();
+    if (!localDevices.count()) {
+        qCWarning(QT_BT_OPENHARMONY) << "Device does not support Bluetooth";
+        d->m_lastError = QBluetoothServer::UnknownError;
+        emit error(d->m_lastError);
+        return false; //no Bluetooth device
+    }
+
+    if (!localAdapter.isNull()) {
+        bool found = false;
+        for (const QBluetoothHostInfo &hostInfo : localDevices) {
+            if (hostInfo.address() == localAdapter) {
+                found = true;
+                break;
+            }
+        }
+
+        if (!found) {
+            qCWarning(QT_BT_OPENHARMONY) << localAdapter.toString() << "is not a valid local Bt adapter";
+            return false;
+        }
+    }
+
+    if (d->isListening())
+        return false;
+
+    if(!d->m_jsAccess)
+        d->m_jsAccess = QSharedPointer<QJsAccess>::create();
+
+    const int state = (int)d->m_jsAccess->getState();
+    // const int state = btMgr->call<int>("getState");
+    static QVector<int> offState{ 0, 3, 6 };
+
+    if (offState.contains(state)) { //BluetoothState
+        d->m_lastError = QBluetoothServer::PoweredOffError;
+        emit error(d->m_lastError);
+        qCWarning(QT_BT_OPENHARMONY) << "Bluetooth device is powered off";
+        return false;
+    }
+
+           //We can not register an actual Rfcomm port, because the platform does not allow it
+           //but we need a way to associate a server with a service
+    if (port == 0) { //Try to assign a non taken port id
+        for (int i=1; ; i++){
+            if (__fakeServerPorts.key(i) == 0) {
+                port = i;
+                break;
+            }
+        }
+    }
+
+    if (__fakeServerPorts.key(port) == 0) {
+        __fakeServerPorts[d] = port;
+
+        qCDebug(QT_BT_OPENHARMONY) << "Port" << port << "registered";
+    } else {
+        qCWarning(QT_BT_OPENHARMONY) << "server with port" << port << "already registered or port invalid";
+        d->m_lastError = ServiceAlreadyRegisteredError;
+        emit error(d->m_lastError);
+        return false;
+    }
+
+    connect(d->thread, SIGNAL(newConnection()),
+            this, SIGNAL(newConnection()));
+    connect(d->thread, SIGNAL(error(QBluetoothServer::Error)),
+            this, SIGNAL(error(QBluetoothServer::Error)), Qt::QueuedConnection);
+
+    return true;
+}
+
+void QBluetoothServer::setMaxPendingConnections(int numConnections)
+{
+    Q_D(QBluetoothServer);
+    d->maxPendingConnections = numConnections;
+    d->thread->setMaxPendingConnections(numConnections);
+}
+
+QBluetoothAddress QBluetoothServer::serverAddress() const
+{
+    //only supports one local adapter
+    QList<QBluetoothHostInfo> hosts = QBluetoothLocalDevice::allDevices();
+    Q_ASSERT(hosts.count() <= 1);
+
+    if (hosts.isEmpty())
+        return QBluetoothAddress();
+    else
+        return hosts.at(0).address();
+}
+
+quint16 QBluetoothServer::serverPort() const
+{
+    //We return the fake port
+    Q_D(const QBluetoothServer);
+    return __fakeServerPorts.value((QBluetoothServerPrivate*)d, 0);
+}
+
+bool QBluetoothServer::hasPendingConnections() const
+{
+    Q_D(const QBluetoothServer);
+
+    return d->thread->hasPendingConnections();
+}
+
+QBluetoothSocket *QBluetoothServer::nextPendingConnection()
+{
+    Q_D(const QBluetoothServer);
+
+    int socket = d->thread->nextPendingConnection();
+    if (-1 == socket)
+        return 0;
+
+    QBluetoothSocket *newSocket = new QBluetoothSocket();
+
+    bool success = newSocket->d_ptr->setSocketDescriptor(socket, d->serverType);
+    if (!success) {
+        delete newSocket;
+        newSocket = nullptr;
+    }
+
+    return newSocket;
+}
+
+void QBluetoothServer::setSecurityFlags(QBluetooth::SecurityFlags security)
+{
+    Q_D(QBluetoothServer);
+    d->securityFlags = security;
+}
+
+QBluetooth::SecurityFlags QBluetoothServer::securityFlags() const
+{
+    Q_D(const QBluetoothServer);
+    return d->securityFlags;
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/bluetooth/qbluetoothserver_p.h b/src/bluetooth/qbluetoothserver_p.h
index d14dc7b4..e3f01126 100644
--- a/src/bluetooth/qbluetoothserver_p.h
+++ b/src/bluetooth/qbluetoothserver_p.h
@@ -69,6 +69,12 @@ QT_FORWARD_DECLARE_CLASS(QSocketNotifier)
 class ServerAcceptanceThread;
 #endif
 
+#ifdef QT_OPENHARMONY_BLUETOOTH
+#include "qjsaccess.h"
+
+class ServerAcceptanceThread;
+#endif
+
 #ifdef QT_WINRT_BLUETOOTH
 #include <QtCore/QMutex>
 
@@ -136,6 +142,15 @@ public:
     bool isListening() const;
     bool initiateActiveListening(const QBluetoothUuid& uuid, const QString &serviceName);
     bool deactivateActiveListening();
+#elif defined(QT_OPENHARMONY_BLUETOOTH)
+    ServerAcceptanceThread *thread;
+    QString m_serviceName;
+    QBluetoothUuid m_uuid;
+    QSharedPointer<QJsAccess> m_jsAccess;
+public:
+    bool isListening() const;
+    bool initiateActiveListening(const QBluetoothUuid& uuid, const QString &serviceName);
+    bool deactivateActiveListening();
 #elif defined(QT_WINRT_BLUETOOTH)
     EventRegistrationToken connectionToken {-1};
 
diff --git a/src/bluetooth/qbluetoothservicediscoveryagent.cpp b/src/bluetooth/qbluetoothservicediscoveryagent.cpp
index e76c2311..74e78b2b 100644
--- a/src/bluetooth/qbluetoothservicediscoveryagent.cpp
+++ b/src/bluetooth/qbluetoothservicediscoveryagent.cpp
@@ -435,8 +435,7 @@ QString QBluetoothServiceDiscoveryAgent::errorString() const
 
     This signal is triggered when the service discovery was canceled via a call to \l stop().
  */
-
-
+#include <QTimer>
 /*!
     Starts device discovery.
 */
@@ -454,6 +453,10 @@ void QBluetoothServiceDiscoveryAgentPrivate::startDeviceDiscovery()
                          q, [this](){
             this->_q_deviceDiscoveryFinished();
         });
+        /* FIXME wanghao ohos蓝牙模块未提供扫描结束接口 */
+        QTimer::singleShot(2000, [this]{
+            this->_q_deviceDiscoveryFinished();
+        });
         QObject::connect(deviceDiscoveryAgent, &QBluetoothDeviceDiscoveryAgent::deviceDiscovered,
                          q, [this](const QBluetoothDeviceInfo &info){
             this->_q_deviceDiscovered(info);
@@ -466,8 +469,11 @@ void QBluetoothServiceDiscoveryAgentPrivate::startDeviceDiscovery()
     }
 
     setDiscoveryState(DeviceDiscovery);
-
-    deviceDiscoveryAgent->start(QBluetoothDeviceDiscoveryAgent::ClassicMethod);
+#ifdef QT_OPENHARMONY_BLUETOOTH
+    //deviceDiscoveryAgent->start(QBluetoothDeviceDiscoveryAgent::ClassicMethod);
+#else
+	deviceDiscoveryAgent->start(QBluetoothDeviceDiscoveryAgent::ClassicMethod);
+#endif
 }
 
 /*!
diff --git a/src/bluetooth/qbluetoothservicediscoveryagent_ohos.cpp b/src/bluetooth/qbluetoothservicediscoveryagent_ohos.cpp
new file mode 100644
index 00000000..7580dfe3
--- /dev/null
+++ b/src/bluetooth/qbluetoothservicediscoveryagent_ohos.cpp
@@ -0,0 +1,432 @@
+#include <QtCore/QTimer>
+#include <QtCore/QLoggingCategory>
+#include <QtCore/qcoreapplication.h>
+#include <QtBluetooth/QBluetoothHostInfo>
+#include <QtBluetooth/QBluetoothLocalDevice>
+#include <QtBluetooth/QBluetoothServiceDiscoveryAgent>
+
+#include "qbluetoothsocket_ohos_p.h"
+#include "qbluetoothservicediscoveryagent_p.h"
+#include "openharmony/openharmonyservicediscoveryreceiver_p.h"
+#include "openharmony/openharmonylocaldevicebroadcastreceiver_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+static int gi_count = 0;
+
+QBluetoothServiceDiscoveryAgentPrivate::QBluetoothServiceDiscoveryAgentPrivate(
+        QBluetoothServiceDiscoveryAgent *qp, const QBluetoothAddress &deviceAdapter)
+    : error(QBluetoothServiceDiscoveryAgent::NoError),
+      m_deviceAdapterAddress(deviceAdapter),
+      state(Inactive),
+      mode(QBluetoothServiceDiscoveryAgent::MinimalDiscovery),
+      singleDevice(false),
+      q_ptr(qp),
+      receiver(nullptr)
+{
+    // If a specific adapter address is requested we need to check it matches
+    // the current local adapter. If it does not match we emit
+    // InvalidBluetoothAdapterError when calling start()
+
+    bool createAdapter = true;
+    if (!deviceAdapter.isNull()) {
+        const QList<QBluetoothHostInfo> devices = QBluetoothLocalDevice::allDevices();
+        if (devices.isEmpty()) {
+            createAdapter = false;
+        } else {
+            auto match = [deviceAdapter](const QBluetoothHostInfo& info) {
+                return info.address() == deviceAdapter;
+            };
+
+            auto result = std::find_if(devices.begin(), devices.end(), match);
+            if (result == devices.end())
+                createAdapter = false;
+        }
+    }
+
+    /*
+      We assume that the current local adapter has been passed.
+      The logic below must change once there is more than one adapter.
+    */    
+    // if (createAdapter)
+    //     m_jsBtMgr = qJsObjectLoader->create("JsBluetoothManager");
+
+    // if (!m_jsBtMgr->isValid())
+    //     qCWarning(QT_BT_OPENHARMONY) << "Platform does not support Bluetooth";
+
+
+    qRegisterMetaType<QList<QBluetoothUuid> >();
+}
+
+QBluetoothServiceDiscoveryAgentPrivate::~QBluetoothServiceDiscoveryAgentPrivate()
+{
+    if (receiver) {
+        delete receiver;
+    }
+
+    if (localDeviceReceiver) {
+        delete localDeviceReceiver;
+    }
+}
+
+void QBluetoothServiceDiscoveryAgentPrivate::start(const QBluetoothAddress &address)
+{
+    Q_Q(QBluetoothServiceDiscoveryAgent);
+
+    // if (!m_jsBtMgr->isValid()) {
+        if (m_deviceAdapterAddress.isNull()) {
+            error = QBluetoothServiceDiscoveryAgent::UnknownError;
+            errorString = QBluetoothServiceDiscoveryAgent::tr("Platform does not support Bluetooth");
+        } else {
+            // specific adapter was requested which does not match the locally
+            // existing adapter
+            error = QBluetoothServiceDiscoveryAgent::InvalidBluetoothAdapterError;
+            errorString = QBluetoothServiceDiscoveryAgent::tr("Invalid Bluetooth adapter address");
+        }
+
+               //abort any outstanding discoveries
+        discoveredDevices.clear();
+        emit q->error(error);
+        _q_serviceDiscoveryFinished();
+
+        return;
+    // }
+//    qWarning() << "<<<<<<<<------111" << address.toString();
+//    QByteArray remoteDev = m_jsBtMgr->call<QByteArray>("getRemoteDeviceName", address.toString());
+//    qWarning() << "<<<<<<<<------111-2" << remoteDev;
+//    if (remoteDev.isEmpty()) {
+//        //if it was only device then its error -> otherwise go to next device
+//        if (singleDevice) {
+//            error = QBluetoothServiceDiscoveryAgent::InputOutputError;
+//            errorString = QBluetoothServiceDiscoveryAgent::tr("Cannot create Android BluetoothDevice");
+
+//            qCWarning(QT_BT_OPENHARMONY) << "Cannot start SDP for" << discoveredDevices.at(0).name()
+//                                         << "(" << address.toString() << ")";
+//            emit q->error(error);
+//        }
+//        _q_serviceDiscoveryFinished();
+//        return;
+//    }
+    if (mode == QBluetoothServiceDiscoveryAgent::MinimalDiscovery) {
+        qCDebug(QT_BT_OPENHARMONY) << "Minimal discovery on (" << discoveredDevices.at(0).name()
+                                   << ")" << address.toString();
+
+        /* TODO */
+        error = QBluetoothServiceDiscoveryAgent::UnknownError;
+        errorString = QBluetoothServiceDiscoveryAgent::tr("Platform does not support Bluetooth");
+
+        discoveredDevices.clear();
+        emit q->error(error);
+        _q_serviceDiscoveryFinished();
+        return;
+    } else {
+       qCDebug(QT_BT_OPENHARMONY) << "Full discovery on (" << discoveredDevices.at(0).name()
+                                  << ")" << address.toString();
+
+        //Full discovery uses BluetoothDevice.fetchUuidsWithSdp()
+        if (!receiver) {            
+            receiver = new OPenHarmonyServiceDiscoveryReceiver();
+            QString name = QString("QBluetoothServiceDiscoveryAgent_%1").arg(++gi_count);            
+            // m_jsBtMgr->call<bool>("createServiceAdapter", name, QVariant(qlonglong(static_cast<QObject*>(receiver))));
+            // m_jsAdapter = qJsObjectLoader->create(name);
+            QObject::connect(receiver, &OPenHarmonyServiceDiscoveryReceiver::uuidFetchFinished,
+                             q, [this](const QBluetoothAddress &address, const QList<QBluetoothUuid>& uuids) {
+                                 qWarning() << "<<<<<<<<------_q_processFetchedUuids" << address;
+                                 this->_q_processFetchedUuids(address, uuids);
+                             });
+        }
+
+        if (!localDeviceReceiver) {
+            localDeviceReceiver = new OPenHarmonyLocalDeviceBroadcastReceiver();
+            QObject::connect(localDeviceReceiver, &OPenHarmonyLocalDeviceBroadcastReceiver::hostModeStateChanged,
+                             q, [this](QBluetoothLocalDevice::HostMode state){
+                                 this->_q_hostModeStateChanged(state);
+                             });
+        }
+
+        //TODO：LL
+        // if (!m_jsAdapter->isValid())
+        //     return;
+
+        // bool ok = m_jsAdapter->call<bool>("createAdapter", address.toString());
+        // if (!ok) {
+        //     receiver->deleteLater();
+        //     receiver = nullptr;
+        //     qCWarning(QT_BT_OPENHARMONY) << "Cannot start dynamic fetch.";
+        //     _q_serviceDiscoveryFinished();
+        // }
+        // m_jsAdapter->callWithoutReturn("fetchService");
+    }
+}
+
+void QBluetoothServiceDiscoveryAgentPrivate::stop()
+{
+    sdpCache.clear();
+    discoveredDevices.clear();
+
+           //kill receiver to limit load of signals
+    //receiver->unregisterReceiver();
+    receiver->deleteLater();
+    receiver = nullptr;
+
+    Q_Q(QBluetoothServiceDiscoveryAgent);
+    emit q->canceled();
+}
+
+void QBluetoothServiceDiscoveryAgentPrivate::_q_processFetchedUuids(
+        const QBluetoothAddress &address, const QList<QBluetoothUuid> &uuids)
+{
+    //don't leave more data through if we are not interested anymore
+    if (discoveredDevices.count() == 0)
+        return;
+
+           //could not find any service for the current address/device -> go to next one
+    if (address.isNull() || uuids.isEmpty()) {
+        if (discoveredDevices.count() == 1) {
+            Q_Q(QBluetoothServiceDiscoveryAgent);
+            QTimer::singleShot(4000, q, [this]() {
+                this->_q_fetchUuidsTimeout();
+            });
+        }
+        _q_serviceDiscoveryFinished();
+        return;
+    }
+
+    if (QT_BT_OPENHARMONY().isDebugEnabled()) {
+        qCDebug(QT_BT_OPENHARMONY) << "Found UUID for" << address.toString()
+                                   << "\ncount: " << uuids.count();
+
+        QString result;
+        for (int i = 0; i<uuids.count(); i++)
+            result += uuids.at(i).toString() + QStringLiteral("**");
+        qCDebug(QT_BT_OPENHARMONY) << result;
+    }
+
+    /* In general there are two uuid events per device.
+     * We'll wait for the second event to arrive before we process the UUIDs.
+     * We utilize a timeout to catch cases when the second
+     * event doesn't arrive at all.
+     * Generally we assume that the second uuid event carries the most up-to-date
+     * set of uuids and discard the first events results.
+     */
+
+    if (sdpCache.contains(address)) {
+        //second event
+        QPair<QBluetoothDeviceInfo,QList<QBluetoothUuid> > pair = sdpCache.take(address);
+
+               //prefer second uuid set over first
+        populateDiscoveredServices(pair.first, uuids);
+
+        if (discoveredDevices.count() == 1 && sdpCache.isEmpty()) {
+            //last regular uuid data set from OS -> we finish here
+            _q_serviceDiscoveryFinished();
+        }
+    } else {
+        //first event
+        QPair<QBluetoothDeviceInfo,QList<QBluetoothUuid> > pair;
+        pair.first = discoveredDevices.at(0);
+        pair.second = uuids;
+
+        if (pair.first.address() != address)
+            return;
+
+        sdpCache.insert(address, pair);
+
+               //the discovery on the last device cannot immediately finish
+               //we have to grant the 2 seconds timeout delay
+        if (discoveredDevices.count() == 1) {
+            Q_Q(QBluetoothServiceDiscoveryAgent);
+            QTimer::singleShot(4000, q, [this]() {
+                this->_q_fetchUuidsTimeout();
+            });
+            return;
+        }
+
+        _q_serviceDiscoveryFinished();
+    }
+}
+
+void QBluetoothServiceDiscoveryAgentPrivate::populateDiscoveredServices(const QBluetoothDeviceInfo &remoteDevice, const QList<QBluetoothUuid> &uuids)
+{
+    /* Android doesn't provide decent SDP data. A flat list of uuids is all we get.
+     *
+     * The following approach is chosen:
+     * - If we see an SPP service class and we see
+     *   one or more custom uuids we match them up. Such services will always
+     *   be SPP services. There is the chance that a custom uuid is eronously
+     *   mapped as being an SPP service. In addition, the SPP uuid will be mapped as
+     *   standalone SPP service.
+     * - If we see a custom uuid but no SPP uuid then we return
+     *   BluetoothServiceInfo instance with just a serviceUuid (no service class set)
+     * - If we don't find any custom uuid but the SPP uuid, we return a
+     *   BluetoothServiceInfo instance where classId and serviceUuid() are set to SPP.
+     * - Any other service uuid will stand on its own.
+     * */
+
+    Q_Q(QBluetoothServiceDiscoveryAgent);
+
+           //find SPP and custom uuid
+    bool haveSppClass = false;
+    QVector<int> customUuids;
+
+    for (int i = 0; i < uuids.count(); i++) {
+        const QBluetoothUuid uuid = uuids.at(i);
+
+        if (uuid.isNull())
+            continue;
+
+               //check for SPP protocol
+        bool ok = false;
+        auto uuid16 = uuid.toUInt16(&ok);
+        haveSppClass |= ok && uuid16 == QBluetoothUuid::SerialPort;
+
+               //check for custom uuid
+        if (uuid.minimumSize() == 16)
+            customUuids.append(i);
+    }
+
+    auto rfcommProtocolDescriptorList = []() -> QBluetoothServiceInfo::Sequence {
+        QBluetoothServiceInfo::Sequence protocol;
+        protocol << QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::Rfcomm))
+                 << QVariant::fromValue(0);
+        return protocol;
+    };
+
+    auto sppProfileDescriptorList = []() -> QBluetoothServiceInfo::Sequence {
+        QBluetoothServiceInfo::Sequence profileSequence;
+        QBluetoothServiceInfo::Sequence classId;
+        classId << QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::SerialPort));
+        classId << QVariant::fromValue(quint16(0x100));
+        profileSequence.append(QVariant::fromValue(classId));
+        return profileSequence;
+    };
+
+    for (int i = 0; i < uuids.count(); i++) {
+        const QBluetoothUuid &uuid = uuids.at(i);
+        if (uuid.isNull())
+            continue;
+
+        QBluetoothServiceInfo serviceInfo;
+        serviceInfo.setDevice(remoteDevice);
+
+        QBluetoothServiceInfo::Sequence protocolDescriptorList;
+        {
+            QBluetoothServiceInfo::Sequence protocol;
+            protocol << QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::L2cap));
+            protocolDescriptorList.append(QVariant::fromValue(protocol));
+        }
+
+        if (customUuids.contains(i) && haveSppClass) {
+            //we have a custom uuid of service class type SPP
+
+                   //set rfcomm protocol
+            protocolDescriptorList.append(QVariant::fromValue(rfcommProtocolDescriptorList()));
+
+                   //set SPP profile descriptor list
+            serviceInfo.setAttribute(QBluetoothServiceInfo::BluetoothProfileDescriptorList,
+                                     sppProfileDescriptorList());
+
+            QBluetoothServiceInfo::Sequence classId;
+            //set SPP service class uuid
+            classId << QVariant::fromValue(uuid);
+            classId << QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::SerialPort));
+            serviceInfo.setAttribute(QBluetoothServiceInfo::ServiceClassIds, classId);
+
+            serviceInfo.setServiceName(QBluetoothServiceDiscoveryAgent::tr("Serial Port Profile"));
+            serviceInfo.setServiceUuid(uuid);
+        } else if (uuid == QBluetoothUuid{QBluetoothUuid::SerialPort}) {
+            //set rfcomm protocol
+            protocolDescriptorList.append(QVariant::fromValue(rfcommProtocolDescriptorList()));
+
+                   //set SPP profile descriptor list
+            serviceInfo.setAttribute(QBluetoothServiceInfo::BluetoothProfileDescriptorList,
+                                     sppProfileDescriptorList());
+
+                   //also we need to set the custom uuid to the SPP uuid
+                   //otherwise QBluetoothSocket::connectToService() would fail due to a missing service uuid
+            serviceInfo.setServiceUuid(uuid);
+        } else if (customUuids.contains(i)) {
+            //custom uuid but no serial port
+            serviceInfo.setServiceUuid(uuid);
+        }
+
+        serviceInfo.setAttribute(QBluetoothServiceInfo::ProtocolDescriptorList, protocolDescriptorList);
+        QBluetoothServiceInfo::Sequence publicBrowse;
+        publicBrowse << QVariant::fromValue(QBluetoothUuid(QBluetoothUuid::PublicBrowseGroup));
+        serviceInfo.setAttribute(QBluetoothServiceInfo::BrowseGroupList, publicBrowse);
+
+        if (!customUuids.contains(i)) {
+            //if we don't have custom uuid use it as class id as well
+            QBluetoothServiceInfo::Sequence classId;
+            classId << QVariant::fromValue(uuid);
+            serviceInfo.setAttribute(QBluetoothServiceInfo::ServiceClassIds, classId);
+            auto clsId = QBluetoothUuid::ServiceClassUuid(uuid.toUInt16());
+            serviceInfo.setServiceName(QBluetoothUuid::serviceClassToString(clsId));
+        }
+
+               //Check if the service is in the uuidFilter
+        if (!uuidFilter.isEmpty()) {
+            bool match = uuidFilter.contains(serviceInfo.serviceUuid());
+            match |= uuidFilter.contains(QBluetoothSocketPrivateOpenHarmony::reverseUuid(serviceInfo.serviceUuid()));
+            for (const auto &uuid : qAsConst(uuidFilter)) {
+                match |= serviceInfo.serviceClassUuids().contains(uuid);
+                match |= serviceInfo.serviceClassUuids().contains(QBluetoothSocketPrivateOpenHarmony::reverseUuid(uuid));
+            }
+
+            if (!match)
+                continue;
+        }
+
+               //don't include the service if we already discovered it before
+        if (!isDuplicatedService(serviceInfo)) {
+            discoveredServices << serviceInfo;
+            //qCDebug(QT_BT_OPENHARMONY) << serviceInfo;
+            emit q->serviceDiscovered(serviceInfo);
+        }
+    }
+}
+
+void QBluetoothServiceDiscoveryAgentPrivate::_q_fetchUuidsTimeout()
+{
+    if (sdpCache.isEmpty())
+        return;
+
+    QPair<QBluetoothDeviceInfo,QList<QBluetoothUuid> > pair;
+    const QList<QBluetoothAddress> keys = sdpCache.keys();
+    for (const QBluetoothAddress &key : keys) {
+        pair = sdpCache.take(key);
+        populateDiscoveredServices(pair.first, pair.second);
+    }
+
+    Q_ASSERT(sdpCache.isEmpty());
+
+           //kill receiver to limit load of signals
+    //receiver->unregisterReceiver();
+    receiver->deleteLater();
+    receiver = nullptr;
+    _q_serviceDiscoveryFinished();
+}
+
+void QBluetoothServiceDiscoveryAgentPrivate::_q_hostModeStateChanged(QBluetoothLocalDevice::HostMode state)
+{
+    if (discoveryState() == QBluetoothServiceDiscoveryAgentPrivate::ServiceDiscovery &&
+        state == QBluetoothLocalDevice::HostPoweredOff ) {
+
+        discoveredDevices.clear();
+        sdpCache.clear();
+        error = QBluetoothServiceDiscoveryAgent::PoweredOffError;
+        errorString = QBluetoothServiceDiscoveryAgent::tr("Device is powered off");
+
+               //kill receiver to limit load of signals
+        //receiver->unregisterReceiver();
+        receiver->deleteLater();
+        receiver = nullptr;
+
+        Q_Q(QBluetoothServiceDiscoveryAgent);
+        emit q->error(error);
+        _q_serviceDiscoveryFinished();
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/qbluetoothservicediscoveryagent_p.h b/src/bluetooth/qbluetoothservicediscoveryagent_p.h
index 40321c55..d7a6595e 100644
--- a/src/bluetooth/qbluetoothservicediscoveryagent_p.h
+++ b/src/bluetooth/qbluetoothservicediscoveryagent_p.h
@@ -105,6 +105,11 @@ class LocalDeviceBroadcastReceiver;
 #include <QtBluetooth/QBluetoothLocalDevice>
 #endif
 
+#ifdef QT_OPENHARMONY_BLUETOOTH
+class OPenHarmonyServiceDiscoveryReceiver;
+class OPenHarmonyLocalDeviceBroadcastReceiver;
+#endif
+
 #ifdef QT_WINRT_BLUETOOTH
 class QWinRTBluetoothServiceDiscoveryWorker;
 #endif
@@ -171,6 +176,14 @@ public:
     void _q_fetchUuidsTimeout();
     void _q_hostModeStateChanged(QBluetoothLocalDevice::HostMode state);
 #endif
+#ifdef QT_OPENHARMONY_BLUETOOTH
+    void _q_processFetchedUuids(const QBluetoothAddress &address, const QList<QBluetoothUuid> &uuids);
+
+    void populateDiscoveredServices(const QBluetoothDeviceInfo &remoteDevice,
+                                    const QList<QBluetoothUuid> &uuids);
+    void _q_fetchUuidsTimeout();
+    void _q_hostModeStateChanged(QBluetoothLocalDevice::HostMode state);
+#endif
 #ifdef QT_WIN_BLUETOOTH
     void _q_nextSdpScan(const QVariant &input);
     bool serviceMatches(const QBluetoothServiceInfo &info);
@@ -231,7 +244,14 @@ private:
     // scan result is received.
     QMap<QBluetoothAddress,QPair<QBluetoothDeviceInfo,QList<QBluetoothUuid> > > sdpCache;
 #endif
+#ifdef QT_OPENHARMONY_BLUETOOTH
+    OPenHarmonyServiceDiscoveryReceiver *receiver = nullptr;
+    OPenHarmonyLocalDeviceBroadcastReceiver *localDeviceReceiver = nullptr;
 
+    // QSharedPointer<QOpenHarmonyJsObject> m_jsBtMgr;
+    // QSharedPointer<QOpenHarmonyJsObject> m_jsAdapter;
+    QMap<QBluetoothAddress,QPair<QBluetoothDeviceInfo,QList<QBluetoothUuid> > > sdpCache;
+#endif
 #ifdef QT_WIN_BLUETOOTH
 private:
     bool pendingStop;
diff --git a/src/bluetooth/qbluetoothserviceinfo_ohos.cpp b/src/bluetooth/qbluetoothserviceinfo_ohos.cpp
new file mode 100644
index 00000000..1c59c713
--- /dev/null
+++ b/src/bluetooth/qbluetoothserviceinfo_ohos.cpp
@@ -0,0 +1,100 @@
+#include <QtCore/QLoggingCategory>
+
+#include "qbluetoothhostinfo.h"
+#include "qbluetoothlocaldevice.h"
+#include "qbluetoothserviceinfo.h"
+#include "qbluetoothserviceinfo_p.h"
+#include "qbluetoothserver_p.h"
+#include "qbluetoothserver.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+extern QHash<QBluetoothServerPrivate*, int> __fakeServerPorts;
+
+QBluetoothServiceInfoPrivate::QBluetoothServiceInfoPrivate()
+    :  registered(false)
+{
+}
+
+QBluetoothServiceInfoPrivate::~QBluetoothServiceInfoPrivate()
+{
+}
+
+bool QBluetoothServiceInfoPrivate::isRegistered() const
+{
+    return registered;
+}
+
+bool QBluetoothServiceInfoPrivate::unregisterService()
+{
+    if (!registered)
+        return false;
+
+    QBluetoothServerPrivate *sPriv = __fakeServerPorts.key(serverChannel());
+    if (!sPriv) {
+        //QBluetoothServer::close() was called without prior call to unregisterService().
+        //Now it is unregistered anyway.
+        registered = false;
+        return true;
+    }
+
+    bool result = sPriv->deactivateActiveListening();
+    if (!result)
+        return false;
+
+    registered = false;
+    return true;
+}
+
+bool QBluetoothServiceInfoPrivate::registerService(const QBluetoothAddress& localAdapter)
+{
+    const QList<QBluetoothHostInfo> localDevices = QBluetoothLocalDevice::allDevices();
+    if (!localDevices.count())
+        return false; //no Bluetooth device
+
+    if (!localAdapter.isNull()) {
+        bool found = false;
+        for (const QBluetoothHostInfo &hostInfo : localDevices) {
+            if (hostInfo.address() == localAdapter) {
+                found = true;
+                break;
+            }
+        }
+
+        if (!found) {
+            qCWarning(QT_BT_OPENHARMONY) << localAdapter.toString() << "is not a valid local Bt adapter";
+            return false;
+        }
+    }
+
+           //already registered on local adapter => nothing to do
+    if (registered)
+        return false;
+
+    if (protocolDescriptor(QBluetoothUuid::Rfcomm).isEmpty()) {
+        qCWarning(QT_BT_OPENHARMONY) << Q_FUNC_INFO << "Only RFCOMM services can be registered on Android";
+        return false;
+    }
+
+    QBluetoothServerPrivate *sPriv = __fakeServerPorts.key(serverChannel());
+    if (!sPriv)
+        return false;
+
+           //tell the server what service name and uuid our listener should have
+           //and start the real listener
+    bool result = sPriv->initiateActiveListening(
+            attributes.value(QBluetoothServiceInfo::ServiceId).value<QBluetoothUuid>(),
+            attributes.value(QBluetoothServiceInfo::ServiceName).toString());
+    if (!result) {
+        return false;
+    }
+
+
+    registered = true;
+    return true;
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/qbluetoothsocket.cpp b/src/bluetooth/qbluetoothsocket.cpp
index 9da67272..0ee28dbe 100644
--- a/src/bluetooth/qbluetoothsocket.cpp
+++ b/src/bluetooth/qbluetoothsocket.cpp
@@ -45,6 +45,8 @@
 #include "bluez/bluez5_helper_p.h"
 #elif defined(QT_ANDROID_BLUETOOTH)
 #include "qbluetoothsocket_android_p.h"
+#elif defined(QT_OPENHARMONY_BLUETOOTH)
+#include "qbluetoothsocket_ohos_p.h"
 #elif defined(QT_WINRT_BLUETOOTH)
 #include "qbluetoothsocket_winrt_p.h"
 #elif defined(QT_WIN_BLUETOOTH)
@@ -274,6 +276,8 @@ static QBluetoothSocketBasePrivate *createSocketPrivate()
     }
 #elif defined(QT_ANDROID_BLUETOOTH)
     return new QBluetoothSocketPrivateAndroid();
+#elif defined(QT_OPENHARMONY_BLUETOOTH)
+    return new QBluetoothSocketPrivateOpenHarmony();
 #elif defined(QT_WINRT_BLUETOOTH)
     return new QBluetoothSocketPrivateWinRT();
 #elif defined(QT_WIN_BLUETOOTH)
diff --git a/src/bluetooth/qbluetoothsocket.h b/src/bluetooth/qbluetoothsocket.h
index 8d35f77e..731987d7 100644
--- a/src/bluetooth/qbluetoothsocket.h
+++ b/src/bluetooth/qbluetoothsocket.h
@@ -70,6 +70,7 @@ class Q_BLUETOOTH_EXPORT QBluetoothSocket : public QIODevice
     friend class QBluetoothSocketPrivateDummy;
     friend class QBluetoothSocketPrivateWin;
     friend class QBluetoothSocketPrivateWinRT;
+    friend class QBluetoothSocketPrivateOpenHarmony;
 
 public:
 
diff --git a/src/bluetooth/qbluetoothsocket_ohos.cpp b/src/bluetooth/qbluetoothsocket_ohos.cpp
new file mode 100644
index 00000000..60895bfe
--- /dev/null
+++ b/src/bluetooth/qbluetoothsocket_ohos.cpp
@@ -0,0 +1,513 @@
+#include "qbluetoothsocket.h"
+#include "qbluetoothsocket_ohos_p.h"
+#include "qbluetoothaddress.h"
+#include "qbluetoothdeviceinfo.h"
+#include "qbluetoothserviceinfo.h"
+#include "openharmony/bluetoothdatareceiver_p.h"
+#include <QtCore/QLoggingCategory>
+// #include <QtCore/QOpenHarmonyJsObject>
+// #include <QtCore/QOpenHarmonyJsObjectLoader>
+#include <QtCore/QThread>
+#include <QtCore/QTime>
+
+#include "syscap_ndk.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY);
+
+
+class SocketConnectWorker : public QObject
+{
+    Q_OBJECT
+public:
+    SocketConnectWorker(QSharedPointer<QJsSocket> jsSocket,
+                        const QString &deviceId, const QString &uuid, bool secure, int sppType)
+        : QObject(),
+          m_socketObject(jsSocket),
+          m_deviceId(deviceId),
+          m_uuid(uuid),
+          m_secure(secure),
+          m_sppType(sppType)
+    {
+    }
+
+signals:
+    void socketConnectDone(QSharedPointer<QJsSocket> jsSocket);
+    void socketConnectFailed(QSharedPointer<QJsSocket> jsSocket);
+
+public slots:
+    void connectSocket()
+    {
+        qCDebug(QT_BT_OPENHARMONY) << "Connecting socket";
+        if (!m_socketObject->connect(m_deviceId, m_uuid, m_secure, m_sppType)) {
+            emit socketConnectFailed(m_socketObject);
+            QThread::currentThread()->quit();
+            return;
+        }
+        qCDebug(QT_BT_OPENHARMONY) << "Socket connection established";
+        emit socketConnectDone(m_socketObject);
+    }
+
+    void closeSocket()
+    {
+        qCDebug(QT_BT_OPENHARMONY) << "Executing queued closeSocket()";
+
+        if (!m_socketObject->closeClient()) {
+            qCWarning(QT_BT_OPENHARMONY) << "Error during closure of abandoned socket";
+        }
+
+        QThread::currentThread()->quit();
+    }
+
+private:
+    QSharedPointer<QJsSocket> m_socketObject;
+    QString m_deviceId;
+    QString m_uuid;
+    bool m_secure;
+    int m_sppType;
+};
+
+class WorkerThread: public QThread
+{
+    Q_OBJECT
+public:
+    WorkerThread()
+        : QThread(),
+          m_workerPointer(nullptr)
+    {
+    }
+
+    // Runs in same thread as QBluetoothSocketPrivateOpenHarmony
+    void setupWorker(QBluetoothSocketPrivateOpenHarmony* d_ptr,
+                     QSharedPointer<QJsSocket> jsSocket,
+                     const QString &deviceId, const QString &uuid, bool secure, int sppType)
+    {
+        SocketConnectWorker* worker = new SocketConnectWorker(jsSocket, deviceId, uuid, secure, sppType);
+        worker->moveToThread(this);
+
+        connect(this, &QThread::finished, worker, &QObject::deleteLater);
+        connect(this, &QThread::finished, this, &QObject::deleteLater);
+        connect(d_ptr, &QBluetoothSocketPrivateOpenHarmony::connectJsSocket,
+                worker, &SocketConnectWorker::connectSocket);
+        connect(d_ptr, &QBluetoothSocketPrivateOpenHarmony::closeJsSocket,
+                worker, &SocketConnectWorker::closeSocket);
+        connect(worker, &SocketConnectWorker::socketConnectDone,
+                d_ptr, &QBluetoothSocketPrivateOpenHarmony::socketConnectSuccess);
+        connect(worker, &SocketConnectWorker::socketConnectFailed,
+                d_ptr, &QBluetoothSocketPrivateOpenHarmony::defaultSocketConnectFailed);
+
+        m_workerPointer = worker;
+    }
+
+private:
+    QPointer<SocketConnectWorker> m_workerPointer;
+};
+
+QBluetoothSocketPrivateOpenHarmony::QBluetoothSocketPrivateOpenHarmony()
+    : m_receiver(nullptr),
+      m_jsSocket(nullptr),
+      m_jsAccess(nullptr),
+      m_jsConnect(nullptr)
+{
+    secFlags = QBluetooth::Secure;
+
+    m_jsConnect = QSharedPointer<QJsConnect>::create();
+    qRegisterMetaType<QBluetoothSocket::SocketError>();
+    qRegisterMetaType<QBluetoothSocket::SocketState>();
+}
+
+QBluetoothSocketPrivateOpenHarmony::~QBluetoothSocketPrivateOpenHarmony()
+{
+    if (state != QBluetoothSocket::UnconnectedState)
+        emit closeJsSocket();
+}
+
+bool QBluetoothSocketPrivateOpenHarmony::ensureNativeSocket(QBluetoothServiceInfo::Protocol type)
+{
+    socketType = type;
+    if (socketType == QBluetoothServiceInfo::RfcommProtocol)
+        return true;
+
+    return false;
+}
+
+void QBluetoothSocketPrivateOpenHarmony::connectToServiceHelper(const QBluetoothAddress &address,
+                                               const QBluetoothUuid &uuid,
+                                               QIODevice::OpenMode openMode)
+{
+    Q_Q(QBluetoothSocket);
+    Q_UNUSED(openMode);
+
+    qCDebug(QT_BT_OPENHARMONY) << "connectToServiceHelper()" << address.toString() << uuid.toString();
+
+    q->setSocketState(QBluetoothSocket::ConnectingState);
+
+    bool isSupport = canIUse("SystemCapability.Communication.Bluetooth.Core");
+    if (!isSupport) {
+        qCWarning(QT_BT_OPENHARMONY) << "Device does not support Bluetooth";
+        errorString = QBluetoothSocket::tr("Device does not support Bluetooth");
+        q->setSocketError(QBluetoothSocket::NetworkError);
+        q->setSocketState(QBluetoothSocket::UnconnectedState);
+        return;
+    }
+
+    if(!m_jsAccess)
+        m_jsAccess = QSharedPointer<QJsAccess>::create();
+
+    const QJsAccess::BluetoothState state = m_jsAccess->getState();
+    if (state !=  QJsAccess::STATE_ON) {
+        qCWarning(QT_BT_OPENHARMONY) << "Bt device offline";
+        errorString = QBluetoothSocket::tr("Device is powered off");
+        q->setSocketError(QBluetoothSocket::NetworkError);
+        q->setSocketState(QBluetoothSocket::UnconnectedState);
+        return;
+    }
+
+    if(!m_jsSocket)
+        m_jsSocket = QSharedPointer<QJsSocket>::create();
+
+    //cut leading { and trailing } {xxx-xxx}
+    QString tempUuid = uuid.toString();
+    tempUuid.chop(1); //remove trailing '}'
+    tempUuid.remove(0, 1); //remove first '{'
+
+    WorkerThread *workerThread = new WorkerThread();
+    workerThread->setupWorker(this, m_jsSocket, address.toString(), tempUuid, secFlags != QBluetooth::NoSecurity, 0);
+    workerThread->start();
+    emit connectJsSocket();
+}
+
+void QBluetoothSocketPrivateOpenHarmony::connectToService(
+        const QBluetoothServiceInfo &service, QIODevice::OpenMode openMode)
+{
+    Q_Q(QBluetoothSocket);
+
+    if (q->state() != QBluetoothSocket::UnconnectedState
+            && q->state() != QBluetoothSocket::ServiceLookupState) {
+        qCWarning(QT_BT_OPENHARMONY) << "QBluetoothSocketPrivateOpenHarmony::connectToService called on busy socket";
+        errorString = QBluetoothSocket::tr("Trying to connect while connection is in progress");
+        q->setSocketError(QBluetoothSocket::OperationError);
+        return;
+    }
+
+    auto protocol = service.socketProtocol();
+    switch (protocol) {
+    case QBluetoothServiceInfo::L2capProtocol:
+    case QBluetoothServiceInfo::UnknownProtocol:
+        qCWarning(QT_BT_OPENHARMONY) << "Changing socket protocol to RFCOMM";
+        protocol = QBluetoothServiceInfo::RfcommProtocol;
+        break;
+    case QBluetoothServiceInfo::RfcommProtocol:
+        break;
+    }
+
+    if (!ensureNativeSocket(protocol)) {
+        errorString = QBluetoothSocket::tr("Socket type not supported");
+        q->setSocketError(QBluetoothSocket::UnsupportedProtocolError);
+        return;
+    }
+    connectToServiceHelper(service.device().address(), service.serviceUuid(), openMode);
+}
+
+void QBluetoothSocketPrivateOpenHarmony::connectToService(
+        const QBluetoothAddress &address, const QBluetoothUuid &uuid,
+        QIODevice::OpenMode openMode)
+{
+    Q_Q(QBluetoothSocket);
+
+    if (q->state() != QBluetoothSocket::UnconnectedState) {
+        qCWarning(QT_BT_OPENHARMONY) << "QBluetoothSocketPrivateOpenHarmony::connectToService called on busy socket";
+        errorString = QBluetoothSocket::tr("Trying to connect while connection is in progress");
+        q->setSocketError(QBluetoothSocket::OperationError);
+        return;
+    }
+
+    if (q->socketType() == QBluetoothServiceInfo::UnknownProtocol) {
+        qCWarning(QT_BT_OPENHARMONY) << "QBluetoothSocketPrivateOpenHarmony::connectToService cannot "
+                                  "connect with 'UnknownProtocol' (type provided by given service)";
+        errorString = QBluetoothSocket::tr("Socket type not supported");
+        q->setSocketError(QBluetoothSocket::UnsupportedProtocolError);
+        return;
+    }
+
+    if (!ensureNativeSocket(q->socketType())) {
+        errorString = QBluetoothSocket::tr("Socket type not supported");
+        q->setSocketError(QBluetoothSocket::UnsupportedProtocolError);
+        return;
+    }
+    connectToServiceHelper(address, uuid, openMode);
+}
+
+void QBluetoothSocketPrivateOpenHarmony::connectToService(
+        const QBluetoothAddress &address, quint16 port, QIODevice::OpenMode openMode)
+{
+    Q_UNUSED(port);
+    Q_UNUSED(openMode);
+    Q_UNUSED(address);
+
+    Q_Q(QBluetoothSocket);
+
+    errorString = tr("Connecting to port is not supported");
+    q->setSocketError(QBluetoothSocket::ServiceNotFoundError);
+    qCWarning(QT_BT_OPENHARMONY) << "Connecting to port is not supported";
+}
+
+void QBluetoothSocketPrivateOpenHarmony::socketConnectSuccess(QSharedPointer<QJsSocket> jsSocket)
+{
+    Q_Q(QBluetoothSocket);
+
+    // test we didn't get a success from a previous connect
+    // which was cleaned up late
+    if (jsSocket != m_jsSocket)
+        return;
+
+
+    m_receiver = new BluetoothDataReceiver(this);
+    QObject::connect(m_receiver, SIGNAL(dataAvailable()),
+                     q, SIGNAL(readyRead()), Qt::QueuedConnection);
+
+    q->setOpenMode(QIODevice::ReadWrite|QIODevice::Unbuffered);
+
+    q->setSocketState(QBluetoothSocket::ConnectedState);
+}
+
+void QBluetoothSocketPrivateOpenHarmony::defaultSocketConnectFailed(QSharedPointer<QJsSocket> jsSocket)
+{
+    Q_Q(QBluetoothSocket);
+
+    // test we didn't get a fail from a previous connect
+    // which was cleaned up late - should be same socket
+    if (m_jsSocket != jsSocket)
+        return;
+
+    errorString = QBluetoothSocket::tr("Connection to service failed");
+
+    m_jsSocket.clear();
+
+    q->setSocketError(QBluetoothSocket::ServiceNotFoundError);
+    q->setSocketState(QBluetoothSocket::UnconnectedState);
+    qCWarning(QT_BT_OPENHARMONY) << "Workaround failed";
+}
+
+void QBluetoothSocketPrivateOpenHarmony::abort()
+{
+    if (state == QBluetoothSocket::UnconnectedState)
+        return;
+
+    if (m_jsSocket) {
+
+        emit closeJsSocket();
+
+        m_jsSocket.clear();
+
+        if (m_receiver) {
+            m_receiver = 0;
+            m_receiver->deleteLater();
+        } else {
+            Q_Q(QBluetoothSocket);
+            q->setOpenMode(QIODevice::NotOpen);
+            q->setSocketState(QBluetoothSocket::UnconnectedState);
+            emit q->readChannelFinished();
+        }
+    }
+}
+
+QString QBluetoothSocketPrivateOpenHarmony::localName() const
+{
+    if (!m_jsConnect)
+        return QString();
+
+    return m_jsConnect->localName();
+}
+
+QBluetoothAddress QBluetoothSocketPrivateOpenHarmony::localAddress() const
+{
+    if (!m_jsSocket)
+        return QBluetoothAddress();
+
+    QString result = m_jsSocket->localAddress();
+    return QBluetoothAddress(result);
+}
+
+quint16 QBluetoothSocketPrivateOpenHarmony::localPort() const
+{
+    return 0;
+}
+
+QString QBluetoothSocketPrivateOpenHarmony::peerName() const
+{
+    if (!m_jsConnect)
+        return QString();
+
+    return m_jsConnect->remoteDeviceName(peerAddress().toString());
+}
+
+QBluetoothAddress QBluetoothSocketPrivateOpenHarmony::peerAddress() const
+{
+    if (!m_jsSocket)
+        return QBluetoothAddress();
+
+    const QString address = m_jsSocket->remoteAddress();
+    return QBluetoothAddress(address);
+}
+
+quint16 QBluetoothSocketPrivateOpenHarmony::peerPort() const
+{
+    // Impossible to get channel number with current openharmony API
+    return 0;
+}
+
+qint64 QBluetoothSocketPrivateOpenHarmony::writeData(const char *data, qint64 maxSize)
+{
+    //TODO implement buffered behavior (so far only unbuffered)
+    Q_Q(QBluetoothSocket);
+    if (state != QBluetoothSocket::ConnectedState || !m_jsSocket) {
+        qCWarning(QT_BT_OPENHARMONY) << "Socket::writeData: " << state;
+        errorString = QBluetoothSocket::tr("Cannot write while not connected");
+        q->setSocketError(QBluetoothSocket::OperationError);
+        return -1;
+    }
+
+    bool result = m_jsSocket->write(QByteArray(data));
+
+    if (!result) {
+        qCWarning(QT_BT_OPENHARMONY) << "Error while writing";
+        errorString = QBluetoothSocket::tr("Error during write on socket.");
+        q->setSocketError(QBluetoothSocket::NetworkError);
+        return -1;
+    }
+
+    emit q->bytesWritten(maxSize);
+    return maxSize;
+}
+
+qint64 QBluetoothSocketPrivateOpenHarmony::readData(char *data, qint64 maxSize)
+{
+    Q_Q(QBluetoothSocket);
+    if (state != QBluetoothSocket::ConnectedState || m_receiver == nullptr) {
+        qCWarning(QT_BT_OPENHARMONY) << "Socket::readData: " << state ;
+        errorString = QBluetoothSocket::tr("Cannot read while not connected");
+        q->setSocketError(QBluetoothSocket::OperationError);
+        return -1;
+    }
+
+    return m_receiver->readData(data, maxSize);
+}
+
+void QBluetoothSocketPrivateOpenHarmony::close()
+{
+    abort();
+}
+
+bool QBluetoothSocketPrivateOpenHarmony::setSocketDescriptor(int socketDescriptor, QBluetoothServiceInfo::Protocol socketType,
+                         QBluetoothSocket::SocketState socketState, QBluetoothSocket::OpenMode openMode)
+{
+#if 0
+    Q_UNUSED(socketDescriptor);
+    Q_UNUSED(socketType)
+    Q_UNUSED(socketState);
+    Q_UNUSED(openMode);
+    qCWarning(QT_BT_OPENHARMONY) << "No socket descriptor support on OPENHARMONY.";
+#endif
+
+    Q_Q(QBluetoothSocket);
+
+    if (q->state() != QBluetoothSocket::UnconnectedState || -1 == socketDescriptor)
+        return false;
+
+    if (!ensureNativeSocket(socketType))
+        return false;
+
+    QString name = QString::number(socketDescriptor);
+    //TODO：
+
+
+    // m_jsBluetoothSocket = qJsObjectLoader->create(name);
+    // if (!m_jsBluetoothSocket->isValid()) {
+    //     errorString = QBluetoothSocket::tr("Obtaining ts object for service failed");
+    //     q->setSocketError(QBluetoothSocket::NetworkError);
+    //     q->setSocketState(QBluetoothSocket::UnconnectedState);
+    //     return false;
+    // }
+
+    // m_jsBluetoothSocket->call<bool>("setSocketNumber", socketDescriptor);
+    // m_jsBluetoothSocket->call<bool>("setId", QVariant(qlonglong(static_cast<QObject*>(this))));
+    // m_names.insert(m_jsBluetoothSocket.data(), name);
+
+    if(!m_jsSocket){
+        errorString = QBluetoothSocket::tr("Obtaining ts object for service failed");
+        q->setSocketError(QBluetoothSocket::NetworkError);
+        q->setSocketState(QBluetoothSocket::UnconnectedState);
+        return false;
+    }
+
+    //TODO:LL
+    // WorkerThread *workerThread = new WorkerThread();
+    // workerThread->setupWorker(this, m_jsSocket, address.toString(), tempUuid, secFlags != QBluetooth::NoSecurity, 0);
+    // workerThread->start();
+
+    q->setOpenMode(openMode | QIODevice::Unbuffered);
+    q->setSocketState(socketState);
+
+    return true;
+}
+
+qint64 QBluetoothSocketPrivateOpenHarmony::bytesAvailable() const
+{
+    //We cannot access buffer directly as it is part of different thread
+    if (m_receiver)
+        return m_receiver->bytesAvailable();
+
+    return 0;
+}
+
+qint64 QBluetoothSocketPrivateOpenHarmony::bytesToWrite() const
+{
+    return 0; // nothing because always unbuffered
+}
+
+bool QBluetoothSocketPrivateOpenHarmony::start()
+{
+    if (!m_jsSocket)
+        return false;
+
+    std::function<void (QByteArray)> func = std::bind(&BluetoothDataReceiver::jsReadyRead, m_receiver, std::placeholders::_1);
+    return m_jsSocket->read(func);
+}
+
+/*
+ * This function is part of a workaround for QTBUG-61392
+ *
+ * Returns null uuid if the given \a serviceUuid is not a uuid
+ * derived from the Bluetooth base uuid.
+ */
+QBluetoothUuid QBluetoothSocketPrivateOpenHarmony::reverseUuid(const QBluetoothUuid &serviceUuid)
+{
+    if (serviceUuid.isNull())
+        return QBluetoothUuid();
+
+    bool isBaseUuid = false;
+    serviceUuid.toUInt32(&isBaseUuid);
+    if (isBaseUuid)
+        return serviceUuid;
+
+    const quint128 original = serviceUuid.toUInt128();
+    quint128 reversed;
+    for (int i = 0; i < 16; i++)
+        reversed.data[15-i] = original.data[i];
+    return QBluetoothUuid{reversed};
+}
+
+bool QBluetoothSocketPrivateOpenHarmony::canReadLine() const
+{
+    // We cannot access buffer directly as it is part of different thread
+    if (m_receiver)
+        return m_receiver->canReadLine();
+
+    return false;
+}
+
+QT_END_NAMESPACE
+
+#include <qbluetoothsocket_ohos.moc>
diff --git a/src/bluetooth/qbluetoothsocket_ohos_p.h b/src/bluetooth/qbluetoothsocket_ohos_p.h
new file mode 100644
index 00000000..bb582b09
--- /dev/null
+++ b/src/bluetooth/qbluetoothsocket_ohos_p.h
@@ -0,0 +1,81 @@
+#ifndef QBLUETOOTHSOCKET_OPENHARMONY_P_H
+#define QBLUETOOTHSOCKET_OPENHARMONY_P_H
+
+#include "qbluetoothsocketbase_p.h"
+#include <QtCore/QPointer>
+#include <QSharedPointer>
+#include <QHash>
+#include "qjsaccess.h"
+#include "qjssocket.h"
+#include "qjsconnect.h"
+
+QT_BEGIN_NAMESPACE
+class BluetoothDataReceiver;
+class QBluetoothSocketPrivateOpenHarmony final : public QBluetoothSocketBasePrivate
+{
+    Q_OBJECT
+    friend class QBluetoothServerPrivate;
+
+public:
+    QBluetoothSocketPrivateOpenHarmony();
+    ~QBluetoothSocketPrivateOpenHarmony() override;
+
+    //On openharmony we connect using the uuid not the port
+    void connectToServiceHelper(const QBluetoothAddress &address, const QBluetoothUuid &uuid,
+                          QIODevice::OpenMode openMode) override;
+
+    void connectToService(const QBluetoothServiceInfo &service,
+                          QIODevice::OpenMode openMode) override;
+    void connectToService(const QBluetoothAddress &address, const QBluetoothUuid &uuid,
+                          QIODevice::OpenMode openMode) override;
+    void connectToService(const QBluetoothAddress &address, quint16 port,
+                          QIODevice::OpenMode openMode) override;
+
+
+    bool ensureNativeSocket(QBluetoothServiceInfo::Protocol type) override;
+
+    QString localName() const override;
+    QBluetoothAddress localAddress() const override;
+    quint16 localPort() const override;
+
+    QString peerName() const override;
+    QBluetoothAddress peerAddress() const override;
+    quint16 peerPort() const override;
+
+    void abort() override;
+    void close() override;
+
+    qint64 writeData(const char *data, qint64 maxSize) override;
+    qint64 readData(char *data, qint64 maxSize) override;
+
+    bool setSocketDescriptor(int socketDescriptor, QBluetoothServiceInfo::Protocol socketType,
+                             QBluetoothSocket::SocketState socketState = QBluetoothSocket::ConnectedState,
+                             QBluetoothSocket::OpenMode openMode = QBluetoothSocket::ReadWrite) override;
+
+    qint64 bytesAvailable() const override;
+    bool canReadLine() const override;
+    qint64 bytesToWrite() const override;
+
+    bool start();
+
+    static QBluetoothUuid reverseUuid(const QBluetoothUuid &serviceUuid);
+
+    BluetoothDataReceiver *m_receiver;
+
+public slots:
+    void socketConnectSuccess(QSharedPointer<QJsSocket> jsSocket);
+    void defaultSocketConnectFailed(QSharedPointer<QJsSocket> jsSocket);
+
+signals:
+    void connectJsSocket();
+    void closeJsSocket();
+
+private:
+    QSharedPointer<QJsSocket> m_jsSocket;
+    QSharedPointer<QJsAccess> m_jsAccess;
+    QSharedPointer<QJsConnect> m_jsConnect;
+};
+
+QT_END_NAMESPACE
+
+#endif // QBLUETOOTHSOCKET_ANDROID_P_H
diff --git a/src/bluetooth/qbluetoothsocketbase_p.h b/src/bluetooth/qbluetoothsocketbase_p.h
index d1894e96..15267b68 100644
--- a/src/bluetooth/qbluetoothsocketbase_p.h
+++ b/src/bluetooth/qbluetoothsocketbase_p.h
@@ -122,7 +122,7 @@ public:
                              QBluetoothSocket::OpenMode openMode = QBluetoothSocket::ReadWrite) = 0;
 
 
-#if defined(QT_ANDROID_BLUETOOTH)
+#if defined(QT_ANDROID_BLUETOOTH) || defined(QT_OPENHARMONY_BLUETOOTH)
     virtual void connectToServiceHelper(const QBluetoothAddress &address, const QBluetoothUuid &uuid,
                           QIODevice::OpenMode openMode) = 0;
 #else
diff --git a/src/bluetooth/qbluetoothtransfermanager.cpp b/src/bluetooth/qbluetoothtransfermanager.cpp
index d84f726c..45005eef 100644
--- a/src/bluetooth/qbluetoothtransfermanager.cpp
+++ b/src/bluetooth/qbluetoothtransfermanager.cpp
@@ -122,7 +122,7 @@ QBluetoothTransferReply *QBluetoothTransferManager::put(const QBluetoothTransfer
     return reply;
 #else
     // Android, iOS, and Win/WinRT have no implementation
-#if !defined(QT_ANDROID_BLUETOOTH) && !defined(QT_IOS_BLUETOOTH) && !defined(QT_WINRT_BLUETOOTH) && !defined(QT_WIN_BLUETOOTH)
+#if !defined(QT_ANDROID_BLUETOOTH) && !defined(QT_IOS_BLUETOOTH) && !defined(QT_WINRT_BLUETOOTH) && !defined(QT_WIN_BLUETOOTH) && !defined(QT_OPENHARMONY_BLUETOOTH)
     printDummyWarning();
 #endif
     Q_UNUSED(request);
diff --git a/src/bluetooth/qlowenergycharacteristic.h b/src/bluetooth/qlowenergycharacteristic.h
index fe9b73fa..a0861ffc 100644
--- a/src/bluetooth/qlowenergycharacteristic.h
+++ b/src/bluetooth/qlowenergycharacteristic.h
@@ -98,6 +98,7 @@ protected:
     friend class QLowEnergyService;
     friend class QLowEnergyControllerPrivate;
     friend class QLowEnergyControllerPrivateAndroid;
+    friend class QLowEnergyControllerPrivateOpenHarmony;
     friend class QLowEnergyControllerPrivateBluez;
     friend class QLowEnergyControllerPrivateBluezDBus;
     friend class QLowEnergyControllerPrivateCommon;
diff --git a/src/bluetooth/qlowenergycontroller.cpp b/src/bluetooth/qlowenergycontroller.cpp
index b065555c..df1f09e3 100644
--- a/src/bluetooth/qlowenergycontroller.cpp
+++ b/src/bluetooth/qlowenergycontroller.cpp
@@ -55,6 +55,8 @@
 #elif defined(QT_ANDROID_BLUETOOTH)
 #include "qlowenergycontroller_android_p.h"
 #include "android/androidutils_p.h"
+#elif defined(QT_OPENHARMONY_BLUETOOTH)
+#include "qlowenergycontroller_ohos_p.h"
 #elif defined(QT_WINRT_BLUETOOTH)
 #include "qtbluetoothglobal_p.h"
 #include "qlowenergycontroller_winrt_p.h"
@@ -324,6 +326,8 @@ static QLowEnergyControllerPrivate *privateController(QLowEnergyController::Role
 #elif defined(QT_ANDROID_BLUETOOTH)
     Q_UNUSED(role);
     return new QLowEnergyControllerPrivateAndroid();
+#elif defined(QT_OPENHARMONY_BLUETOOTH)
+    return new QLowEnergyControllerPrivateOpenHarmony();
 #elif defined(QT_WINRT_BLUETOOTH)
     Q_UNUSED(role);
 #if QT_CONFIG(winrt_btle_no_pairing)
diff --git a/src/bluetooth/qlowenergycontroller_ohos.cpp b/src/bluetooth/qlowenergycontroller_ohos.cpp
new file mode 100644
index 00000000..7a1c7560
--- /dev/null
+++ b/src/bluetooth/qlowenergycontroller_ohos.cpp
@@ -0,0 +1,1156 @@
+#include <QtCore/QLoggingCategory>
+#include <QtBluetooth/QLowEnergyServiceData>
+#include <QtBluetooth/QLowEnergyCharacteristicData>
+#include <QtBluetooth/QLowEnergyDescriptorData>
+#include <QtBluetooth/QLowEnergyAdvertisingData>
+#include <QtBluetooth/QLowEnergyAdvertisingParameters>
+#include <QtBluetooth/QLowEnergyConnectionParameters>
+
+#include <qjsobject.h>
+
+#include "qlowenergycontroller_ohos_p.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(QT_BT_OPENHARMONY)
+
+static QString jsUuidfromQtUuid(const QBluetoothUuid& uuid)
+{
+    QString output = uuid.toString();
+    // cut off leading and trailing brackets
+    output = output.mid(1, output.size()-2);
+
+    return output;
+}
+
+
+QLowEnergyControllerPrivateOpenHarmony::QLowEnergyControllerPrivateOpenHarmony()
+    : QLowEnergyControllerPrivate(),
+      hub(0)
+{
+    registerQLowEnergyControllerMetaType();
+}
+
+QLowEnergyControllerPrivateOpenHarmony::~QLowEnergyControllerPrivateOpenHarmony()
+{
+    if (role == QLowEnergyController::PeripheralRole) {
+        if (hub)
+            // hub->jsObject()->callWithoutReturn("disconnectServer");
+            hub->jsGattServer()->close();
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::init()
+{
+    const bool isPeripheral = (role == QLowEnergyController::PeripheralRole);
+
+    if (isPeripheral) {
+
+        hub = new LowEnergyNotificationHub(remoteDevice, isPeripheral, this);
+        // we only connect to the peripheral role specific signals
+        // TODO add connections as they get added later on
+        connect(hub, &LowEnergyNotificationHub::connectionUpdated,
+                this, &QLowEnergyControllerPrivateOpenHarmony::connectionUpdated);
+        connect(hub, &LowEnergyNotificationHub::advertisementError,
+                this, &QLowEnergyControllerPrivateOpenHarmony::advertisementError);
+        connect(hub, &LowEnergyNotificationHub::serverCharacteristicChanged,
+                this, &QLowEnergyControllerPrivateOpenHarmony::serverCharacteristicChanged);
+        connect(hub, &LowEnergyNotificationHub::serverDescriptorWritten,
+                this, &QLowEnergyControllerPrivateOpenHarmony::serverDescriptorWritten);
+    } else {
+        hub = new LowEnergyNotificationHub(remoteDevice, isPeripheral, this);
+        // we only connect to the central role specific signals
+        connect(hub, &LowEnergyNotificationHub::connectionUpdated,
+                this, &QLowEnergyControllerPrivateOpenHarmony::connectionUpdated);
+        connect(hub, &LowEnergyNotificationHub::servicesDiscovered,
+                this, &QLowEnergyControllerPrivateOpenHarmony::servicesDiscovered);
+        connect(hub, &LowEnergyNotificationHub::serviceDetailsDiscoveryFinished,
+                this, &QLowEnergyControllerPrivateOpenHarmony::serviceDetailsDiscoveryFinished);
+        connect(hub, &LowEnergyNotificationHub::characteristicRead,
+                this, &QLowEnergyControllerPrivateOpenHarmony::characteristicRead);
+        connect(hub, &LowEnergyNotificationHub::descriptorRead,
+                this, &QLowEnergyControllerPrivateOpenHarmony::descriptorRead);
+        connect(hub, &LowEnergyNotificationHub::characteristicWritten,
+                this, &QLowEnergyControllerPrivateOpenHarmony::characteristicWritten);
+        connect(hub, &LowEnergyNotificationHub::descriptorWritten,
+                this, &QLowEnergyControllerPrivateOpenHarmony::descriptorWritten);
+        connect(hub, &LowEnergyNotificationHub::characteristicChanged,
+                this, &QLowEnergyControllerPrivateOpenHarmony::characteristicChanged);
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::connectToDevice()
+{
+    if (!hub)
+        return;
+
+    // required to pass unit test on default backend
+    if (remoteDevice.isNull()) {
+        qWarning() << "Invalid/null remote device address";
+        setError(QLowEnergyController::UnknownRemoteDeviceError);
+        return;
+    }
+
+    setState(QLowEnergyController::ConnectingState);
+
+    if (!hub->jsGattClientDevice()) {
+        qCWarning(QT_BT_OPENHARMONY) << "Cannot initiate QtBluetoothLE";
+        setError(QLowEnergyController::ConnectionError);
+        setState(QLowEnergyController::UnconnectedState);
+        return;
+    }
+
+    bool result = hub->jsGattClientDevice()->connect();
+    if (!result) {
+        setError(QLowEnergyController::ConnectionError);
+        setState(QLowEnergyController::UnconnectedState);
+        return;
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::disconnectFromDevice()
+{
+    QLowEnergyController::ControllerState oldState = state;
+    setState(QLowEnergyController::ClosingState);
+
+    if (hub) {
+        if (role == QLowEnergyController::PeripheralRole)
+            hub->jsGattServer()->close();
+        else
+            hub->jsGattClientDevice()->disconnect();
+    }
+
+    if (oldState == QLowEnergyController::ConnectingState)
+        setState(QLowEnergyController::UnconnectedState);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::discoverServices()
+{
+    bool success = false;
+    if(hub && hub->jsGattClientDevice()){
+        QString uuidsStr;
+        if(hub->jsGattClientDevice()->getServices(&uuidsStr)){
+            success = true;
+            servicesDiscovered(QLowEnergyController::NoError, uuidsStr);
+        }
+    }
+
+    if(!success){
+        //revert to connected state
+        setError(QLowEnergyController::NetworkError);
+        setState(QLowEnergyController::ConnectedState);
+    }
+}
+
+static int gattPropertyToInt(Napi::Object properties)
+{
+    int result;
+    if(!properties.IsObject())
+        return result;
+    if (properties.Get("write").ToBoolean()) {
+        result = 0x08;
+    }
+    if (properties.Get("writeNoResponse").ToBoolean()) {
+        result = result | 0x04;
+    }
+    if (properties.Get("read").ToBoolean()) {
+        result = result | 0x02;
+    }
+    if (properties.Get("notify").ToBoolean()) {
+        result = result | 0x10;
+    }
+    if (properties.Get("indicate").ToBoolean()) {
+        result = result | 0x20;
+    }
+    return result;
+}
+
+
+void QLowEnergyControllerPrivateOpenHarmony::discoverServiceDetails(const QBluetoothUuid &service)
+{
+    if (!serviceList.contains(service)) {
+        qCWarning(QT_BT_OPENHARMONY) << "Discovery of unknown service" << service.toString()
+                                 << "not possible";
+        return;
+    }
+
+    if (!hub)
+        return;
+
+    //cut leading { and trailing } {xxx-xxx}
+    QString tempUuid = service.toString();
+    tempUuid.chop(1); //remove trailing '}'
+    tempUuid.remove(0, 1); //remove first '{'
+
+    Napi::Array allGattService;
+    bool result = hub->jsGattClientDevice()->discoverServiceDetails(allGattService);
+    if (!result) {
+        QStringList uuidList;
+        for (uint32_t i = 0; i < allGattService.Length(); ++i) {
+            if(allGattService.Get(i).IsObject()){
+                Napi::Object gattService = allGattService.Get(i).As<Napi::Object>();
+                gattEntries << GattEntry{.type = GattService, .gattService = gattService};
+                QString uuidStr = QString::fromStdString(gattService.Get("serviceUuid").ToString());
+                uuidToGattEntry[uuidStr].append(gattEntries.count() - 1);
+                uuidList << uuidStr;
+
+                Napi::Array characteristics = gattService.Get("characteristics").As<Napi::Array>();
+                for(uint32_t j = 0; j < characteristics.Length(); ++j){
+                    if(characteristics.Get(j).IsObject()){
+                        Napi::Object characteristic = characteristics.Get(j).As<Napi::Object>();
+                        gattEntries << GattEntry{.type = Characteristic, .bleCharacteristic = characteristic};
+                        gattEntries << GattEntry{.type = CharacteristicValue};
+
+                        Napi::Array descriptors = characteristic.Get("descriptors").As<Napi::Array>();
+                        for(uint32_t k = 0; k < descriptors.Length(); ++k){
+                            if(descriptors.Get(k).IsObject()){
+                                Napi::Object descriptor = descriptors.Get(k).As<Napi::Object>();
+                                gattEntries << GattEntry{.type = Descriptor, .bleDescriptor = descriptor};
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        QString uuidsStr = uuidList.join(" ");
+        servicesDiscovered(QLowEnergyController::NoError, uuidsStr);
+
+        int handle;
+        if(uuidToGattEntry.contains(tempUuid)){
+            //取第一个
+            int index = uuidToGattEntry[tempUuid].at(0);
+            int handle = index + Characteristic - GattService;
+            GattEntry gattEntry = gattEntries.at(handle);
+            QString characteristicUuid = QString::fromStdString(gattEntry.bleCharacteristic.Get("characteristicUuid").ToString());
+            int properties = gattPropertyToInt(gattEntry.bleCharacteristic.Get("properties").ToObject());
+            Napi::ArrayBuffer arrayBuffer = gattEntry.bleCharacteristic.Get("characteristicValue").As<Napi::ArrayBuffer>();
+            size_t bufferSize = arrayBuffer.ByteLength();
+            QByteArray characteristicValue = QByteArray((char *)arrayBuffer.Data(), bufferSize);
+            characteristicRead(service, handle, QBluetoothUuid(characteristicUuid), properties, characteristicValue);
+
+
+            int descHandle = index + Descriptor - GattService;
+            gattEntry = gattEntries.at(descHandle);
+            characteristicUuid = QString::fromStdString(gattEntry.bleDescriptor.Get("characteristicUuid").ToString());
+            QString descriptorUuid = QString::fromStdString(gattEntry.bleDescriptor.Get("descriptorUuid").ToString());
+            arrayBuffer = gattEntry.bleDescriptor.Get("descriptorValue").As<Napi::ArrayBuffer>();
+            bufferSize = arrayBuffer.ByteLength();
+            QByteArray descriptorValue = QByteArray((char *)arrayBuffer.Data(), bufferSize);
+            descriptorRead(service, QBluetoothUuid(characteristicUuid), descHandle,
+                           QBluetoothUuid(descriptorUuid), descriptorValue);
+
+        }
+
+        QSharedPointer<QLowEnergyServicePrivate> servicePrivate =
+                serviceList.value(service);
+        if (!servicePrivate.isNull()) {
+            servicePrivate->setError(QLowEnergyService::UnknownError);
+            servicePrivate->setState(QLowEnergyService::DiscoveryRequired);
+        }
+        qCWarning(QT_BT_OPENHARMONY) << "Cannot discover details for" << service.toString();
+        return;
+    }
+
+    qCDebug(QT_BT_OPENHARMONY) << "Discovery of" << service << "started";
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::writeCharacteristic(
+        const QSharedPointer<QLowEnergyServicePrivate> service,
+        const QLowEnergyHandle charHandle,
+        const QByteArray &newValue,
+        QLowEnergyService::WriteMode mode)
+{
+    //TODO don't ignore WriteWithResponse, right now we assume responses
+    Q_ASSERT(!service.isNull());
+
+    if (!service->characteristicList.contains(charHandle))
+        return;
+
+    bool result = false;
+    if (hub) {
+        if (role == QLowEnergyController::CentralRole) {
+            qCDebug(QT_BT_OPENHARMONY) << "Write characteristic with handle " << charHandle
+                     << newValue.toHex() << "(service:" << service->uuid
+                     << ", writeWithResponse:" << (mode == QLowEnergyService::WriteWithResponse)
+                     << ", signed:" << (mode == QLowEnergyService::WriteSigned) << ")";
+            // result = hub->jsObject()->call<bool>("writeCharacteristic", charHandle, newValue, (int)mode);
+            GattEntry gattEntry = gattEntries.at(charHandle);
+            Napi::ArrayBuffer arrayBuffer = Napi::ArrayBuffer::New(QtOh::uiEnv(), newValue.size());
+            memcpy(arrayBuffer.Data(), newValue.data(), newValue.size());
+
+            gattEntry.bleCharacteristic.Set("characteristicValue", arrayBuffer);
+            int writeType = (mode == QLowEnergyService::WriteWithResponse) ? 2 : 1;
+            result = hub->jsGattClientDevice()->writeCharacteristicValue(gattEntry.bleCharacteristic, writeType);
+        } else { // peripheral mode
+            qCDebug(QT_BT_OPENHARMONY) << "Write server characteristic with handle " << charHandle
+                     << newValue.toHex() << "(service:" << service->uuid;
+
+            const auto &characteristic = characteristicForHandle(charHandle);
+            if (characteristic.isValid()) {
+                // result = hub->jsObject()->call<bool>(
+                //         "writeCharacteristic",
+                //         service->m_jsService, jsUuidfromQtUuid(characteristic.uuid()), newValue);
+
+                auto it = gattServices.constFind(service->m_jsService);
+                if (it != gattServices.constEnd()) {
+                    GattServiceEntry gattServiceEntry = it.value();
+                    Napi::Array characteristics = gattServiceEntry.gattService.Get("characteristics").As<Napi::Array>();
+                    for(int i = 0; i < characteristics.Length(); ++i){
+                        Napi::Object jsCharacteristic = characteristics.Get(i).As<Napi::Object>();
+                        if(jsUuidfromQtUuid(characteristic.uuid()) == QString::fromStdString(jsCharacteristic.Get("characteristicUuid").ToString())){
+                            Napi::ArrayBuffer characteristicValue = Napi::ArrayBuffer::New(QtOh::uiEnv(), newValue.size());
+                            memcpy(characteristicValue.Data(), newValue.data(), newValue.size());
+
+                            jsCharacteristic.Set("characteristicValue", characteristicValue);
+                            Napi::Object notifyCharacteristic = Napi::Object::New(QtOh::uiEnv());
+                            notifyCharacteristic.Set("serviceUuid", jsCharacteristic.Get("serviceUuid"));
+                            notifyCharacteristic.Set("characteristicUuid", jsCharacteristic.Get("characteristicUuid"));
+                            notifyCharacteristic.Set("characteristicValue", characteristicValue);
+                            notifyCharacteristic.Set("confirm", Napi::Boolean::New(QtOh::uiEnv(), false));
+                            hub->jsGattServer()->notifyCharacteristicChanged(notifyCharacteristic);
+                            break;
+                        }
+                    }
+                } else {
+                    result = false;
+                }
+            }
+        }
+    }
+
+    if (!result)
+        service->setError(QLowEnergyService::CharacteristicWriteError);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::writeDescriptor(
+        const QSharedPointer<QLowEnergyServicePrivate> service,
+        const QLowEnergyHandle charHandle,
+        const QLowEnergyHandle descHandle,
+        const QByteArray &newValue)
+{
+    Q_ASSERT(!service.isNull());
+
+    bool result = false;
+    if (hub) {
+        if (role == QLowEnergyController::CentralRole) {
+            qCDebug(QT_BT_OPENHARMONY) << "Write descriptor with handle " << descHandle
+                                       << newValue.toHex() << "(service:" << service->uuid << ")";
+            // result = hub->jsObject()->writeDescriptor((int)descHandle, newValue));
+            GattEntry gattEntry = gattEntries.at(charHandle);
+            Napi::ArrayBuffer arrayBuffer = Napi::ArrayBuffer::New(QtOh::uiEnv(), newValue.size());
+            memcpy(arrayBuffer.Data(), newValue.data(), newValue.size());
+
+            gattEntry.bleDescriptor.Set("descriptorValue", arrayBuffer);
+            result = hub->jsGattClientDevice()->writeDescriptorValue(gattEntry.bleDescriptor);
+        } else {
+            const auto &characteristic = characteristicForHandle(charHandle);
+            const auto &descriptor = descriptorForHandle(descHandle);
+            if (characteristic.isValid() && descriptor.isValid()) {
+                qCDebug(QT_BT_OPENHARMONY) << "Write descriptor" << descriptor.uuid()
+                << "(service:" << service->uuid
+                << "char: " << characteristic.uuid() << ")";
+                // result = hub->jsObject()->writeDescriptor(service->m_jsService, jsUuidfromQtUuid(characteristic.uuid()),
+                //                                           jsUuidfromQtUuid(descriptor.uuid()), newValue);
+
+                auto it = gattServices.constFind(service->m_jsService);
+                if (it != gattServices.constEnd()) {
+                    GattServiceEntry gattServiceEntry = it.value();
+                    Napi::Array characteristics = gattServiceEntry.gattService.Get("characteristics").As<Napi::Array>();
+                    for(int i = 0; i < characteristics.Length(); ++i){
+                        Napi::Object jsCharacteristic = characteristics.Get(i).As<Napi::Object>();
+                        if(jsUuidfromQtUuid(characteristic.uuid()) == QString::fromStdString(jsCharacteristic.Get("characteristicUuid").ToString())){
+                            Napi::Array descriptors = jsCharacteristic.Get("descriptors").As<Napi::Array>();
+                            for(int j = 0; j < descriptors.Length(); ++j){
+                                Napi::Object jsDescriptor = descriptors.Get(j).As<Napi::Object>();
+                                if(jsUuidfromQtUuid(descriptor.uuid()) == QString::fromStdString(jsDescriptor.Get("descriptorUuid").ToString())){
+                                    Napi::ArrayBuffer descriptorValue = Napi::ArrayBuffer::New(QtOh::uiEnv(), newValue.size());
+                                    memcpy(descriptorValue.Data(), newValue.data(), newValue.size());
+                                    jsDescriptor.Set("descriptorValue", descriptorValue);
+                                    break;
+                                }
+                            }
+                            break;
+                        }
+                    }
+                } else {
+                    result = false;
+                }
+            }
+        }
+    }
+
+    if (!result)
+        service->setError(QLowEnergyService::DescriptorWriteError);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::readCharacteristic(
+        const QSharedPointer<QLowEnergyServicePrivate> service,
+        const QLowEnergyHandle charHandle)
+{
+    Q_ASSERT(!service.isNull());
+
+    if (!service->characteristicList.contains(charHandle))
+        return;
+
+    bool result = false;
+    if (hub) {
+        qCDebug(QT_BT_OPENHARMONY) << "Read characteristic with handle"
+                                   <<  charHandle << service->uuid;
+        // result = hub->jsObject()->readCharacteristic(charHandle);
+        GattEntry gattEntry = gattEntries.at(charHandle);
+        Napi::Object outputCharacteristic = Napi::Object::New(QtOh::uiEnv());
+        result = hub->jsGattClientDevice()->readCharacteristicValue(gattEntry.bleCharacteristic, outputCharacteristic);
+        if(result){
+            QString serviceUuid = QString::fromStdString(outputCharacteristic.Get("serviceUuid").ToString());
+            QString characteristicUuid = QString::fromStdString(outputCharacteristic.Get("characteristicUuid").ToString());
+            int properties = gattPropertyToInt(outputCharacteristic.Get("properties").ToObject());
+            Napi::ArrayBuffer arrayBuffer = outputCharacteristic.Get("characteristicValue").As<Napi::ArrayBuffer>();
+            size_t bufferSize = arrayBuffer.ByteLength();
+            QByteArray characteristicValue = QByteArray((char *)arrayBuffer.Data(), bufferSize);
+            characteristicRead(QBluetoothUuid(serviceUuid), charHandle, QBluetoothUuid(characteristicUuid), properties, characteristicValue);
+        }
+    }
+
+    if (!result)
+        service->setError(QLowEnergyService::CharacteristicReadError);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::readDescriptor(
+        const QSharedPointer<QLowEnergyServicePrivate> service,
+        const QLowEnergyHandle /*charHandle*/,
+        const QLowEnergyHandle descriptorHandle)
+{
+    Q_ASSERT(!service.isNull());
+
+    bool result = false;
+    if (hub) {
+        qCDebug(QT_BT_OPENHARMONY) << "Read descriptor with handle"
+                                   <<  descriptorHandle << service->uuid;
+        // result = hub->jsGattClientDevice()->readDescriptorValue(descriptorHandle);
+
+        GattEntry gattEntry = gattEntries.at(descriptorHandle);
+        Napi::Object outputDescriptor = Napi::Object::New(QtOh::uiEnv());
+        result = hub->jsGattClientDevice()->readDescriptorValue(gattEntry.bleDescriptor, outputDescriptor);
+        if(result){
+            QString serviceUuid = QString::fromStdString(outputDescriptor.Get("serviceUuid").ToString());
+            QString characteristicUuid = QString::fromStdString(outputDescriptor.Get("characteristicUuid").ToString());
+            QString descriptorUuid = QString::fromStdString(outputDescriptor.Get("descriptorUuid").ToString());
+            Napi::ArrayBuffer arrayBuffer = outputDescriptor.Get("descriptorValue").As<Napi::ArrayBuffer>();
+            size_t bufferSize = arrayBuffer.ByteLength();
+            QByteArray descriptorValue = QByteArray((char *)arrayBuffer.Data(), bufferSize);
+            descriptorRead(QBluetoothUuid(serviceUuid), QBluetoothUuid(characteristicUuid), descriptorHandle,
+                           QBluetoothUuid(descriptorUuid), descriptorValue);
+        }
+    }
+
+    if (!result)
+        service->setError(QLowEnergyService::DescriptorReadError);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::connectionUpdated(
+        QLowEnergyController::ControllerState newState,
+        QLowEnergyController::Error errorCode)
+{
+    qCDebug(QT_BT_OPENHARMONY) << "Connection updated:"
+                           << "error:" << errorCode
+                           << "oldState:" << state
+                           << "newState:" << newState;
+
+    if (role == QLowEnergyController::PeripheralRole)
+        peripheralConnectionUpdated(newState, errorCode);
+    else
+        centralConnectionUpdated(newState, errorCode);
+}
+
+// called if server/peripheral
+void QLowEnergyControllerPrivateOpenHarmony::peripheralConnectionUpdated(
+        QLowEnergyController::ControllerState newState,
+        QLowEnergyController::Error errorCode)
+{
+    // Java errorCode can be larger than max QLowEnergyController::Error
+    if (errorCode > QLowEnergyController::AdvertisingError)
+        errorCode = QLowEnergyController::UnknownError;
+
+    if (errorCode != QLowEnergyController::NoError)
+        setError(errorCode);
+
+    const QLowEnergyController::ControllerState oldState = state;
+    setState(newState);
+
+    // disconnect implies stop of advertisement
+    if (newState == QLowEnergyController::UnconnectedState)
+        stopAdvertising();
+
+
+    Q_Q(QLowEnergyController);
+    if (oldState == QLowEnergyController::ConnectedState
+            && newState != QLowEnergyController::ConnectedState) {
+        remoteDevice.clear();
+        remoteName.clear();
+        emit q->disconnected();
+    } else if (newState == QLowEnergyController::ConnectedState
+                 && oldState != QLowEnergyController::ConnectedState) {
+        if (hub) {
+            remoteDevice = QBluetoothAddress(hub->jsGattServer()->remoteAddress());
+            remoteName = hub->jsGattServer()->remoteName();
+        }
+        emit q->connected();
+    }
+}
+
+// called if client/central
+void QLowEnergyControllerPrivateOpenHarmony::centralConnectionUpdated(
+        QLowEnergyController::ControllerState newState,
+        QLowEnergyController::Error errorCode)
+{
+    Q_Q(QLowEnergyController);
+
+    const QLowEnergyController::ControllerState oldState = state;
+
+    if (errorCode != QLowEnergyController::NoError) {
+        // ConnectionError if transition from Connecting to Connected
+        if (oldState == QLowEnergyController::ConnectingState) {
+            setError(QLowEnergyController::ConnectionError);
+            /* There is a bug in Android, when connecting to an unconnectable
+             * device. The connection times out and Android sends error code
+             * 133 (doesn't exist) and STATE_CONNECTED. A subsequent disconnect()
+             * call never sends a STATE_DISCONNECTED either.
+             * As workaround we will trigger disconnect when we encounter
+             * error during connect attempt. This leaves the controller
+             * in a cleaner state.
+             * */
+            newState = QLowEnergyController::UnconnectedState;
+        }
+        else
+            setError(errorCode);
+    }
+
+    setState(newState);
+    if (newState == QLowEnergyController::UnconnectedState
+            && !(oldState == QLowEnergyController::UnconnectedState
+                || oldState == QLowEnergyController::ConnectingState)) {
+
+        // Invalidate the services if the disconnect came from the remote end.
+        // Qtherwise we disconnected via QLowEnergyController::disconnectDevice() which
+        // triggered invalidation already
+        if (!serviceList.isEmpty()) {
+            Q_ASSERT(oldState != QLowEnergyController::ClosingState);
+            invalidateServices();
+        }
+        emit q->disconnected();
+    } else if (newState == QLowEnergyController::ConnectedState
+               && oldState != QLowEnergyController::ConnectedState ) {
+        emit q->connected();
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::servicesDiscovered(
+        QLowEnergyController::Error errorCode, const QString &foundServices)
+{
+    Q_Q(QLowEnergyController);
+
+    if (errorCode == QLowEnergyController::NoError) {
+        const QStringList list = foundServices.split(QStringLiteral(" "), QString::SkipEmptyParts);
+        for (const QString &entry : list) {
+            const QBluetoothUuid service(entry);
+            if (service.isNull())
+                return;
+
+            QLowEnergyServicePrivate *priv = new QLowEnergyServicePrivate();
+            priv->uuid = service;
+            priv->setController(this);
+
+            QSharedPointer<QLowEnergyServicePrivate> pointer(priv);
+            serviceList.insert(service, pointer);
+
+            emit q->serviceDiscovered(QBluetoothUuid(entry));
+        }
+
+        setState(QLowEnergyController::DiscoveredState);
+        emit q->discoveryFinished();
+    } else {
+        setError(errorCode);
+        setState(QLowEnergyController::ConnectedState);
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::serviceDetailsDiscoveryFinished(
+        const QString &serviceUuid, int startHandle, int endHandle)
+{
+    const QBluetoothUuid service(serviceUuid);
+    if (!serviceList.contains(service)) {
+        qCWarning(QT_BT_OPENHARMONY) << "Discovery done of unknown service:"
+                                 << service.toString();
+        return;
+    }
+
+    //update service data
+    QSharedPointer<QLowEnergyServicePrivate> pointer =
+            serviceList.value(service);
+    pointer->startHandle = startHandle;
+    pointer->endHandle = endHandle;
+
+    if (hub && hub->jsGattClientDevice()) {
+        QString jsIncludes = hub->jsGattClientDevice()->includedServices(serviceUuid);
+        if (!jsIncludes.isEmpty()) {
+            const QStringList list = jsIncludes.split(QStringLiteral(" "), QString::SkipEmptyParts);
+            for (const QString &entry : list) {
+                const QBluetoothUuid service(entry);
+                if (service.isNull())
+                    return;
+
+                pointer->includedServices.append(service);
+
+                // update the type of the included service
+                QSharedPointer<QLowEnergyServicePrivate> otherService =
+                        serviceList.value(service);
+                if (!otherService.isNull())
+                    otherService->type |= QLowEnergyService::IncludedService;
+            }
+        }
+    }
+
+    qCDebug(QT_BT_OPENHARMONY) << "Service" << serviceUuid << "discovered (start:"
+              << startHandle << "end:" << endHandle << ")" << pointer.data();
+
+    pointer->setState(QLowEnergyService::ServiceDiscovered);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::characteristicRead(
+        const QBluetoothUuid &serviceUuid, int handle,
+        const QBluetoothUuid &charUuid, int properties, const QByteArray &data)
+{
+    if (!serviceList.contains(serviceUuid))
+        return;
+
+    QSharedPointer<QLowEnergyServicePrivate> service =
+            serviceList.value(serviceUuid);
+    QLowEnergyHandle charHandle = handle;
+
+    QLowEnergyServicePrivate::CharData &charDetails =
+            service->characteristicList[charHandle];
+
+    //Android uses same property value as Qt which is the Bluetooth LE standard
+    charDetails.properties = QLowEnergyCharacteristic::PropertyType(properties);
+    charDetails.uuid = charUuid;
+    charDetails.value = data;
+    //value handle always one larger than characteristics value handle
+    charDetails.valueHandle = charHandle + 1;
+
+    if (service->state == QLowEnergyService::ServiceDiscovered) {
+        QLowEnergyCharacteristic characteristic = characteristicForHandle(charHandle);
+        if (!characteristic.isValid()) {
+            qCWarning(QT_BT_OPENHARMONY) << "characteristicRead: Cannot find characteristic";
+            return;
+        }
+        emit service->characteristicRead(characteristic, data);
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::descriptorRead(
+        const QBluetoothUuid &serviceUuid, const QBluetoothUuid &charUuid,
+        int descHandle, const QBluetoothUuid &descUuid, const QByteArray &data)
+{
+    if (!serviceList.contains(serviceUuid))
+        return;
+
+    QSharedPointer<QLowEnergyServicePrivate> service =
+            serviceList.value(serviceUuid);
+
+    bool entryUpdated = false;
+
+    CharacteristicDataMap::iterator charIt = service->characteristicList.begin();
+    for ( ; charIt != service->characteristicList.end(); ++charIt) {
+        QLowEnergyServicePrivate::CharData &charDetails = charIt.value();
+
+        if (charDetails.uuid != charUuid)
+            continue;
+
+        // new entry created if it doesn't exist
+        QLowEnergyServicePrivate::DescData &descDetails =
+                charDetails.descriptorList[descHandle];
+        descDetails.uuid = descUuid;
+        descDetails.value = data;
+        entryUpdated = true;
+        break;
+    }
+
+    if (!entryUpdated) {
+        qCWarning(QT_BT_OPENHARMONY) << "Cannot find/update descriptor"
+                                 << descUuid << charUuid << serviceUuid;
+    } else if (service->state == QLowEnergyService::ServiceDiscovered){
+        QLowEnergyDescriptor descriptor = descriptorForHandle(descHandle);
+        if (!descriptor.isValid()) {
+            qCWarning(QT_BT_OPENHARMONY) << "descriptorRead: Cannot find descriptor";
+            return;
+        }
+        emit service->descriptorRead(descriptor, data);
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::characteristicWritten(
+        int charHandle, const QByteArray &data, QLowEnergyService::ServiceError errorCode)
+{
+    QSharedPointer<QLowEnergyServicePrivate> service =
+            serviceForHandle(charHandle);
+    if (service.isNull())
+        return;
+
+    qCDebug(QT_BT_OPENHARMONY) << "Characteristic write confirmation" << service->uuid
+                           << charHandle << data.toHex() << errorCode;
+
+    if (errorCode != QLowEnergyService::NoError) {
+        service->setError(errorCode);
+        return;
+    }
+
+    QLowEnergyCharacteristic characteristic = characteristicForHandle(charHandle);
+    if (!characteristic.isValid()) {
+        qCWarning(QT_BT_OPENHARMONY) << "characteristicWritten: Cannot find characteristic";
+        return;
+    }
+
+    // only update cache when property is readable. Otherwise it remains
+    // empty.
+    if (characteristic.properties() & QLowEnergyCharacteristic::Read)
+        updateValueOfCharacteristic(charHandle, data, false);
+    emit service->characteristicWritten(characteristic, data);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::descriptorWritten(
+        int descHandle, const QByteArray &data, QLowEnergyService::ServiceError errorCode)
+{
+    QSharedPointer<QLowEnergyServicePrivate> service =
+            serviceForHandle(descHandle);
+    if (service.isNull())
+        return;
+
+    qCDebug(QT_BT_OPENHARMONY) << "Descriptor write confirmation" << service->uuid
+                           << descHandle << data.toHex() << errorCode;
+
+    if (errorCode != QLowEnergyService::NoError) {
+        service->setError(errorCode);
+        return;
+    }
+
+    QLowEnergyDescriptor descriptor = descriptorForHandle(descHandle);
+    if (!descriptor.isValid()) {
+        qCWarning(QT_BT_OPENHARMONY) << "descriptorWritten: Cannot find descriptor";
+        return;
+    }
+
+    updateValueOfDescriptor(descriptor.characteristicHandle(),
+                            descHandle, data, false);
+    emit service->descriptorWritten(descriptor, data);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::serverDescriptorWritten(
+        const QBluetoothUuid &serviceUuid, const QBluetoothUuid &characteristicUuid, const QBluetoothUuid &descriptorUuid, const QByteArray &newValue)
+{
+    qCDebug(QT_BT_OPENHARMONY) << "Server descriptor change notification" << newValue.toHex();
+
+    if (serviceUuid.isNull() || characteristicUuid.isNull() || descriptorUuid.isNull())
+        return;
+
+    if (!localServices.contains(serviceUuid))
+        return;
+
+    // find matching QLEDescriptor
+    auto servicePrivate = localServices.value(serviceUuid);
+    // TODO test if service contains two characteristics with same uuid
+    // or characteristic contains two descriptors with same uuid
+    const auto handleList = servicePrivate->characteristicList.keys();
+    for (const auto charHandle: handleList) {
+        const auto &charData = servicePrivate->characteristicList.value(charHandle);
+        if (charData.uuid != characteristicUuid)
+            continue;
+
+        const auto &descHandleList = charData.descriptorList.keys();
+        for (const auto descHandle: descHandleList) {
+            const auto &descData = charData.descriptorList.value(descHandle);
+            if (descData.uuid != descriptorUuid)
+                continue;
+
+            qCDebug(QT_BT_OPENHARMONY) << "serverDescriptorChanged: Matching descriptor"
+                                   << descriptorUuid << "in char" << characteristicUuid
+                                   << "of service" << serviceUuid;
+
+            servicePrivate->characteristicList[charHandle].descriptorList[descHandle].value = newValue;
+
+            emit servicePrivate->descriptorWritten(
+                        QLowEnergyDescriptor(servicePrivate, charHandle, descHandle),
+                        newValue);
+            return;
+        }
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::characteristicChanged(
+        int charHandle, const QByteArray &data)
+{
+    QSharedPointer<QLowEnergyServicePrivate> service =
+            serviceForHandle(charHandle);
+    if (service.isNull())
+        return;
+
+    qCDebug(QT_BT_OPENHARMONY) << "Characteristic change notification" << service->uuid
+                           << charHandle << data.toHex();
+
+    QLowEnergyCharacteristic characteristic = characteristicForHandle(charHandle);
+    if (!characteristic.isValid()) {
+        qCWarning(QT_BT_OPENHARMONY) << "characteristicChanged: Cannot find characteristic";
+        return;
+    }
+
+    // only update cache when property is readable. Otherwise it remains
+    // empty.
+    if (characteristic.properties() & QLowEnergyCharacteristic::Read)
+        updateValueOfCharacteristic(characteristic.attributeHandle(),
+                                data, false);
+    emit service->characteristicChanged(characteristic, data);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::serverCharacteristicChanged(
+        const QBluetoothUuid &serviceUuid, const QBluetoothUuid &characteristicUuid, const QByteArray &newValue)
+{
+    qCDebug(QT_BT_OPENHARMONY) << "Server characteristic change notification" << newValue.toHex();
+
+    if (serviceUuid.isNull())
+        return;
+
+    // TODO test if two service with same uuid exist
+    if (!localServices.contains(serviceUuid))
+        return;
+
+    auto servicePrivate = localServices.value(serviceUuid);
+    if (characteristicUuid.isNull())
+        return;
+
+    QLowEnergyHandle foundHandle = 0;
+    const auto handleList = servicePrivate->characteristicList.keys();
+    // TODO test if service contains two characteristics with same uuid
+    for (const auto handle: handleList) {
+        QLowEnergyServicePrivate::CharData &charData = servicePrivate->characteristicList[handle];
+        if (charData.uuid != characteristicUuid)
+            continue;
+
+        qCDebug(QT_BT_OPENHARMONY) << "serverCharacteristicChanged: Matching characteristic"
+                               << characteristicUuid << " on " << serviceUuid;
+        charData.value = newValue;
+        foundHandle = handle;
+        break;
+    }
+
+    if (!foundHandle)
+        return;
+
+    emit servicePrivate->characteristicChanged(
+                QLowEnergyCharacteristic(servicePrivate, foundHandle), newValue);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::serviceError(
+        int attributeHandle, QLowEnergyService::ServiceError errorCode)
+{
+    // ignore call if it isn't really an error
+    if (errorCode == QLowEnergyService::NoError)
+        return;
+
+    QSharedPointer<QLowEnergyServicePrivate> service =
+            serviceForHandle(attributeHandle);
+    Q_ASSERT(!service.isNull());
+
+    // ATM we don't really use attributeHandle but later on we might
+    // want to associate the error code with a char or desc
+    service->setError(errorCode);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::advertisementError(const QString &errorString)
+{
+    Q_Q(QLowEnergyController);
+
+    this->errorString = errorString;
+
+    error = QLowEnergyController::AdvertisingError;
+    emit q->error(error);
+
+    // not relevant states in peripheral mode
+    Q_ASSERT(state != QLowEnergyController::DiscoveredState);
+    Q_ASSERT(state != QLowEnergyController::DiscoveringState);
+
+    switch (state)
+    {
+    case QLowEnergyController::UnconnectedState:
+    case QLowEnergyController::ConnectingState:
+    case QLowEnergyController::ConnectedState:
+    case QLowEnergyController::ClosingState:
+        // noop as remote is already connected or about to disconnect.
+        // when connection drops we reset to unconnected anyway
+        break;
+
+    case QLowEnergyController::AdvertisingState:
+        setState(QLowEnergyController::UnconnectedState);
+        break;
+    default:
+        break;
+    }
+}
+
+static Napi::Object createJsAdvertiseData(const Napi::Env& env, const QLowEnergyAdvertisingData &data)
+{
+    Napi::Object jsAdvertisingData = Napi::Object::New(env);
+
+    QList<QBluetoothUuid> advertisingServices = data.services();
+    int servicesCount = advertisingServices.count();
+    Napi::Array jsUuids = Napi::Array::New(env, servicesCount);
+    int i = 0;
+
+    for (const auto service: advertisingServices){
+        jsUuids.Set(i++, Napi::String::New(env, jsUuidfromQtUuid(service).toStdString()));
+    }
+    jsAdvertisingData.Set("serviceUuids", jsUuids);
+
+    Napi::Array jsManufactureDataArr = Napi::Array::New(env);
+    if (!data.manufacturerData().isEmpty()) {
+        qWarning() << "!data.manufacturerData().isEmpty()";
+        Napi::Object jsManufactureData = Napi::Object::New(env);
+        jsManufactureData.Set("manufactureId", Napi::Number::New(env, (int)data.manufacturerId()));
+        qWarning() << "manufactureId" << (int)data.manufacturerId();
+        int dataSize = data.manufacturerData().size();
+        Napi::ArrayBuffer jsManufacturerDataAb = Napi::ArrayBuffer::New(env, dataSize);
+        memcpy(jsManufacturerDataAb.Data(), data.manufacturerData().data(), dataSize);
+        jsManufactureData.Set("manufactureValue", jsManufacturerDataAb);
+        jsManufactureDataArr.Set((int)0, jsManufactureData);
+    }
+    jsAdvertisingData.Set("manufactureData", jsManufactureDataArr);
+
+    Napi::Array jsServiceDataArr = Napi::Array::New(env);
+    // Napi::Object jsServiceData = Napi::Object::New(env);
+    // jsServiceData.Set("serviceUuid", jsUuids.Get((int)0).As<Napi::Array>());
+    // int size = data.manufacturerData().size();
+    // Napi::ArrayBuffer serviceValue = Napi::ArrayBuffer::New(env, size);
+    // memcpy(serviceValue.Data(), data.manufacturerData().data(), size);
+    // jsServiceData.Set("serviceValue", serviceValue);
+    // jsServiceDataArr.Set((int)0, jsServiceData);
+    jsAdvertisingData.Set("serviceData", jsServiceDataArr);
+    jsAdvertisingData.Set("includeDeviceName", Napi::Boolean::New(env, !data.localName().isEmpty()));
+
+    return jsAdvertisingData;
+
+    // QVariantMap result;
+    // result.insert("includeDeviceName", !data.localName().isEmpty());
+    // result.insert("includeTxPowerLevel", data.includePowerLevel());
+
+    // QStringList uuids;
+    // for (const auto service: data.services())
+    // {
+    //     uuids << jsUuidfromQtUuid(service);
+    // }
+    // result.insert("serviceUuids", uuids);
+
+    // if (!data.manufacturerData().isEmpty()) {
+    //     result.insert("manufacturerId", (int)data.manufacturerId());
+    //     result.insert("manufacturerData", data.manufacturerData());
+
+    // }
+
+    // return result;
+}
+
+static QVariantMap createJsAdvertiseSettings(const QLowEnergyAdvertisingParameters &params)
+{
+    QVariantMap result;
+
+    bool connectable = false;
+    switch (params.mode())
+    {
+    case QLowEnergyAdvertisingParameters::AdvInd:
+        connectable = true;
+        break;
+    case QLowEnergyAdvertisingParameters::AdvScanInd:
+    case QLowEnergyAdvertisingParameters::AdvNonConnInd:
+        connectable = false;
+        break;
+    // intentionally no default case
+    }
+    result.insert("connectable", connectable);
+    result.insert("maximumInterval", params.maximumInterval());
+
+    return result;
+}
+
+
+void QLowEnergyControllerPrivateOpenHarmony::startAdvertising(const QLowEnergyAdvertisingParameters &params,
+        const QLowEnergyAdvertisingData &advertisingData,
+        const QLowEnergyAdvertisingData &scanResponseData)
+{
+    setState(QLowEnergyController::AdvertisingState);
+
+    qDebug() << "ddddddddddddddddddddddddddddd" << !hub->jsBleObject();
+    if (!hub->jsBleObject()) {
+        qCWarning(QT_BT_OPENHARMONY) << "Cannot initiate QtBluetoothLEServer";
+        setError(QLowEnergyController::AdvertisingError);
+        setState(QLowEnergyController::UnconnectedState);
+        return;
+    }
+
+//     Pass on advertisingData, scanResponse & AdvertiseSettings
+    // QVariantMap jAdvertiseData = createJsAdvertiseData(advertisingData);
+    // QVariantMap jScanResponse = createJsAdvertiseData(scanResponseData);
+    // QVariantMap jAdvertiseSettings = createJsAdvertiseSettings(params);
+
+    Napi::Object advertisingParams = Napi::Object::New(QtOh::uiEnv());
+
+    Napi::Object advertiseSettings = Napi::Object::New(QtOh::uiEnv());
+    advertiseSettings.Set("interval", Napi::Number::New(QtOh::uiEnv(), params.maximumInterval()));
+    advertiseSettings.Set("connectable", Napi::Boolean::New(QtOh::uiEnv(),
+                                                           params.mode() == QLowEnergyAdvertisingParameters::AdvInd ? true : false));
+    Napi::Object jsAdvertisingData = createJsAdvertiseData(QtOh::uiEnv(), advertisingData);
+    Napi::Object jsAdvertisingResponse = createJsAdvertiseData(QtOh::uiEnv(), scanResponseData);
+
+    advertisingParams.Set("advertisingSettings", advertiseSettings);
+    advertisingParams.Set("advertisingData", jsAdvertisingData);
+    // advertisingParams.Set("advertisingResponse", jsAdvertisingResponse);
+    // advertisingParams.Set("duration", Napi::Number::New(QtOh::uiEnv(), 0));
+
+    const bool result = hub->jsBleObject()->startAdvertising(advertisingParams, advertisingId);
+    if (!result) {
+        setError(QLowEnergyController::AdvertisingError);
+        setState(QLowEnergyController::UnconnectedState);
+    }
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::stopAdvertising()
+{
+    setState(QLowEnergyController::UnconnectedState);
+    hub->jsBleObject()->stopAdvertising(advertisingId);
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::requestConnectionUpdate(const QLowEnergyConnectionParameters &params)
+{
+    if (role != QLowEnergyController::CentralRole) {
+        qCWarning(QT_BT_OPENHARMONY) << "On Openharmony, connection requests only work for central role";
+        return;
+    }
+
+    //Note：There are no relevant interfaces on openHarmony
+}
+
+void QLowEnergyControllerPrivateOpenHarmony::addToGenericAttributeList(const QLowEnergyServiceData &serviceData,
+                                                            QLowEnergyHandle startHandle)
+{
+    QSharedPointer<QLowEnergyServicePrivate> service = serviceForHandle(startHandle);
+    if (hub == nullptr || service.isNull())
+        return;
+
+    // create BluetoothGattService object
+    bool isPrimary = (serviceData.type() == QLowEnergyServiceData::ServiceTypePrimary);
+
+
+    static int index = 0;
+    QString name = QString("QLowEnergyControllerPrivateOpenHarmonyService%1").arg(index++);
+    // bool result = hub->jsObject()->call<bool>("createService", name, jsUuidfromQtUuid(service->uuid), isPrimary);
+
+
+    Napi::Object gattService = Napi::Object::New(QtOh::uiEnv());
+    QString jsUUidStr = jsUuidfromQtUuid(service->uuid);
+    gattService.Set("serviceUuid", Napi::String::New(QtOh::uiEnv(), jsUUidStr.toStdString()));
+    gattService.Set("isPrimary", Napi::Boolean::New(QtOh::uiEnv(), isPrimary));
+    Napi::Array characteristics = Napi::Array::New(QtOh::uiEnv());
+    gattService.Set("characteristics", characteristics);
+
+    gattServices[name] = GattServiceEntry{.uuid = jsUUidStr, .gattService = gattService};
+
+
+    // bool result = hub->jsGattServer()->createService(name, jsUuidfromQtUuid(service->uuid), isPrimary);
+    // QSharedPointer<QOpenHarmonyJsObject> jsService = qJsObjectLoader->create(name);
+    // if (result) {
+    //     if (!jsService->isValid()) {
+    //         qWarning(QT_BT_OPENHARMONY) << "Cannot init js gatt server ";
+    //         return;
+    //     }
+    // } else {
+    //     qWarning(QT_BT_OPENHARMONY) << "Cannot init js gatt server ";
+    //     return;
+    // }
+
+    service->m_jsService = name;
+
+//     add included services, which must have been added earlier already
+    const QList<QLowEnergyService*> includedServices = serviceData.includedServices();
+    for (const auto includedServiceEntry: includedServices) {
+        //TODO test this end-to-end
+        // result = hub->jsGattServer()->addIncludeService(includedServiceEntry->d_ptr->m_jsService);
+        bool result = hub->jsGattServer()->addService(gattServices[includedServiceEntry->d_ptr->m_jsService].gattService);
+        if (!result)
+            qWarning(QT_BT_OPENHARMONY) << "Cannot add included service " << includedServiceEntry->serviceUuid()
+                                    << "to current service" << service->uuid;
+    }
+
+    // add characteristics
+    const QList<QLowEnergyCharacteristicData> serviceCharsData = serviceData.characteristics();
+    for (const auto &charData: serviceCharsData) {
+        // result = jsService->call<bool>("addCharacteristic", jsUuidfromQtUuid(charData.uuid()), int(charData.properties()), charData.value());
+        int properties = int(charData.properties());
+        Napi::Object gattProperties = Napi::Object::New(QtOh::uiEnv());
+        gattProperties.Set("write", Napi::Boolean::New(QtOh::uiEnv(), (properties & 0x08) != 0));
+        gattProperties.Set("writeNoResponse", Napi::Boolean::New(QtOh::uiEnv(), (properties & 0x04) != 0));
+        gattProperties.Set("read", Napi::Boolean::New(QtOh::uiEnv(), (properties & 0x02) != 0));
+        gattProperties.Set("notify", Napi::Boolean::New(QtOh::uiEnv(), (properties & 0x10) != 0));
+        gattProperties.Set("indicate", Napi::Boolean::New(QtOh::uiEnv(), (properties & 0x20) != 0));
+
+        Napi::ArrayBuffer characteristicValue = Napi::ArrayBuffer::New(QtOh::uiEnv(), charData.value().size());
+        if (charData.value().size() > 0) {
+            memcpy(characteristicValue.Data(), charData.value().data(), charData.value().size());
+        }
+
+        GattServiceEntry gattServiceEntry = gattServices[name];
+
+        Napi::Object characteristic = Napi::Object::New(QtOh::uiEnv());
+        characteristic.Set("serviceUuid", Napi::String::New(QtOh::uiEnv(), gattServiceEntry.uuid.toStdString()));
+        QString charDataJsUuid = jsUuidfromQtUuid(charData.uuid());
+        characteristic.Set("characteristicUuid", Napi::String::New(QtOh::uiEnv(), charDataJsUuid.toStdString()));
+        characteristic.Set("characteristicValue", characteristicValue);
+        characteristic.Set("descriptors", Napi::Array::New(QtOh::uiEnv()));
+        characteristic.Set("properties", gattProperties);
+
+        Napi::Array characteristics = gattServiceEntry.gattService.Get("characteristics").As<Napi::Array>();
+        characteristics.Set(characteristics.Length(), characteristic);
+
+        // if (!result)
+        //     qCWarning(QT_BT_OPENHARMONY) << "Cannot setup initial characteristic value for " << charData.uuid();
+
+        const QList<QLowEnergyDescriptorData> descriptorList = charData.descriptors();
+        for (const auto &descData: descriptorList) {
+
+            //  setupDescPermissions(descData),
+            // result = jsService->call<bool>("addDescriptor", jsUuidfromQtUuid(charData.uuid()), jsUuidfromQtUuid(descData.uuid())
+            //                                , descData.value());
+
+            Napi::ArrayBuffer descriptorValue = Napi::ArrayBuffer::New(QtOh::uiEnv(), descData.value().size());
+            memcpy(descriptorValue.Data(), descData.value().data(), descData.value().size());
+
+            Napi::Object descriptor = Napi::Object::New(QtOh::uiEnv());
+            descriptor.Set("serviceUuid", Napi::String::New(QtOh::uiEnv(), gattServiceEntry.uuid.toStdString()));
+            descriptor.Set("characteristicUuid", Napi::String::New(QtOh::uiEnv(), charDataJsUuid.toStdString()));
+            descriptor.Set("descriptorUuid", Napi::String::New(QtOh::uiEnv(), jsUuidfromQtUuid(descData.uuid()).toStdString()));
+            descriptor.Set("descriptorValue", descriptorValue);
+
+            for(int i = 0; i < characteristics.Length(); ++i){
+                Napi::Object characteristic = characteristics.Get(i).As<Napi::Object>();
+                if(charDataJsUuid != QString::fromStdString(characteristic.Get("characteristicUuid").ToString()))
+                    continue;
+                Napi::Array descriptors = characteristic.Get("descriptors").As<Napi::Array>();
+                descriptors.Set(descriptors.Length(), descriptor);
+            }
+
+            // if (!result) {
+            //     qCWarning(QT_BT_OPENHARMONY) << "Cannot add descriptor" << descData.uuid()
+            //                              << "to service" << service->uuid << "(char:"
+            //                              << charData.uuid() << ")";
+            // }
+        }
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/bluetooth/qlowenergycontroller_ohos_p.h b/src/bluetooth/qlowenergycontroller_ohos_p.h
new file mode 100644
index 00000000..de6f7ae3
--- /dev/null
+++ b/src/bluetooth/qlowenergycontroller_ohos_p.h
@@ -0,0 +1,136 @@
+#ifndef QLOWENERGYCONTROLLERPRIVATEOHOS_P_H
+#define QLOWENERGYCONTROLLERPRIVATEOHOS_P_H
+
+#include <qglobal.h>
+#include <QtCore/QQueue>
+#include <QtCore/QVector>
+#include <QtBluetooth/qbluetooth.h>
+#include <QtBluetooth/qlowenergycharacteristic.h>
+#include "qlowenergycontroller.h"
+#include "qlowenergycontrollerbase_p.h"
+
+#include "openharmony/lowenergynotificationhub_p.h"
+
+#include <functional>
+
+#include <QList>
+
+QT_BEGIN_NAMESPACE
+
+class QLowEnergyServiceData;
+class QTimer;
+
+class LowEnergyNotificationHub;
+
+extern void registerQLowEnergyControllerMetaType();
+
+class QLeAdvertiser;
+
+class QLowEnergyControllerPrivateOpenHarmony final : public QLowEnergyControllerPrivate
+{
+    Q_OBJECT
+public:
+    enum GattEntryType
+    {
+        GattService,
+        Characteristic,
+        CharacteristicValue,
+        Descriptor
+    };
+
+    struct GattEntry
+    {
+        GattEntryType type;
+        Napi::Object gattService;
+        Napi::Object bleCharacteristic;
+        Napi::Object bleDescriptor;
+    };
+
+    struct GattServiceEntry
+    {
+        QString uuid;
+        Napi::Object gattService;
+    };
+
+    QLowEnergyControllerPrivateOpenHarmony();
+    ~QLowEnergyControllerPrivateOpenHarmony() override;
+
+    void init() override;
+
+    void connectToDevice() override;
+    void disconnectFromDevice() override;
+
+    void discoverServices() override;
+    void discoverServiceDetails(const QBluetoothUuid &service) override;
+
+    void startAdvertising(const QLowEnergyAdvertisingParameters &params,
+                          const QLowEnergyAdvertisingData &advertisingData,
+                          const QLowEnergyAdvertisingData &scanResponseData) override;
+    void stopAdvertising() override;
+
+    void requestConnectionUpdate(const QLowEnergyConnectionParameters &params) override;
+
+    // read data
+    void readCharacteristic(const QSharedPointer<QLowEnergyServicePrivate> service,
+                            const QLowEnergyHandle charHandle) override;
+    void readDescriptor(const QSharedPointer<QLowEnergyServicePrivate> service,
+                        const QLowEnergyHandle charHandle,
+                        const QLowEnergyHandle descriptorHandle) override;
+
+    // write data
+    void writeCharacteristic(const QSharedPointer<QLowEnergyServicePrivate> service,
+                             const QLowEnergyHandle charHandle,
+                             const QByteArray &newValue, QLowEnergyService::WriteMode mode) override;
+    void writeDescriptor(const QSharedPointer<QLowEnergyServicePrivate> service,
+                         const QLowEnergyHandle charHandle,
+                         const QLowEnergyHandle descriptorHandle,
+                         const QByteArray &newValue) override;
+
+    void addToGenericAttributeList(const QLowEnergyServiceData &service,
+                                   QLowEnergyHandle startHandle) override;
+
+private:
+
+    LowEnergyNotificationHub *hub;
+
+private slots:
+    void connectionUpdated(QLowEnergyController::ControllerState newState,
+                           QLowEnergyController::Error errorCode);
+    void servicesDiscovered(QLowEnergyController::Error errorCode,
+                            const QString &foundServices);
+    void serviceDetailsDiscoveryFinished(const QString& serviceUuid,
+                                         int startHandle, int endHandle);
+    void characteristicRead(const QBluetoothUuid &serviceUuid, int handle,
+                            const QBluetoothUuid &charUuid, int properties,
+                            const QByteArray& data);
+    void descriptorRead(const QBluetoothUuid &serviceUuid, const QBluetoothUuid &charUuid,
+                        int handle, const QBluetoothUuid &descUuid, const QByteArray &data);
+    void characteristicWritten(int charHandle, const QByteArray &data,
+                               QLowEnergyService::ServiceError errorCode);
+    void descriptorWritten(int descHandle, const QByteArray &data,
+                           QLowEnergyService::ServiceError errorCode);
+    void serverDescriptorWritten(const QBluetoothUuid &serviceUuid, const QBluetoothUuid &characteristicUuid, const QBluetoothUuid &descriptorUuid, const QByteArray &newValue);
+    void characteristicChanged(int charHandle, const QByteArray &data);
+    void serverCharacteristicChanged(const QBluetoothUuid &serviceUuid, const QBluetoothUuid &characteristicUuid, const QByteArray &newValue);
+    void serviceError(int attributeHandle, QLowEnergyService::ServiceError errorCode);
+    void advertisementError(const QString &errorString);
+
+private:
+    void peripheralConnectionUpdated(QLowEnergyController::ControllerState newState,
+                           QLowEnergyController::Error errorCode);
+    void centralConnectionUpdated(QLowEnergyController::ControllerState newState,
+                           QLowEnergyController::Error errorCode);
+
+
+private:
+    QList<GattEntry> gattEntries;
+    QHash<QString, QList<int>> uuidToGattEntry;
+
+    QHash<QString, GattServiceEntry> gattServices;
+
+    int advertisingId;
+};
+
+QT_END_NAMESPACE
+
+#endif // QLOWENERGYCONTROLLERPRIVATEOHOS_P_H
diff --git a/src/bluetooth/qlowenergydescriptor.h b/src/bluetooth/qlowenergydescriptor.h
index 18bb53c0..e6c6a7ff 100644
--- a/src/bluetooth/qlowenergydescriptor.h
+++ b/src/bluetooth/qlowenergydescriptor.h
@@ -81,6 +81,7 @@ protected:
     friend class QLowEnergyControllerPrivate;
     friend class QLowEnergyControllerPrivateAndroid;
     friend class QLowEnergyControllerPrivateBluez;
+    friend class QLowEnergyControllerPrivateOpenHarmony;
     friend class QLowEnergyControllerPrivateBluezDBus;
     friend class QLowEnergyControllerPrivateCommon;
     friend class QLowEnergyControllerPrivateWin32;
diff --git a/src/bluetooth/qlowenergyservice.h b/src/bluetooth/qlowenergyservice.h
index a2715471..fb9597f7 100644
--- a/src/bluetooth/qlowenergyservice.h
+++ b/src/bluetooth/qlowenergyservice.h
@@ -137,6 +137,7 @@ private:
     friend class QLowEnergyControllerPrivateBluez;
     friend class QLowEnergyControllerPrivateAndroid;
     friend class QLowEnergyControllerPrivateDarwin;
+    friend class QLowEnergyControllerPrivateOpenHarmony;
     QLowEnergyService(QSharedPointer<QLowEnergyServicePrivate> p,
                       QObject *parent = nullptr);
 };
diff --git a/src/bluetooth/qlowenergyserviceprivate_p.h b/src/bluetooth/qlowenergyserviceprivate_p.h
index 1816a23f..167ca7e2 100644
--- a/src/bluetooth/qlowenergyserviceprivate_p.h
+++ b/src/bluetooth/qlowenergyserviceprivate_p.h
@@ -137,7 +137,9 @@ public:
 #if defined(QT_WIN_BLUETOOTH)
     Qt::HANDLE hService = nullptr;
 #endif
-
+#if defined (QT_OPENHARMONY_BLUETOOTH)
+    QString m_jsService;
+#endif
 };
 
 typedef QHash<QLowEnergyHandle, QLowEnergyServicePrivate::CharData> CharacteristicDataMap;
diff --git a/src/nfc/nfc.pro b/src/nfc/nfc.pro
index c6ae147d..0f49f35c 100644
--- a/src/nfc/nfc.pro
+++ b/src/nfc/nfc.pro
@@ -54,7 +54,7 @@ SOURCES += \
     qnearfieldsharetarget.cpp \
     qnfc.cpp
 
-linux:!android:qtHaveModule(dbus) {
+linux:!android:!openharmony:qtHaveModule(dbus) {
     NFC_BACKEND_AVAILABLE = yes
 
     QT_PRIVATE += dbus
@@ -110,6 +110,38 @@ linux:!android:qtHaveModule(dbus) {
         qnearfieldsharemanagerimpl_p.cpp \
         qnearfieldsharetargetimpl_p.cpp \
         android/androidmainnewintentlistener.cpp
+} else:openharmony {
+    NFC_BACKEND_AVAILABLE = yes
+    DEFINES += QT_OPENHARMONY_NFC
+    DEFINES += OPENHARMONY_NFC
+    QT_PRIVATE += core-private gui
+
+    HEADERS += \
+        qllcpserver_openharmony_p.h \
+        qllcpsocket_openharmony_p.h \
+        qnearfieldmanager_openharmony_p.h \
+        qnearfieldtarget_openharmony_p.h \
+        qnearfieldsharemanagerimpl_p.h \
+        qnearfieldsharetargetimpl_p.h \
+        openharmony/openharmonynfc_p.h \
+        openharmony/openharmonynfclistener_p.h \
+        openharmony/jsclass/qjscontroller.h \
+        openharmony/jsclass/qjstag.h
+
+    SOURCES += \
+        qllcpserver_openharmony_p.cpp \
+        qllcpsocket_openharmony_p.cpp \
+        qnearfieldmanager_openharmony.cpp \
+        qnearfieldtarget_openharmony.cpp \
+        qnearfieldsharemanagerimpl_p.cpp \
+        qnearfieldsharetargetimpl_p.cpp \
+        qnearfieldtarget_openharmony_p.cpp \
+        openharmony/openharmonynfc.cpp \
+        openharmony/openharmonynfclistener.cpp \
+        openharmony/jsclass/qjscontroller.cpp \
+        openharmony/jsclass/qjstag.cpp
+
+    LIBS += -lace_napi.z
 }
 
 isEmpty(NFC_BACKEND_AVAILABLE) {
diff --git a/src/nfc/openharmony/jsclass/qjscontroller.cpp b/src/nfc/openharmony/jsclass/qjscontroller.cpp
new file mode 100644
index 00000000..7518a39c
--- /dev/null
+++ b/src/nfc/openharmony/jsclass/qjscontroller.cpp
@@ -0,0 +1,487 @@
+#include "qjscontroller.h"
+#include "../openharmonynfclistener_p.h"
+
+#include <private/qjspromise_p.h>
+#include <private/qopenharmony_p.h>
+#include <sstream>
+#include <iomanip>
+#include <cctype>
+#include <cmath>
+
+#include "syscap_ndk.h"
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+
+static QJsController *g_qJsController = nullptr;
+
+static Napi::Array QByteArrayToNapiArray(Napi::Env env, const QByteArray &byteArray) {
+    Napi::Array jsArray = Napi::Array::New(env, byteArray.size());
+    for (int i = 0; i < byteArray.size(); ++i) {
+        uint8_t byte = static_cast<uint8_t>(byteArray.at(i));
+        jsArray.Set(i, Napi::Number::New(env, byte));
+    }
+    return jsArray;
+}
+
+static QByteArray NapiArrayToQByteArray(Napi::Array jsArray) {
+    QByteArray byteArray;
+    for (uint32_t i = 0; i < jsArray.Length(); ++i) {
+        Napi::Value item = jsArray.Get(i);
+        byteArray.append(static_cast<char>(item.As<Napi::Number>().Uint32Value()));
+    }
+    return byteArray;
+}
+
+
+static void escape_json_string(const std::string& input, std::ostringstream& output) {
+    for (char c : input) {
+        switch (c) {
+        case '"': output << "\\\""; break;
+        case '\\': output << "\\\\"; break;
+        case '/': output << "\\/"; break;
+        case '\b': output << "\\b"; break;
+        case '\f': output << "\\f"; break;
+        case '\n': output << "\\n"; break;
+        case '\r': output << "\\r"; break;
+        case '\t': output << "\\t"; break;
+        default:
+            if (static_cast<unsigned char>(c) < 0x20 || c == 0x7F) {
+                output << "\\u00"
+                       << std::hex << std::setw(2) << std::setfill('0')
+                       << static_cast<int>(static_cast<unsigned char>(c));
+            } else {
+                output << c;
+            }
+        }
+    }
+}
+
+static void serialize_napi_value(const Napi::Value& val, std::ostringstream& output) {
+    Napi::Env env = val.Env();
+
+    if (val.IsString()) {
+        output << '"';
+        escape_json_string(val.As<Napi::String>().Utf8Value(), output);
+        output << '"';
+    }
+    else if (val.IsNumber()) {
+        double num = val.As<Napi::Number>().DoubleValue();
+        if (num == static_cast<int64_t>(num) &&
+            (num > 9007199254740991 || num < -9007199254740991)) {
+            output << '"' << static_cast<int64_t>(num) << '"';
+        } else {
+            output << num;
+        }
+    }
+    else if (val.IsBoolean()) {
+        output << (val.As<Napi::Boolean>() ? "true" : "false");
+    }
+    else if (val.IsNull() || val.IsUndefined()) {
+        output << "null";
+    }
+    else if (val.IsArray()) {
+        Napi::Array arr = val.As<Napi::Array>();
+        output << '[';
+        for (uint32_t i = 0; i < arr.Length(); i++) {
+            if (i > 0) output << ',';
+            serialize_napi_value(arr[i], output);
+        }
+        output << ']';
+    }
+    else if (val.IsObject()) {
+        if (val.IsBuffer()) {
+            output << "\"<Buffer>";
+            output << val.As<Napi::Buffer<char>>().Length();
+            output << " bytes>\"";
+        }else {
+            Napi::Object obj = val.As<Napi::Object>();
+            output << '{';
+
+            Napi::Array keys = obj.GetPropertyNames();
+            bool first = true;
+
+            for (uint32_t i = 0; i < keys.Length(); i++) {
+                Napi::Value key = keys[i];
+                if (!key.IsString()) continue;
+
+                std::string keyStr = key.As<Napi::String>().Utf8Value();
+                Napi::Value value = obj.Get(key);
+
+                       // 跳过undefined值
+                if (value.IsUndefined()) continue;
+
+                if (!first) output << ',';
+                first = false;
+
+                output << '"';
+                escape_json_string(keyStr, output);
+                output << "\":";
+                serialize_napi_value(value, output);
+            }
+            output << '}';
+        }
+    }
+    else if (val.IsFunction()) {
+        output << "\"<Function>\"";
+    }
+    else if (val.IsPromise()) {
+        output << "\"<Promise>\"";
+    }
+    else {
+        output << "\"<UnsupportedType>\"";
+    }
+}
+
+JsTagSession::JsTagSession(Napi::Object tagInfo, Napi::Object target)
+    : QJsObject(target),
+      m_tagInfo(tagInfo),
+      m_target(target)
+{
+    m_jsSessionTag = QSharedPointer<QJsTag>::create();
+
+    Napi::Array technology = tagInfo.Get("technology").As<Napi::Array>();
+    for (uint32_t i = 0; i < technology.Length(); i++) {
+        uint32_t type = technology.Get(i).ToNumber().Uint32Value();
+        supportTechnologys.insert((NfcTechnologyType)type);
+    }
+}
+
+JsTagSession::~JsTagSession()
+{
+}
+
+QByteArray JsTagSession::uid()
+{
+    QByteArray byteArray;
+    if(m_tagInfo.IsUndefined() || m_tagInfo.IsNull())
+        return byteArray;
+
+    Napi::Array uid = m_tagInfo.Get("uid").As<Napi::Array>();
+    for(uint32_t i = 0; i < uid.Length(); ++i){
+        uint32_t num = uid.Get(i).ToNumber().Uint32Value();
+        byteArray.append(static_cast<char>(num));
+    }
+
+    return byteArray;
+}
+
+bool JsTagSession::connect()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        return call("connect").ToBoolean();
+    });
+}
+
+bool JsTagSession::isConnected()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        return call("isConnected").ToBoolean();
+    });
+}
+
+bool JsTagSession::close()
+{
+  //Todo
+    return true;
+}
+
+bool JsTagSession::isInRange()
+{
+    return true;
+}
+
+QByteArray JsTagSession::getNdefMessage()
+{
+    if(!supportTechnologys.contains(NDEF))
+        return QByteArray();
+
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        Napi::Object ndefTag = m_jsSessionTag->call("getNdef", {m_tagInfo}).As<Napi::Object>();
+        QJsObject qjsNdefTag(ndefTag);
+        Napi::Value ndefMessage = qjsNdefTag.call("getNdefMessage");
+        std::ostringstream jsonStream;
+        jsonStream << std::boolalpha;
+        serialize_napi_value(ndefMessage, jsonStream);
+        return QByteArray::fromStdString(jsonStream.str());
+    });
+}
+
+int JsTagSession::maxCommandLength()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        return call("getMaxTransmitSize").As<Napi::Number>().Int32Value();
+    });
+}
+
+QByteArray JsTagSession::transceive(const QByteArray &command)
+{
+    QByteArray responseData;
+    responseData = QtOh::runOnJsUIThreadWithPromise<QByteArray>([&, this](auto p){
+        Napi::Array data = QByteArrayToNapiArray(env(), command);
+        auto result = call("transmit", {data});
+        QJsPromise promise = QJsPromise(result.As<Napi::Promise>());
+        promise.onThen([p](const Napi::CallbackInfo &info){
+                   if(info[0].IsArray()){
+                       Napi::Array jsResponseData = info[0].As<Napi::Array>();
+                       p->set_value(NapiArrayToQByteArray(jsResponseData));
+                   }
+               }).onCatch([p](const Napi::CallbackInfo &info){
+                    int code = info[0].ToObject().Get("code").ToNumber();
+                    qWarning() << "JsTagSession transceive failed：" << code;
+                    p->set_value(QByteArray());
+                });
+    });
+
+    return responseData;
+}
+
+void JsTagSession::format(QByteArray data)
+{
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        Napi::Object tagNdef = m_jsSessionTag->get("ndef").As<Napi::Object>();
+        QJsObject qjstagNdef(tagNdef);
+        Napi::Object ndefMessage = qjstagNdef.call("createNdefMessage", {QByteArrayToNapiArray(env(), data)}).As<Napi::Object>();
+
+        if(m_target.Has("format")){
+            call("format", {ndefMessage});
+        }else{
+            Napi::Object ndefFormatableTag = m_jsSessionTag->call("getNdefFormatable", {m_tagInfo}).As<Napi::Object>();
+            QJsObject qjsNdefFormatableTag(ndefFormatableTag);
+            qjsNdefFormatableTag.call("format", {ndefMessage});
+        }
+    });
+}
+
+void JsTagSession::writeNdefMessage(QByteArray data)
+{
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        Napi::Object tagNdef = m_jsSessionTag->get("ndef").As<Napi::Object>();
+        QJsObject qjstagNdef(tagNdef);
+        Napi::Object ndefMessage = qjstagNdef.call("createNdefMessage", {QByteArrayToNapiArray(env(), data)}).As<Napi::Object>();
+
+        if(m_target.Has("writeNdef")){
+            call("writeNdef", {ndefMessage});
+        }else{
+            Napi::Object ndefTag = m_jsSessionTag->call("getNdef", {m_tagInfo}).As<Napi::Object>();
+            QJsObject qjsNdefTag(ndefTag);
+            qjsNdefTag.call("writeNdef", {ndefMessage});
+        }
+    });
+}
+
+QString JsTagSession::technologies()
+{
+    QStringList list;
+    for (int num : supportTechnologys) {
+        list.append(QString::number(num));
+    }
+    return list.join(",");
+}
+
+QString JsTagSession::getType()
+{
+    return QtOh::runOnJsUIThreadWithResult([&, this](){
+        Napi::Object ndefTagType;
+        if(m_target.Has("getNdefTagType")){
+            ndefTagType = call("getNdefTagType").As<Napi::Object>();
+            return QString::fromStdString(call("getNdefTagTypeString", {ndefTagType}).ToString());
+        }else{
+            Napi::Object ndefTag = m_jsSessionTag->call("getNdef", {m_tagInfo}).As<Napi::Object>();
+            QJsObject qjsNdefTag(ndefTag);
+            ndefTagType = qjsNdefTag.call("getNdefTagType").As<Napi::Object>();
+            return QString::fromStdString(qjsNdefTag.call("getNdefTagTypeString", {ndefTagType}).ToString());
+        }
+    });
+}
+
+QByteArray JsTagSession::getAtqa()
+{
+    return QtOh::runOnJsUIThreadWithResult([&, this](){
+        if(m_target.Has("getAtqa")){
+            return NapiArrayToQByteArray(call("getAtqa").As<Napi::Array>());
+        }else{
+            Napi::Object nfcATag = m_jsSessionTag->call("getNfcA", {m_tagInfo}).As<Napi::Object>();
+            QJsObject qjsNfcATag(nfcATag);
+            return NapiArrayToQByteArray(qjsNfcATag.call("getAtqa").As<Napi::Array>());
+        }
+    });
+}
+
+int JsTagSession::getSak()
+{
+    return QtOh::runOnJsUIThreadWithResult([&, this](){
+        if(m_target.Has("getSak")){
+            return call("getSak").As<Napi::Number>().Int32Value();
+        }else{
+            Napi::Object nfcATag = m_jsSessionTag->call("getNfcA", {m_tagInfo}).As<Napi::Object>();
+            QJsObject qjsNfcATag(nfcATag);
+            return qjsNfcATag.call("getSak").As<Napi::Number>().Int32Value();
+        }
+    });
+}
+
+QJsController::QJsController()
+    :QJsModule("@ohos.nfc.controller"),
+      m_jsTag(nullptr),
+      m_jsNfcTags()
+{
+    m_jsTag = QSharedPointer<QJsTag>::create();
+    g_qJsController = this;
+}
+
+QJsController::~QJsController()
+{
+    g_qJsController = nullptr;
+}
+
+QJsController *QJsController::instance()
+{
+    return g_qJsController ? g_qJsController : new QJsController();
+}
+
+void QJsController::createTag(Napi::Object tagInfo)
+{
+    static int index = 0;
+    if(tagInfo.IsUndefined() || tagInfo.IsNull())
+        return;
+
+    QString name = "tagInfo" + index++;
+    auto ohNfcListener = OpenHarmonyNfcListener::ohNfcListener();
+    ohNfcListener->newNfc(name);
+
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        Napi::Array technology = tagInfo.Get("technology").As<Napi::Array>();
+        Napi::Object targetNfc;
+        for (uint32_t i = 0; i < technology.Length(); i++) {
+            uint32_t type = technology.Get(i).ToNumber().Uint32Value();
+            switch(type){
+            case NFC_A:
+                targetNfc = m_jsTag->call("getNfcA", {tagInfo}).As<Napi::Object>();
+                break;
+            case NFC_B:
+                targetNfc = m_jsTag->call("getNfcB", {tagInfo}).As<Napi::Object>();
+                break;
+            case ISO_DEP:
+                targetNfc = m_jsTag->call("getIsoDep", {tagInfo}).As<Napi::Object>();
+                break;
+            case NFC_F:
+                targetNfc = m_jsTag->call("getNfcF", {tagInfo}).As<Napi::Object>();
+                break;
+            case NFC_V:
+                targetNfc = m_jsTag->call("getNfcV", {tagInfo}).As<Napi::Object>();
+                break;
+            case NDEF:
+                targetNfc = m_jsTag->call("getNdef", {tagInfo}).As<Napi::Object>();
+                break;
+            case NDEF_FORMATABLE:
+                targetNfc = m_jsTag->call("getNdefFormatable", {tagInfo}).As<Napi::Object>();
+                break;
+            case MIFARE_CLASSIC:
+                targetNfc = m_jsTag->call("getMifareClassic", {tagInfo}).As<Napi::Object>();
+                break;
+            case MIFARE_ULTRALIGHT:
+                targetNfc = m_jsTag->call("getMifareUltralight", {tagInfo}).As<Napi::Object>();
+                break;
+            default:
+                break;
+            }
+
+            /*默认使用第一个target*/
+            if(!targetNfc.IsUndefined() && !targetNfc.IsNull())
+                break;
+        }
+
+        m_jsNfcTags.insert(name, QSharedPointer<JsTagSession>(new JsTagSession(tagInfo, targetNfc)));
+    });
+}
+
+bool QJsController::start()
+{
+    QtOh::runOnJsUIThreadNoWait([&, this](){
+        Napi::Function nfcStateChangeCb = Napi::Function::New(env(), [&](const Napi::CallbackInfo& info) {
+            if (info.Length() < 2) {
+                qWarning() << "nfcStateChange failed, error unkonwn";
+                return;
+            }
+            Napi::Object error = info[0].As<Napi::Object>();
+            int code = (int)error.Get("code").ToNumber();
+            if (code != 0){
+                qWarning() << "nfcStateChange failed" << code << error.Get("message").ToString();
+                return;
+            }
+            auto ohNfcListener = OpenHarmonyNfcListener::ohNfcListener();
+            ohNfcListener->handleStateChanged(info[1].As<Napi::Number>().Int32Value());
+        });
+
+        call("on", {Napi::String::New(env(), "nfcStateChange"), nfcStateChangeCb});
+
+        Napi::Object elementName = Napi::Object::New(env());
+        elementName.Set("bundleName", Napi::String::New(env(), QtOh::bundleName().toStdString()));
+        elementName.Set("abilityName", Napi::String::New(env(), QtOh::abilityName().toStdString()));
+
+        Napi::Array discTech = Napi::Array::New(env());
+        int i = discTech.Length();
+        discTech.Set(i++, 1);   /*NFC_A*/
+        discTech.Set(i++, 2);   /*NFC_B*/
+
+        Napi::Function registerForegroundDispatchCb = Napi::Function::New(env(), [&,this](const Napi::CallbackInfo& info) {
+            if (info.Length() < 2) {
+                qWarning() << "registerForegroundDispatch failed, error unkonwn";
+                return;
+            }
+            Napi::Object error = info[0].As<Napi::Object>();
+            int code = (int)error.Get("code").ToNumber();
+            if (code != 0){
+                qWarning() << "registerForegroundDispatch failed" << code << error.Get("message").ToString();
+                return;
+            }
+            createTag(info[1].As<Napi::Object>());
+        });
+
+        m_jsTag->call("registerForegroundDispatch", {elementName, discTech, registerForegroundDispatchCb});
+    });
+
+    return true;
+}
+
+bool QJsController::stop()
+{
+    QtOh::runOnJsUIThreadNoWait([this](){
+        Napi::Object elementName = Napi::Object::New(env());
+        elementName.Set("bundleName", Napi::String::New(env(), QtOh::bundleName().toStdString()));
+        elementName.Set("abilityName", Napi::String::New(env(), QtOh::abilityName().toStdString()));
+        m_jsTag->call("unregisterForegroundDispatch", {elementName});
+    });
+}
+
+bool QJsController::isAvailable()
+{
+    return QtOh::runOnJsUIThreadWithResult([this](){
+        return call("isNfcOpen");
+    });
+}
+
+bool QJsController::isSupported()
+{
+    return canIUse("SystemCapability.Communication.NFC.Core");
+}
+
+QByteArray QJsController::tagInfoUid(QString tagInfoName)
+{
+    auto it = m_jsNfcTags.find(tagInfoName);
+    if(it == m_jsNfcTags.end())
+        return QByteArray();
+    return it.value()->uid();
+}
+
+JsTagSession *QJsController::getTagSession(QString tagInfoName)
+{
+    auto it = m_jsNfcTags.find(tagInfoName);
+    if(it == m_jsNfcTags.end())
+        return nullptr;
+    return it.value().data();
+}
+
+QT_END_NAMESPACE
diff --git a/src/nfc/openharmony/jsclass/qjscontroller.h b/src/nfc/openharmony/jsclass/qjscontroller.h
new file mode 100644
index 00000000..4df83990
--- /dev/null
+++ b/src/nfc/openharmony/jsclass/qjscontroller.h
@@ -0,0 +1,80 @@
+#ifndef QJSCONTROLLER_H
+#define QJSCONTROLLER_H
+
+#include <QJsModule>
+#include <QSharedPointer>
+#include <QByteArray>
+#include <QSet>
+#include "qjstag.h"
+
+
+QT_BEGIN_NAMESPACE
+
+enum NfcTechnologyType{
+    NFC_A = 1,
+    NFC_B,
+    ISO_DEP,
+    NFC_F,
+    NFC_V,
+    NDEF,
+    NDEF_FORMATABLE,
+    MIFARE_CLASSIC,
+    MIFARE_ULTRALIGHT
+};
+
+class JsTagSession : public QJsObject
+{
+public:
+    JsTagSession(Napi::Object tagInfo, Napi::Object target);
+    ~JsTagSession();
+
+    QByteArray uid();
+
+    bool connect();
+    bool isConnected();
+    bool close();
+    bool isInRange();
+    QByteArray getNdefMessage();
+    int maxCommandLength();
+    QByteArray transceive(const QByteArray &command);
+    void format(QByteArray data);
+    void writeNdefMessage(QByteArray data);
+    QString technologies();
+    QString getType();
+    QByteArray getAtqa();
+    int getSak();
+
+
+private:
+    QSharedPointer<QJsTag> m_jsSessionTag;
+    Napi::Object m_tagInfo;
+    Napi::Object m_target;
+    QSet<NfcTechnologyType> supportTechnologys;
+};
+
+class QJsController : public QJsModule
+{
+public:
+    QJsController();
+    ~QJsController();
+
+    static QJsController *instance();
+
+    bool start();
+    bool stop();
+    bool isAvailable();
+    bool isSupported();
+
+    QByteArray tagInfoUid(QString tagInfoName);
+    JsTagSession *getTagSession(QString tagInfoName);
+
+private:
+    void createTag(Napi::Object tagInfo);
+
+    QSharedPointer<QJsTag> m_jsTag;
+    QMap<QString, QSharedPointer<JsTagSession>> m_jsNfcTags;
+};
+
+QT_END_NAMESPACE
+
+#endif // QJSCONTROLLER_H
diff --git a/src/nfc/openharmony/jsclass/qjstag.cpp b/src/nfc/openharmony/jsclass/qjstag.cpp
new file mode 100644
index 00000000..e9c0c691
--- /dev/null
+++ b/src/nfc/openharmony/jsclass/qjstag.cpp
@@ -0,0 +1,15 @@
+#include "qjstag.h"
+
+QT_BEGIN_NAMESPACE
+
+QJsTag::QJsTag()
+    :QJsModule("@ohos.nfc.tag")
+{
+}
+
+QJsTag::~QJsTag()
+{
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/nfc/openharmony/jsclass/qjstag.h b/src/nfc/openharmony/jsclass/qjstag.h
new file mode 100644
index 00000000..4524ea4a
--- /dev/null
+++ b/src/nfc/openharmony/jsclass/qjstag.h
@@ -0,0 +1,18 @@
+#ifndef QJSTAG_H
+#define QJSTAG_H
+
+#include <QJsModule>
+
+QT_BEGIN_NAMESPACE
+
+
+class QJsTag : public QJsModule
+{
+public:
+    QJsTag();
+    ~QJsTag();
+};
+
+QT_END_NAMESPACE
+
+#endif // QJSTAG_H
diff --git a/src/nfc/openharmony/openharmonynfc.cpp b/src/nfc/openharmony/openharmonynfc.cpp
new file mode 100644
index 00000000..3f478194
--- /dev/null
+++ b/src/nfc/openharmony/openharmonynfc.cpp
@@ -0,0 +1,58 @@
+// #include <napi/native_api.h>
+#include <hilog/log.h>
+
+#include "openharmonynfclistener_p.h"
+#include "qopenharmonydefines.h"
+#include "openharmony/jsclass/qjscontroller.h"
+
+#include <QSharedPointer>
+
+namespace QtHarmonyPrivate {
+
+static OpenHarmonyNfcListener listeners;
+
+bool startDiscovery()
+{
+    QJsController *jsController = QJsController::instance();
+    return jsController->start();
+}
+
+bool isAvailable()
+{
+    QJsController *jsController = QJsController::instance();
+    return jsController->isAvailable();
+}
+
+bool isSupported()
+{
+    QJsController *jsController = QJsController::instance();
+    return jsController->isSupported();
+}
+
+bool stopDiscovery()
+{
+    QJsController *jsController = QJsController::instance();
+    return jsController->stop();
+}
+
+bool registerNfcListener(OpenHarmonyNfcListenerInterface *listener)
+{
+    return listeners.registerNfcListener(listener);
+}
+
+bool unregisterNfcListener(OpenHarmonyNfcListenerInterface *listener)
+{
+    return listeners.unregisterNfcListener(listener);
+}
+
+bool registerNfcStateListener(OpenHarmonyNfcStateListenerInterface *listener)
+{
+    return listeners.registerNfcStateListener(listener);
+}
+
+bool unregisterNfcStateListener(OpenHarmonyNfcStateListenerInterface *listener)
+{
+    return listeners.unregisterNfcStateListener(listener);
+}
+
+}
diff --git a/src/nfc/openharmony/openharmonynfc_p.h b/src/nfc/openharmony/openharmonynfc_p.h
new file mode 100644
index 00000000..c740707f
--- /dev/null
+++ b/src/nfc/openharmony/openharmonynfc_p.h
@@ -0,0 +1,31 @@
+#ifndef OPENHARMONYNFC_P_H
+#define OPENHARMONYNFC_P_H
+
+namespace QtHarmonyPrivate {
+
+class OpenHarmonyNfcListenerInterface
+{
+public:
+    virtual ~OpenHarmonyNfcListenerInterface(){}
+    virtual void newNfc(const QString &tagInfoName) = 0;
+};
+
+class OpenHarmonyNfcStateListenerInterface
+{
+public:
+    virtual ~OpenHarmonyNfcStateListenerInterface(){}
+    virtual void handleStateChanged(int state) = 0;
+};
+
+bool startDiscovery();
+bool stopDiscovery();
+bool isAvailable();
+bool isSupported();
+
+bool registerNfcListener(OpenHarmonyNfcListenerInterface *listener);
+bool unregisterNfcListener(OpenHarmonyNfcListenerInterface *listener);
+
+bool registerNfcStateListener(OpenHarmonyNfcStateListenerInterface *listener);
+bool unregisterNfcStateListener(OpenHarmonyNfcStateListenerInterface *listener);
+}
+#endif // OPENHARMONYNFC_P_H
diff --git a/src/nfc/openharmony/openharmonynfclistener.cpp b/src/nfc/openharmony/openharmonynfclistener.cpp
new file mode 100644
index 00000000..6d2b3208
--- /dev/null
+++ b/src/nfc/openharmony/openharmonynfclistener.cpp
@@ -0,0 +1,160 @@
+#include "openharmonynfclistener_p.h"
+#include "qopenharmonydefines.h"
+// #include <QOpenHarmonyJsEnvironment>
+#include "qdebug.h"
+#include <QtGui/QGuiApplication>
+
+static OpenHarmonyNfcListener *g_listener = nullptr;
+
+// static napi_value nfcStateChanged(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 1;
+//     napi_value args[1];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 1) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments");
+//         return nullptr;
+//     }
+
+
+//     int32_t value0 = qJs::getInt32(args[0]);
+//     if (g_listener != nullptr)
+//         g_listener->handleStateChanged(value0);
+
+//     return nullptr;
+// }
+
+// static napi_value nfcTargetDetected(napi_env env, napi_callback_info info)
+// {
+//     size_t argc = 1;
+//     napi_value args[1];
+//     NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+//     if (argc != 1) {
+//         napi_throw_type_error(env, NULL, "Wrong number of arguments");
+//         return nullptr;
+//     }
+
+//     QString value0 = qJs::getString(args[0]);
+//     if (g_listener != nullptr)
+//         g_listener->newNfc(value0);
+
+//     return nullptr;
+// }
+
+// napi_value OpenHarmonyNfcListener::init(napi_env env, napi_value exports)
+// {
+//     napi_property_descriptor desc[] ={
+//         DECLARE_NAPI_FUNCTION("nfcStateChanged", nfcStateChanged),
+//         DECLARE_NAPI_FUNCTION("nfcTargetDetected", nfcTargetDetected),
+//     };
+//     NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+//     return nullptr;
+// }
+
+
+OpenHarmonyNfcListener::OpenHarmonyNfcListener()
+ : nfcListeners(), nfcStateListeners(), listenersLock(), paused(true), receiving(false)
+{
+    // QtHarmonyPrivate::registerResumePauseListener(this);
+    g_listener = this;
+}
+
+OpenHarmonyNfcListener::~OpenHarmonyNfcListener()
+{
+    // QtHarmonyPrivate::unregisterResumePauseListener(this);
+    g_listener = nullptr;
+}
+
+OpenHarmonyNfcListener *OpenHarmonyNfcListener::ohNfcListener()
+{
+    return g_listener;
+}
+
+bool OpenHarmonyNfcListener::registerNfcStateListener(QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface *listener)
+{
+    listenersLock.lockForWrite();
+    if (!nfcStateListeners.contains(listener))
+        nfcStateListeners.push_back(listener);
+    listenersLock.unlock();
+    return true;
+}
+
+bool OpenHarmonyNfcListener::unregisterNfcStateListener(QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface *listener)
+{
+    listenersLock.lockForWrite();
+    nfcStateListeners.removeOne(listener);
+    listenersLock.unlock();
+    return true;
+}
+
+bool OpenHarmonyNfcListener::registerNfcListener(QtHarmonyPrivate::OpenHarmonyNfcListenerInterface *listener)
+{
+    listenersLock.lockForWrite();
+    if (!nfcListeners.contains(listener))
+        nfcListeners.push_back(listener);
+    listenersLock.unlock();
+    updateReceiveState();
+    return true;
+}
+
+bool OpenHarmonyNfcListener::unregisterNfcListener(QtHarmonyPrivate::OpenHarmonyNfcListenerInterface *listener)
+{
+    listenersLock.lockForWrite();
+    nfcListeners.removeOne(listener);
+    listenersLock.unlock();
+    updateReceiveState();
+    return true;
+}
+
+void OpenHarmonyNfcListener::handleResume()
+{
+    paused = false;
+    updateReceiveState();
+}
+
+void OpenHarmonyNfcListener::handlePause()
+{
+    paused = true;
+    updateReceiveState();
+}
+
+void OpenHarmonyNfcListener::newNfc(const QString &tagInfoName)
+{
+    for (const auto listener : qAsConst(nfcListeners)) {
+        listener->newNfc(tagInfoName);
+    }
+}
+
+void OpenHarmonyNfcListener::handleStateChanged(int state)
+{
+    for (const auto listener : qAsConst(nfcStateListeners)) {
+        listener->handleStateChanged(state);
+    }
+}
+
+void OpenHarmonyNfcListener::updateReceiveState()
+{
+    if (paused) {
+        // We were paused while receiving, so we stop receiving.
+        if (receiving) {
+            QtHarmonyPrivate::stopDiscovery();
+            receiving = false;
+        }
+        return;
+    }
+
+    // We reach here, so we are not paused.
+    listenersLock.lockForRead();
+    // We have nfc listeners and do not receive. Switch on.
+    if (nfcListeners.count() && !receiving)
+        receiving = QtHarmonyPrivate::startDiscovery();
+
+    // we have no nfc listeners and do receive. Switch off.
+    if (!nfcListeners.count() && receiving) {
+        QtHarmonyPrivate::stopDiscovery();
+        receiving = false;
+    }
+    listenersLock.unlock();
+}
diff --git a/src/nfc/openharmony/openharmonynfclistener_p.h b/src/nfc/openharmony/openharmonynfclistener_p.h
new file mode 100644
index 00000000..f80e1d1d
--- /dev/null
+++ b/src/nfc/openharmony/openharmonynfclistener_p.h
@@ -0,0 +1,45 @@
+#ifndef OPENHARMONYNFCLISTENER_P_H_
+#define OPENHARMONYNFCLISTENER_P_H_
+
+
+// #include <QtCore/private/qopenharmonyhelpers_p.h>
+// #include <napi/native_api.h>
+
+#include "qlist.h"
+#include "qreadwritelock.h"
+#include "openharmonynfc_p.h"
+
+class OpenHarmonyNfcListener : QtHarmonyPrivate::OpenHarmonyNfcListenerInterface,
+                               QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface
+{
+public:
+    OpenHarmonyNfcListener();
+    ~OpenHarmonyNfcListener();
+
+
+    static OpenHarmonyNfcListener *ohNfcListener();
+
+    bool registerNfcListener(QtHarmonyPrivate::OpenHarmonyNfcListenerInterface *listener);
+    bool unregisterNfcListener(QtHarmonyPrivate::OpenHarmonyNfcListenerInterface *listener);
+
+    bool registerNfcStateListener(QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface *listener);
+    bool unregisterNfcStateListener(QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface *listener);
+
+    void handleResume();
+    void handlePause();
+
+    void newNfc(const QString &tagInfoName);
+    void handleStateChanged(int state);
+
+    // static napi_value init(napi_env env, napi_value exports);
+private:
+    void updateReceiveState();
+protected:
+    QList<QtHarmonyPrivate::OpenHarmonyNfcListenerInterface*> nfcListeners;
+    QList<QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface*> nfcStateListeners;
+    QReadWriteLock listenersLock;
+    bool paused;
+    bool receiving;
+};
+
+#endif /* OPENHARMONYNFCLISTENER_P_H_ */
diff --git a/src/nfc/qllcpserver_openharmony_p.cpp b/src/nfc/qllcpserver_openharmony_p.cpp
new file mode 100644
index 00000000..108210c6
--- /dev/null
+++ b/src/nfc/qllcpserver_openharmony_p.cpp
@@ -0,0 +1,92 @@
+#include "qllcpserver_openharmony_p.h"
+//#include "qnx/qnxnfcmanager_p.h"
+
+QT_BEGIN_NAMESPACE
+
+QLlcpServerPrivate::QLlcpServerPrivate(QLlcpServer *q)
+    : q_ptr(q), m_llcpSocket(0), m_connected(false)
+{
+}
+
+QLlcpServerPrivate::~QLlcpServerPrivate()
+{
+}
+
+bool QLlcpServerPrivate::listen(const QString &/*serviceUri*/)
+{
+    /*//The server is already listening
+    if (isListening())
+        return false;
+
+    nfc_result_t result = nfc_llcp_register_connection_listener(NFC_LLCP_SERVER, 0, serviceUri.toStdString().c_str(), &m_conListener);
+    m_connected = true;
+    if (result == NFC_RESULT_SUCCESS) {
+        m_serviceUri = serviceUri;
+        qQNXNFCDebug() << "LLCP server registered" << serviceUri;
+    } else {
+        qWarning() << Q_FUNC_INFO << "Could not register for llcp connection listener";
+        return false;
+    }
+    QNXNFCManager::instance()->registerLLCPConnection(m_conListener, this);*/
+    return true;
+}
+
+bool QLlcpServerPrivate::isListening() const
+{
+    return m_connected;
+}
+
+void QLlcpServerPrivate::close()
+{
+    /*nfc_llcp_unregister_connection_listener(m_conListener);
+    QNXNFCManager::instance()->unregisterLLCPConnection(m_conListener);
+    m_serviceUri = QString();
+    m_connected = false;*/
+}
+
+QString QLlcpServerPrivate::serviceUri() const
+{
+    return m_serviceUri;
+}
+
+quint8 QLlcpServerPrivate::serverPort() const
+{
+    /*unsigned int sap;
+    if (nfc_llcp_get_local_sap(m_target, &sap) == NFC_RESULT_SUCCESS) {
+        return sap;
+    }*/
+    return -1;
+}
+
+bool QLlcpServerPrivate::hasPendingConnections() const
+{
+    return m_llcpSocket != 0;
+}
+
+QLlcpSocket *QLlcpServerPrivate::nextPendingConnection()
+{
+    /*QLlcpSocket *socket = m_llcpSocket;
+    m_llcpSocket = 0;
+    return socket;*/
+    return 0;
+}
+
+QLlcpSocket::SocketError QLlcpServerPrivate::serverError() const
+{
+    return QLlcpSocket::UnknownSocketError;
+}
+
+/*void QLlcpServerPrivate::connected(nfc_target_t *target)
+{
+    m_target = target;
+    if (m_llcpSocket != 0) {
+        qWarning() << Q_FUNC_INFO << "LLCP socket not cloesed properly";
+        return;
+    }
+    m_llcpSocket = new QLlcpSocket();
+    m_llcpSocket->bind(serverPort());
+}*/
+
+QT_END_NAMESPACE
+
+
diff --git a/src/nfc/qllcpserver_openharmony_p.h b/src/nfc/qllcpserver_openharmony_p.h
new file mode 100644
index 00000000..cbb4b957
--- /dev/null
+++ b/src/nfc/qllcpserver_openharmony_p.h
@@ -0,0 +1,44 @@
+#ifndef QLLCPSERVER_OPENHARMONY_P_H
+#define QLLCPSERVER_OPENHARMONY_P_H
+
+
+#include "qllcpserver_p.h"
+//#include "nfc/nfc.h"
+
+QT_BEGIN_NAMESPACE
+
+class QLlcpServerPrivate : public QObject
+{
+    Q_OBJECT
+public:
+    QLlcpServerPrivate(QLlcpServer *q);
+    ~QLlcpServerPrivate();
+
+    bool listen(const QString &serviceUri);
+    bool isListening() const;
+
+    void close();
+
+    QString serviceUri() const;
+    quint8 serverPort() const;
+
+    bool hasPendingConnections() const;
+    QLlcpSocket *nextPendingConnection();
+
+    QLlcpSocket::SocketError serverError() const;
+
+    //Q_INVOKABLE void connected(nfc_target_t *);
+
+private:
+    QLlcpServer *q_ptr;
+    QLlcpSocket *m_llcpSocket;
+    //We can not use m_conListener for the connection state
+    bool m_connected;
+    //nfc_llcp_connection_listener_t m_conListener;
+    QString m_serviceUri;
+    //nfc_target_t *m_target;
+};
+
+QT_END_NAMESPACE
+
+#endif // QLLCPSERVER_OPENHARMONY_P_H
diff --git a/src/nfc/qllcpsocket_openharmony_p.cpp b/src/nfc/qllcpsocket_openharmony_p.cpp
new file mode 100644
index 00000000..77c41ea1
--- /dev/null
+++ b/src/nfc/qllcpsocket_openharmony_p.cpp
@@ -0,0 +1,285 @@
+#include "qllcpsocket_android_p.h"
+#include <unistd.h>
+
+QT_BEGIN_NAMESPACE
+
+QLlcpSocketPrivate::QLlcpSocketPrivate(QLlcpSocket *q)
+    :   q_ptr(q), m_state(QLlcpSocket::UnconnectedState), m_server(false)
+{
+}
+
+QLlcpSocketPrivate::~QLlcpSocketPrivate()
+{
+    disconnectFromService();
+}
+
+void QLlcpSocketPrivate::connectToService(QNearFieldTarget *target, const QString &serviceUri)
+{
+    Q_UNUSED(target)
+    Q_UNUSED(serviceUri)
+    /*if (m_state != QLlcpSocket::UnconnectedState) {
+        qWarning() << Q_FUNC_INFO << "socket is already connected";
+        return;
+    }
+
+    m_state = QLlcpSocket::ConnectingState;
+    if (nfc_llcp_register_connection_listener(NFC_LLCP_CLIENT, 0, serviceUri.toLocal8Bit().constData(),
+                                              &m_conListener) != NFC_RESULT_SUCCESS) {
+        qWarning() << Q_FUNC_INFO << "could not register for connection listener";
+        return;
+    }
+
+    QNXNFCManager::instance()->registerLLCPConnection(m_conListener, this);
+
+    qQNXNFCDebug() << "Connecting client socket" << serviceUri << m_conListener;
+    connect(QNXNFCManager::instance(), &QNXNFCManager::llcpDisconnected, this, &QLlcpSocketPrivate::disconnectFromService);*/
+}
+
+void QLlcpSocketPrivate::disconnectFromService()
+{
+    /*Q_Q(QLlcpSocket);
+    QNXNFCManager::instance()->unregisterTargetLost(this);
+    qQNXNFCDebug() << "Shutting down LLCP socket";
+    if (!m_server && nfc_llcp_unregister_connection_listener(m_conListener) != NFC_RESULT_SUCCESS) {
+        qWarning() << Q_FUNC_INFO << "Error when trying to close LLCP socket";
+    }
+    QNXNFCManager::instance()->unregisterLLCPConnection(m_conListener);
+    disconnect(QNXNFCManager::instance(), &QNXNFCManager::llcpDisconnected, this, &QLlcpSocketPrivate::disconnectFromService);
+
+    q->disconnected();
+    m_conListener = 0;
+    m_state = QLlcpSocket::UnconnectedState;*/
+}
+
+bool QLlcpSocketPrivate::bind(quint8 port)
+{
+    Q_UNUSED(port);
+
+    /*m_state = QLlcpSocket::ConnectedState;
+    m_server = true;
+    connect(QNXNFCManager::instance(), &QNXNFCManager::llcpDisconnected, this, &QLlcpSocketPrivate::disconnectFromService);
+    connected(QNXNFCManager::instance()->getLastTarget());*/
+
+    return true;
+}
+
+bool QLlcpSocketPrivate::hasPendingDatagrams() const
+{
+    return !m_receivedDatagrams.isEmpty();
+}
+
+qint64 QLlcpSocketPrivate::pendingDatagramSize() const
+{
+    if (m_receivedDatagrams.isEmpty())
+        return -1;
+
+    return m_receivedDatagrams.first().length();
+}
+
+qint64 QLlcpSocketPrivate::writeDatagram(const char *data, qint64 size)
+{
+    if (m_state == QLlcpSocket::ConnectedState)
+        return writeData(data, size);
+
+    return -1;
+}
+
+qint64 QLlcpSocketPrivate::writeDatagram(const QByteArray &datagram)
+{
+    return writeDatagram(datagram.constData(), datagram.size());
+}
+
+qint64 QLlcpSocketPrivate::readDatagram(char *data, qint64 maxSize,
+                                        QNearFieldTarget **target, quint8 *port)
+{
+    Q_UNUSED(target);
+    Q_UNUSED(port);
+
+    if (m_state == QLlcpSocket::ConnectedState)
+        return readData(data, maxSize);
+
+    return -1;
+}
+
+qint64 QLlcpSocketPrivate::writeDatagram(const char *data, qint64 size,
+                                         QNearFieldTarget *target, quint8 port)
+{
+    Q_UNUSED(target);
+    Q_UNUSED(port);
+
+    return writeDatagram(data, size);
+}
+
+qint64 QLlcpSocketPrivate::writeDatagram(const QByteArray &datagram,
+                                         QNearFieldTarget *target, quint8 port)
+{
+    Q_UNUSED(datagram);
+    Q_UNUSED(target);
+    Q_UNUSED(port);
+
+    return writeDatagram(datagram.constData(), datagram.size()-1);
+}
+
+QLlcpSocket::SocketError QLlcpSocketPrivate::error() const
+{
+    return QLlcpSocket::UnknownSocketError;
+}
+
+QLlcpSocket::SocketState QLlcpSocketPrivate::state() const
+{
+    return m_state;
+}
+
+qint64 QLlcpSocketPrivate::readData(char *data, qint64 maxlen)
+{
+    Q_UNUSED(data);
+    Q_UNUSED(maxlen);
+    if (m_receivedDatagrams.isEmpty())
+        return 0;
+
+    /*const QByteArray datagram = m_receivedDatagrams.takeFirst();
+    qint64 size = qMin(maxlen, qint64(datagram.length()));
+    memcpy(data, datagram.constData(), size);
+    return size;*/
+    return 0;
+}
+
+qint64 QLlcpSocketPrivate::writeData(const char *data, qint64 len)
+{
+    Q_UNUSED(data);
+    Q_UNUSED(len);
+    /*if (socketState != Idle) {
+        m_writeQueue.append(QByteArray(data, len));
+        return len;
+    } else {
+        socketState = Writing;
+        qQNXNFCDebug() << "LLCP write";
+        nfc_result_t res = nfc_llcp_write(m_target, (uchar_t*)data, (size_t)len);
+        if (res == NFC_RESULT_SUCCESS) {
+            return len;
+        } else {
+            qWarning() << Q_FUNC_INFO << "Error writing to LLCP socket. Error" << res;
+            enteringIdle();
+            return -1;
+        }
+    }*/
+    return -1;
+}
+
+qint64 QLlcpSocketPrivate::bytesAvailable() const
+{
+    /*qint64 available = 0;
+    for (const QByteArray &datagram : qAsConst(m_receivedDatagrams))
+        available += datagram.length();
+
+    return available;*/
+    return 0;
+}
+
+bool QLlcpSocketPrivate::canReadLine() const
+{
+    /*for (const QByteArray &datagram : qAsConst(m_receivedDatagrams)) {
+        if (datagram.contains('\n'))
+            return true;
+    }*/
+
+    return false;
+}
+
+bool QLlcpSocketPrivate::waitForReadyRead(int msecs)
+{
+    Q_UNUSED(msecs);
+
+    return false;
+}
+
+bool QLlcpSocketPrivate::waitForBytesWritten(int msecs)
+{
+    Q_UNUSED(msecs);
+
+    return false;
+}
+
+bool QLlcpSocketPrivate::waitForConnected(int msecs)
+{
+    Q_UNUSED(msecs);
+
+    return false;
+}
+
+bool QLlcpSocketPrivate::waitForDisconnected(int msecs)
+{
+    Q_UNUSED(msecs);
+
+    return false;
+}
+
+/*void QLlcpSocketPrivate::connected(nfc_target_t *target)
+{
+    Q_Q(QLlcpSocket);
+    m_target = target;
+
+    m_state = QLlcpSocket::ConnectedState;
+    emit q->connected();
+    qQNXNFCDebug() << "Socket connected";
+
+    unsigned int targetId;
+    nfc_get_target_connection_id(target, &targetId);
+    QNXNFCManager::instance()->requestTargetLost(this, targetId);
+    enteringIdle();
+}*/
+
+void QLlcpSocketPrivate::targetLost()
+{
+    disconnectFromService();
+    //qQNXNFCDebug() << "LLCP target lost...socket disconnected";
+}
+
+void QLlcpSocketPrivate::dataRead(QByteArray& data)
+{
+    Q_UNUSED(data);
+    /*Q_Q(QLlcpSocket);
+    if (!data.isEmpty()) {
+        m_receivedDatagrams.append(data);
+        emit q->readyRead();
+    }
+    socketState = Idle;
+    enteringIdle();*/
+}
+
+void QLlcpSocketPrivate::dataWritten()
+{
+    //enteringIdle();
+}
+
+void QLlcpSocketPrivate::read()
+{
+    /*if (socketState != Idle) {
+        qQNXNFCDebug() << "Trying to read but socket state not in idle..abort";
+        return;
+    }
+    socketState = Reading;
+    qQNXNFCDebug() << "LLCP read";
+    if (nfc_llcp_read(m_target, 128) != NFC_RESULT_SUCCESS) {
+        qWarning() << Q_FUNC_INFO << "Could not register for reading";
+        socketState = Idle;
+    }*/
+}
+
+void QLlcpSocketPrivate::enteringIdle()
+{
+    /*qQNXNFCDebug() << "entering idle; Socket state:" << socketState;
+    socketState = Idle;
+    if (m_state == QLlcpSocket::ConnectedState) {
+        if (m_writeQueue.isEmpty()) {
+            qQNXNFCDebug() << "Write queue empty, reading in 50ms";
+            QTimer::singleShot(50, this, SLOT(read()));
+        } else {
+            qQNXNFCDebug() << "Write first package in queue";
+            writeDatagram(m_writeQueue.takeFirst());
+        }
+    }*/
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/nfc/qllcpsocket_openharmony_p.h b/src/nfc/qllcpsocket_openharmony_p.h
new file mode 100644
index 00000000..0be026c0
--- /dev/null
+++ b/src/nfc/qllcpsocket_openharmony_p.h
@@ -0,0 +1,83 @@
+#ifndef QLLCPSOCKET_OPENHARMONY_P_H
+#define QLLCPSOCKET_OPENHARMONY_P_H
+
+#include "qllcpsocket_p.h"
+
+
+QT_BEGIN_NAMESPACE
+
+class QLlcpSocketPrivate : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PUBLIC(QLlcpSocket)
+
+public:
+    QLlcpSocketPrivate(QLlcpSocket *q);
+
+    ~QLlcpSocketPrivate();
+
+    void connectToService(QNearFieldTarget *target, const QString &serviceUri);
+
+    bool bind(quint8 port);
+
+    bool hasPendingDatagrams() const;
+    qint64 pendingDatagramSize() const;
+
+    qint64 writeDatagram(const char *data, qint64 size);
+    qint64 writeDatagram(const QByteArray &datagram);
+
+    qint64 readDatagram(char *data, qint64 maxSize,
+                        QNearFieldTarget **target = 0, quint8 *port = 0);
+    qint64 writeDatagram(const char *data, qint64 size,
+                         QNearFieldTarget *target, quint8 port);
+    qint64 writeDatagram(const QByteArray &datagram, QNearFieldTarget *target, quint8 port);
+
+    QLlcpSocket::SocketError error() const;
+    QLlcpSocket::SocketState state() const;
+
+    qint64 readData(char *data, qint64 maxlen);
+    qint64 writeData(const char *data, qint64 len);
+
+    qint64 bytesAvailable() const;
+    bool canReadLine() const;
+
+    bool waitForReadyRead(int msecs);
+    bool waitForBytesWritten(int msecs);
+    bool waitForConnected(int msecs);
+    bool waitForDisconnected(int msecs);
+
+    //Q_INVOKABLE void connected(nfc_target_t *);
+    Q_INVOKABLE void targetLost();
+
+    void dataRead(QByteArray&);
+    void dataWritten();
+
+public Q_SLOTS:
+    void disconnectFromService();
+
+private:
+    QLlcpSocket *q_ptr;
+    unsigned int m_sap;
+    //nfc_llcp_connection_listener_t m_conListener;
+    //NearFieldTarget *m_target;
+    //nfc_target_t *m_target;
+
+    QLlcpSocket::SocketState m_state;
+
+    QList<QByteArray> m_receivedDatagrams;
+    QList<QByteArray> m_writeQueue;
+
+    bool m_server;
+
+    enum llcpState {
+        Idle, Reading, Writing
+    } socketState;
+
+private Q_SLOTS:
+    void read();
+    void enteringIdle();
+};
+
+QT_END_NAMESPACE
+
+#endif // QLLCPSOCKET_OPENHARMONY_P_H
diff --git a/src/nfc/qnearfieldmanager.cpp b/src/nfc/qnearfieldmanager.cpp
index 757c8c99..8dfffd47 100644
--- a/src/nfc/qnearfieldmanager.cpp
+++ b/src/nfc/qnearfieldmanager.cpp
@@ -46,6 +46,8 @@
 #include "qnearfieldmanager_neard_p.h"
 #elif defined(ANDROID_NFC)
 #include "qnearfieldmanager_android_p.h"
+#elif defined(OPENHARMONY_NFC)
+#include "qnearfieldmanager_openharmony_p.h"
 #else
 #include "qnearfieldmanagerimpl_p.h"
 #endif
diff --git a/src/nfc/qnearfieldmanager_openharmony.cpp b/src/nfc/qnearfieldmanager_openharmony.cpp
new file mode 100644
index 00000000..ee836ebe
--- /dev/null
+++ b/src/nfc/qnearfieldmanager_openharmony.cpp
@@ -0,0 +1,274 @@
+#include "qnearfieldmanager_openharmony_p.h"
+#include "qnearfieldtarget_openharmony_p.h"
+
+#include "qndeffilter.h"
+#include "qndefmessage.h"
+#include "qndefrecord.h"
+#include "qbytearray.h"
+#include "qcoreapplication.h"
+#include "qdebug.h"
+#include "qlist.h"
+#include "openharmony/jsclass/qjscontroller.h"
+
+#include <QScopedPointer>
+#include <QtCore/QMetaType>
+#include <QtCore/QMetaMethod>
+
+QT_BEGIN_NAMESPACE
+
+
+QNearFieldManagerPrivateImpl::QNearFieldManagerPrivateImpl() :
+    m_detecting(false), m_handlerID(0)
+{
+    QtHarmonyPrivate::registerNfcStateListener(this);
+    connect(this, &QNearFieldManagerPrivateImpl::targetDetected, this, &QNearFieldManagerPrivateImpl::handlerTargetDetected);
+    connect(this, &QNearFieldManagerPrivateImpl::targetLost, this, &QNearFieldManagerPrivateImpl::handlerTargetLost);
+}
+
+QNearFieldManagerPrivateImpl::~QNearFieldManagerPrivateImpl()
+{
+    QtHarmonyPrivate::unregisterNfcStateListener(this);
+}
+
+void QNearFieldManagerPrivateImpl::handlerTargetDetected(QNearFieldTarget *target)
+{
+    if (ndefMessageHandlers.count() == 0 && ndefFilterHandlers.count() == 0) // if no handler is registered
+        return;
+    if (target->hasNdefMessage()) {
+        connect(reinterpret_cast<NearFieldTarget *>(target), &NearFieldTarget::ndefMessageRead,
+                this, &QNearFieldManagerPrivateImpl::handlerNdefMessageRead);
+        connect(target, &QNearFieldTarget::requestCompleted,
+                this, &QNearFieldManagerPrivateImpl::handlerRequestCompleted);
+        connect(target, &QNearFieldTarget::error,
+                this, &QNearFieldManagerPrivateImpl::handlerError);
+
+        QNearFieldTarget::RequestId id = target->readNdefMessages();
+        m_idToTarget.insert(id, target);
+    }
+}
+
+void QNearFieldManagerPrivateImpl::handlerTargetLost(QNearFieldTarget *target)
+{
+    disconnect(reinterpret_cast<NearFieldTarget *>(target), &NearFieldTarget::ndefMessageRead,
+            this, &QNearFieldManagerPrivateImpl::handlerNdefMessageRead);
+    disconnect(target, &QNearFieldTarget::requestCompleted,
+            this, &QNearFieldManagerPrivateImpl::handlerRequestCompleted);
+    disconnect(target, &QNearFieldTarget::error,
+            this, &QNearFieldManagerPrivateImpl::handlerError);
+    m_idToTarget.remove(m_idToTarget.key(target));
+}
+
+struct VerifyRecord
+{
+    QNdefFilter::Record filterRecord;
+    unsigned int count;
+};
+
+void QNearFieldManagerPrivateImpl::handlerNdefMessageRead(const QNdefMessage &message, const QNearFieldTarget::RequestId &id)
+{
+    QNearFieldTarget *target = m_idToTarget.value(id);
+    //For message handlers without filters
+    for (int i = 0; i < ndefMessageHandlers.count(); i++) {
+        ndefMessageHandlers.at(i).second.invoke(ndefMessageHandlers.at(i).first.second, Q_ARG(QNdefMessage, message), Q_ARG(QNearFieldTarget*, target));
+    }
+
+    //For message handlers that specified a filter
+    for (int i = 0; i < ndefFilterHandlers.count(); ++i) {
+        bool matched = true;
+
+        QNdefFilter filter = ndefFilterHandlers.at(i).second.first;
+
+        QList<VerifyRecord> filterRecords;
+        for (int j = 0; j < filter.recordCount(); ++j) {
+            VerifyRecord vr;
+            vr.count = 0;
+            vr.filterRecord = filter.recordAt(j);
+
+            filterRecords.append(vr);
+        }
+
+        for (const QNdefRecord &record : message) {
+            for (int j = 0; matched && (j < filterRecords.count()); ++j) {
+                VerifyRecord &vr = filterRecords[j];
+
+                if (vr.filterRecord.typeNameFormat == record.typeNameFormat() &&
+                    ( vr.filterRecord.type == record.type() ||
+                      vr.filterRecord.type.isEmpty()) ) {
+                    ++vr.count;
+                    break;
+                } else {
+                    if (filter.orderMatch()) {
+                        if (vr.filterRecord.minimum <= vr.count &&
+                            vr.count <= vr.filterRecord.maximum) {
+                            continue;
+                        } else {
+                            matched = false;
+                        }
+                    }
+                }
+            }
+        }
+
+        for (int j = 0; matched && (j < filterRecords.count()); ++j) {
+            const VerifyRecord &vr = filterRecords.at(j);
+
+            if (vr.filterRecord.minimum <= vr.count && vr.count <= vr.filterRecord.maximum)
+                continue;
+            else
+                matched = false;
+        }
+
+        if (matched) {
+            ndefFilterHandlers.at(i).second.second.invoke(ndefFilterHandlers.at(i).first.second, Q_ARG(QNdefMessage, message), Q_ARG(QNearFieldTarget*, target));
+        }
+    }
+}
+
+void QNearFieldManagerPrivateImpl::handlerRequestCompleted(const QNearFieldTarget::RequestId &id)
+{
+    m_idToTarget.remove(id);
+}
+
+void QNearFieldManagerPrivateImpl::handlerError(QNearFieldTarget::Error error, const QNearFieldTarget::RequestId &id)
+{
+    Q_UNUSED(error);
+    m_idToTarget.remove(id);
+}
+
+bool QNearFieldManagerPrivateImpl::isAvailable() const
+{
+    return QtHarmonyPrivate::isAvailable();
+}
+
+bool QNearFieldManagerPrivateImpl::isSupported() const
+{
+    return QtHarmonyPrivate::isSupported();
+}
+
+bool QNearFieldManagerPrivateImpl::startTargetDetection()
+{
+    if (m_detecting)
+        return false;   // Already detecting targets
+
+    m_detecting = true;
+    updateReceiveState();
+    return true;
+}
+
+void QNearFieldManagerPrivateImpl::stopTargetDetection()
+{
+    m_detecting = false;
+    updateReceiveState();
+}
+
+// FIXME This is supposed to be a platform registration. A message that
+// matches the given NDEF filter should restart the current application.
+// The implementation below only works as long as the current application
+// is running. It is not a platform wide registration on Android.
+int QNearFieldManagerPrivateImpl::registerNdefMessageHandler(QObject *object, const QMetaMethod &method)
+{
+    ndefMessageHandlers.append(QPair<QPair<int, QObject *>, QMetaMethod>(QPair<int, QObject *>(m_handlerID, object), method));
+    updateReceiveState();
+    //Returns the handler ID and increments it afterwards
+    return m_handlerID++;
+}
+
+// FIXME see above
+int QNearFieldManagerPrivateImpl::registerNdefMessageHandler(const QNdefFilter &filter,
+                                                             QObject *object, const QMetaMethod &method)
+{
+    //If no record is set in the filter, we ignore the filter
+    if (filter.recordCount()==0)
+        return registerNdefMessageHandler(object, method);
+
+    ndefFilterHandlers.append(QPair<QPair<int, QObject*>, QPair<QNdefFilter, QMetaMethod> >
+                              (QPair<int, QObject*>(m_handlerID, object), QPair<QNdefFilter, QMetaMethod>(filter, method)));
+
+    updateReceiveState();
+
+    return m_handlerID++;
+}
+
+bool QNearFieldManagerPrivateImpl::unregisterNdefMessageHandler(int handlerId)
+{
+    for (int i=0; i<ndefMessageHandlers.count(); ++i) {
+        if (ndefMessageHandlers.at(i).first.first == handlerId) {
+            ndefMessageHandlers.removeAt(i);
+            updateReceiveState();
+            return true;
+        }
+    }
+    for (int i=0; i<ndefFilterHandlers.count(); ++i) {
+        if (ndefFilterHandlers.at(i).first.first == handlerId) {
+            ndefFilterHandlers.removeAt(i);
+            updateReceiveState();
+            return true;
+        }
+    }
+    return false;
+}
+
+void QNearFieldManagerPrivateImpl::requestAccess(QNearFieldManager::TargetAccessModes accessModes)
+{
+    Q_UNUSED(accessModes);
+    //Do nothing, because we dont have access modes for the target
+}
+
+void QNearFieldManagerPrivateImpl::releaseAccess(QNearFieldManager::TargetAccessModes accessModes)
+{
+    Q_UNUSED(accessModes);
+    //Do nothing, because we dont have access modes for the target
+}
+
+void QNearFieldManagerPrivateImpl::newNfc(const QString &tagInfoName)
+{
+    // This function is called from different thread and is used to move intent to main thread.
+     QMetaObject::invokeMethod(this, "onTargetDiscovered", Qt::QueuedConnection, Q_ARG(QString, tagInfoName));
+}
+
+void QNearFieldManagerPrivateImpl::handleStateChanged(int state)
+{
+    QNearFieldManager::AdapterState adapterState = static_cast<QNearFieldManager::AdapterState>((int) state);
+    emit adapterStateChanged(adapterState);
+}
+
+void QNearFieldManagerPrivateImpl::onTargetDiscovered(const QString &tagInfoName)
+{
+    // Getting UID
+    QJsController *jsController = QJsController::instance();
+    QByteArray uid = jsController->tagInfoUid(tagInfoName);
+
+    if (uid.isEmpty())
+        return;
+
+    // Accepting all targets but only sending signal of requested types.
+    NearFieldTarget *&target = m_detectedTargets[uid];
+    if (target) {
+        target->setIndex(tagInfoName);  // Updating existing target
+    } else {
+        target = new NearFieldTarget(tagInfoName, uid, this);
+        connect(target, &NearFieldTarget::targetDestroyed, this, &QNearFieldManagerPrivateImpl::onTargetDestroyed);
+        connect(target, &NearFieldTarget::targetLost, this, &QNearFieldManagerPrivateImpl::targetLost);
+    }
+    emit targetDetected(target);
+}
+
+void QNearFieldManagerPrivateImpl::onTargetDestroyed(const QByteArray &uid)
+{
+    m_detectedTargets.remove(uid);
+}
+
+void QNearFieldManagerPrivateImpl::updateReceiveState()
+{
+    if (m_detecting) {
+        QtHarmonyPrivate::registerNfcListener(this);
+    } else {
+        if (ndefMessageHandlers.count() || ndefFilterHandlers.count()) {
+            QtHarmonyPrivate::registerNfcListener(this);
+        } else {
+            QtHarmonyPrivate::unregisterNfcListener(this);
+        }
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/nfc/qnearfieldmanager_openharmony_p.h b/src/nfc/qnearfieldmanager_openharmony_p.h
new file mode 100644
index 00000000..bb5338fe
--- /dev/null
+++ b/src/nfc/qnearfieldmanager_openharmony_p.h
@@ -0,0 +1,67 @@
+#ifndef QNEARFIELDMANAGER_OPENHARMONY_P_H
+#define QNEARFIELDMANAGER_OPENHARMONY_P_H
+
+#include "qnearfieldmanager_p.h"
+#include "qnearfieldmanager.h"
+#include "qnearfieldtarget.h"
+#include "openharmony/openharmonynfc_p.h"
+
+#include <QHash>
+#include <QMap>
+#include <QSharedPointer>
+
+QT_BEGIN_NAMESPACE
+
+typedef QList<QNdefMessage> QNdefMessageList;
+
+class NearFieldTarget;
+class QByteArray;
+class QNearFieldManagerPrivateImpl : public QNearFieldManagerPrivate
+        , public QtHarmonyPrivate::OpenHarmonyNfcListenerInterface
+        , public QtHarmonyPrivate::OpenHarmonyNfcStateListenerInterface
+{
+    Q_OBJECT
+
+public:
+    QNearFieldManagerPrivateImpl();
+    ~QNearFieldManagerPrivateImpl() override;
+
+    bool isAvailable() const override;
+    bool isSupported() const override;
+    bool startTargetDetection() override;
+    void stopTargetDetection() override;
+    int registerNdefMessageHandler(QObject *object, const QMetaMethod &method) override;
+    int registerNdefMessageHandler(const QNdefFilter &filter, QObject *object, const QMetaMethod &method) override;
+    bool unregisterNdefMessageHandler(int handlerId) override;
+    void requestAccess(QNearFieldManager::TargetAccessModes accessModes) override;
+    void releaseAccess(QNearFieldManager::TargetAccessModes accessModes) override;
+    QByteArray getUid(const QString &tagInfo);
+
+    virtual void newNfc(const QString &tagInfoName);
+    virtual void handleStateChanged(int state);
+
+public slots:
+    void onTargetDiscovered(const QString &tagInfoName);
+    void onTargetDestroyed(const QByteArray &uid);
+    void handlerTargetDetected(QNearFieldTarget *target);
+    void handlerTargetLost(QNearFieldTarget *target);
+    void handlerNdefMessageRead(const QNdefMessage &message, const QNearFieldTarget::RequestId &id);
+    void handlerRequestCompleted(const QNearFieldTarget::RequestId &id);
+    void handlerError(QNearFieldTarget::Error error, const QNearFieldTarget::RequestId &id);
+
+protected:
+    void updateReceiveState();
+
+private:
+    bool m_detecting;
+    QHash<QByteArray, NearFieldTarget*> m_detectedTargets;
+    QMap<QNearFieldTarget::RequestId, QNearFieldTarget*> m_idToTarget;
+
+    int m_handlerID;
+    QList< QPair<QPair<int, QObject *>, QMetaMethod> > ndefMessageHandlers;
+    QList< QPair<QPair<int, QObject *>, QPair<QNdefFilter, QMetaMethod> > > ndefFilterHandlers;
+};
+
+QT_END_NAMESPACE
+
+#endif // QNEARFIELDMANAGER_OPENHARMONY_P_H
diff --git a/src/nfc/qnearfieldtarget_openharmony.cpp b/src/nfc/qnearfieldtarget_openharmony.cpp
new file mode 100644
index 00000000..e716be5f
--- /dev/null
+++ b/src/nfc/qnearfieldtarget_openharmony.cpp
@@ -0,0 +1,373 @@
+#include "qnearfieldtarget_openharmony_p.h"
+#include "qdebug.h"
+
+// #include "qopenharmonyjsobjectloader.h"
+// #include <QOpenHarmonyJsObject>
+
+// from openharmony document https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-nfcTag.md/#taginfo
+#define NDEFTECHNOLOGY              QStringLiteral("6")
+#define NDEFFORMATABLETECHNOLOGY    QStringLiteral("7")
+#define ISODEPTECHNOLOGY            QStringLiteral("3")
+#define NFCATECHNOLOGY              QStringLiteral("1")
+#define NFCBTECHNOLOGY              QStringLiteral("2")
+#define NFCFTECHNOLOGY              QStringLiteral("4")
+#define NFCVTECHNOLOGY              QStringLiteral("5")
+#define MIFARECLASSICTECHNOLOGY     QStringLiteral("8")
+#define MIFARECULTRALIGHTTECHNOLOGY QStringLiteral("9")
+
+#define MIFARETAG   QStringLiteral("com.nxp.ndef.mifareclassic")
+#define NFCTAGTYPE1 QStringLiteral("org.nfcforum.ndef.type1")
+#define NFCTAGTYPE2 QStringLiteral("org.nfcforum.ndef.type2")
+#define NFCTAGTYPE3 QStringLiteral("org.nfcforum.ndef.type3")
+#define NFCTAGTYPE4 QStringLiteral("org.nfcforum.ndef.type4")
+
+NearFieldTarget::NearFieldTarget(const QString &tag, const QByteArray &uid, QObject *parent) :
+    QNearFieldTarget(parent),
+    m_tag(tag),
+    m_uid(uid),
+      m_keepConnection(false)
+{
+    QJsController *jsController = QJsController::instance();
+    auto tagSession = jsController->getTagSession(m_tag);
+    if(tagSession){
+        m_jsTag = QSharedPointer<JsTagSession>(tagSession);
+    }
+    updateTechList();
+    updateType();
+    setupTargetCheckTimer();
+}
+
+NearFieldTarget::~NearFieldTarget()
+{
+    releaseIntent();
+    emit targetDestroyed(m_uid);
+}
+
+QByteArray NearFieldTarget::uid() const
+{
+    return m_uid;
+}
+
+QNearFieldTarget::Type NearFieldTarget::type() const
+{
+    return m_type;
+}
+
+QNearFieldTarget::AccessMethods NearFieldTarget::accessMethods() const
+{
+    AccessMethods result = UnknownAccess;
+
+    if (m_techList.contains(NDEFTECHNOLOGY)
+            || m_techList.contains(NDEFFORMATABLETECHNOLOGY))
+        result |= NdefAccess;
+
+    if (m_techList.contains(ISODEPTECHNOLOGY)
+            || m_techList.contains(NFCATECHNOLOGY)
+            || m_techList.contains(NFCBTECHNOLOGY)
+            || m_techList.contains(NFCFTECHNOLOGY)
+            || m_techList.contains(NFCVTECHNOLOGY))
+        result |= TagTypeSpecificAccess;
+
+    return result;
+}
+
+bool NearFieldTarget::keepConnection() const
+{
+    return m_keepConnection;
+}
+
+bool NearFieldTarget::setKeepConnection(bool isPersistent)
+{
+    m_keepConnection = isPersistent;
+
+    if (!m_keepConnection)
+        disconnect();
+
+    return true;
+}
+
+bool NearFieldTarget::disconnect()
+{
+    bool connected = m_jsTag->isConnected();
+
+    if (!connected)
+        return false;
+
+    return m_jsTag->close();
+}
+
+bool NearFieldTarget::hasNdefMessage()
+{
+    return m_techList.contains(NDEFTECHNOLOGY);
+}
+
+QNearFieldTarget::RequestId NearFieldTarget::readNdefMessages()
+{
+    // Making sure that target has NDEF messages
+    if (!hasNdefMessage())
+        return QNearFieldTarget::RequestId();
+
+    // Making sure that target is still in range
+    QNearFieldTarget::RequestId requestId(new QNearFieldTarget::RequestIdPrivate);
+    bool valid = m_jsTag->isInRange();
+    if (!valid) {
+        reportError(QNearFieldTarget::TargetOutOfRangeError, requestId);
+        return requestId;
+    }
+
+    QByteArray result = m_jsTag->getNdefMessage();
+    if (result.isEmpty())
+        return requestId;
+
+    if (!m_keepConnection) {
+        // Closing connection
+        disconnect();   // IOException at this point does not matter anymore.
+    }
+
+    // Sending QNdefMessage, requestCompleted and exit.
+    QNdefMessage qNdefMessage = QNdefMessage::fromByteArray(result);
+    QMetaObject::invokeMethod(this, [this, qNdefMessage]() {
+        Q_EMIT this->QNearFieldTarget::ndefMessageRead(qNdefMessage);
+    }, Qt::QueuedConnection);
+    QMetaObject::invokeMethod(this, [this, requestId]() {
+        Q_EMIT this->requestCompleted(requestId);
+    }, Qt::QueuedConnection);
+    QMetaObject::invokeMethod(this, [this, qNdefMessage, requestId]() {
+        //TODO This is an Android specific signal in NearFieldTarget.
+        //     We need to check if it is still necessary.
+        Q_EMIT this->ndefMessageRead(qNdefMessage, requestId);
+    }, Qt::QueuedConnection);
+    return requestId;
+}
+
+int NearFieldTarget::maxCommandLength() const
+{
+    return m_jsTag->maxCommandLength();
+}
+
+QNearFieldTarget::RequestId NearFieldTarget::sendCommand(const QByteArray &command)
+{
+    if (command.size() == 0 || command.size() > maxCommandLength()) {
+        Q_EMIT QNearFieldTarget::error(QNearFieldTarget::InvalidParametersError, QNearFieldTarget::RequestId());
+        return QNearFieldTarget::RequestId();
+    }
+
+    // Making sure that target has commands
+    if (!(accessMethods() & TagTypeSpecificAccess))
+        return QNearFieldTarget::RequestId();
+
+
+    if (!setTagTechnology({ISODEPTECHNOLOGY, NFCATECHNOLOGY, NFCBTECHNOLOGY, NFCFTECHNOLOGY, NFCVTECHNOLOGY})) {
+        Q_EMIT QNearFieldTarget::error(QNearFieldTarget::UnsupportedError, QNearFieldTarget::RequestId());
+        return QNearFieldTarget::RequestId();
+    }
+
+    // Connecting
+    QNearFieldTarget::RequestId requestId = QNearFieldTarget::RequestId(new QNearFieldTarget::RequestIdPrivate());
+    if (!connect()) {
+        reportError(QNearFieldTarget::TargetOutOfRangeError, requestId);
+        return requestId;
+    }
+
+    // Writing
+    QByteArray result = m_jsTag->transceive(command);
+
+    handleResponse(requestId, result);
+
+    if (!m_keepConnection) {
+        // Closing connection
+        disconnect();   // IOException at this point does not matter anymore.
+    }
+    QMetaObject::invokeMethod(this, [this, requestId]() {
+        Q_EMIT this->requestCompleted(requestId);
+    }, Qt::QueuedConnection);
+
+    return requestId;
+}
+
+QNearFieldTarget::RequestId NearFieldTarget::sendCommands(const QList<QByteArray> &commands)
+{
+    QNearFieldTarget::RequestId requestId;
+    for (int i=0; i < commands.size(); i++)
+        requestId = sendCommand(commands.at(i));
+    return requestId;
+}
+
+QNearFieldTarget::RequestId NearFieldTarget::writeNdefMessages(const QList<QNdefMessage> &messages)
+{
+    if (messages.size() == 0)
+        return QNearFieldTarget::RequestId();
+
+    if (messages.size() > 1)
+        qWarning("QNearFieldTarget::writeNdefMessages: harmony supports writing only one NDEF message per tag.");
+
+    QString writeMethod;
+    // Getting write method
+    // if (m_tech == NDEFFORMATABLETECHNOLOGY)
+    //     writeMethod = "format";
+    // else
+    //     writeMethod = "writeNdefMessage";
+
+    if (!setTagTechnology({NDEFFORMATABLETECHNOLOGY, NDEFTECHNOLOGY}))
+        return QNearFieldTarget::RequestId();
+
+    // Connecting
+    QNearFieldTarget::RequestId requestId = QNearFieldTarget::RequestId(new QNearFieldTarget::RequestIdPrivate());
+    if (!connect()) {
+        reportError(QNearFieldTarget::TargetOutOfRangeError, requestId);
+        return requestId;
+    }
+
+    const QNdefMessage &message = messages.first();
+    QByteArray ba = message.toByteArray();
+    if (m_tech == NDEFFORMATABLETECHNOLOGY)
+        m_jsTag->format(ba);
+    else
+        m_jsTag->writeNdefMessage(ba);
+
+    if (!m_keepConnection)
+        disconnect();   // IOException at this point does not matter anymore.
+    QMetaObject::invokeMethod(this, "ndefMessagesWritten", Qt::QueuedConnection);
+    return requestId;
+}
+
+void NearFieldTarget::setIndex(const QString &tag)
+{
+    if (m_tag == tag)
+        return;
+
+    releaseIntent();
+    m_tag = tag;
+    updateTechList();
+    updateType();
+    m_targetCheckTimer->start();
+}
+
+void NearFieldTarget::checkIsTargetLost()
+{
+//    if (!m_intent.isValid() || !setTagTechnology(m_techList)) {
+//        handleTargetLost();
+//        return;
+//    }
+
+//    bool connected = m_tagTech.callMethod<jboolean>("isConnected");
+//    if (catchJavaExceptions()) {
+//        handleTargetLost();
+//        return;
+//    }
+
+//    if (connected)
+//        return;
+
+//    m_tagTech.callMethod<void>("connect");
+//    if (catchJavaExceptions(false)) {
+//        handleTargetLost();
+//        return;
+//    }
+//    m_tagTech.callMethod<void>("close");
+//    if (catchJavaExceptions(false))
+//        handleTargetLost();
+}
+
+void NearFieldTarget::releaseIntent()
+{
+    m_targetCheckTimer->stop();
+}
+
+void NearFieldTarget::updateTechList()
+{
+    QString str = m_jsTag->technologies();
+    if (str.isEmpty()) {
+        return;
+    }
+    m_techList = str.split(",");
+}
+
+void NearFieldTarget::updateType()
+{
+    m_type = getTagType();
+}
+
+QNearFieldTarget::Type NearFieldTarget::getTagType() const
+{
+    if (m_techList.contains(NDEFTECHNOLOGY)) {
+        QString qtype = m_jsTag->getType();
+
+        if (qtype.compare(MIFARETAG) == 0)
+            return MifareTag;
+        if (qtype.compare(NFCTAGTYPE1) == 0)
+            return NfcTagType1;
+        if (qtype.compare(NFCTAGTYPE2) == 0)
+            return NfcTagType2;
+        if (qtype.compare(NFCTAGTYPE3) == 0)
+            return NfcTagType3;
+        if (qtype.compare(NFCTAGTYPE4) == 0)
+            return NfcTagType4;
+        return ProprietaryTag;
+    } else if (m_techList.contains(NFCATECHNOLOGY)) {
+        if (m_techList.contains(MIFARECLASSICTECHNOLOGY))
+            return MifareTag;
+
+        // Checking ATQA/SENS_RES
+        // xxx0 0000  xxxx xxxx: Identifies tag Type 1 platform
+        QByteArray atqaQBA = m_jsTag->getAtqa();
+        if (atqaQBA.isEmpty())
+            return ProprietaryTag;
+        if ((atqaQBA[0] & 0x1F) == 0x00)
+            return NfcTagType1;
+
+        // Checking SAK/SEL_RES
+        // xxxx xxxx  x00x x0xx: Identifies tag Type 2 platform
+        // xxxx xxxx  x01x x0xx: Identifies tag Type 4 platform
+        int sakS = m_jsTag->getSak();
+        if ((sakS & 0x0064) == 0x0000)
+            return NfcTagType2;
+        else if ((sakS & 0x0064) == 0x0020)
+            return NfcTagType4;
+        return ProprietaryTag;
+    } else if (m_techList.contains(NFCBTECHNOLOGY)) {
+        return NfcTagType4;
+    } else if (m_techList.contains(NFCFTECHNOLOGY)) {
+        return NfcTagType3;
+    }
+
+    return ProprietaryTag;
+}
+
+void NearFieldTarget::setupTargetCheckTimer()
+{
+    m_targetCheckTimer = new QTimer(this);
+    m_targetCheckTimer->setInterval(1000);
+    QObject::connect(m_targetCheckTimer, &QTimer::timeout, this, &NearFieldTarget::checkIsTargetLost);
+    m_targetCheckTimer->start();
+}
+
+void NearFieldTarget::handleTargetLost()
+{
+    releaseIntent();
+    emit targetLost(this);
+}
+
+bool NearFieldTarget::setTagTechnology(const QStringList &techList)
+{
+    for (const QString &tech : techList) {
+        if (m_techList.contains(tech)) {
+            if (m_tech == tech) {
+                return true;
+            }
+            m_tech = tech;
+            return true;
+        }
+    }
+    return false;
+}
+
+bool NearFieldTarget::connect()
+{
+    bool connected = m_jsTag->isConnected();
+
+    if (connected)
+        return true;
+
+    return m_jsTag->connect();
+}
diff --git a/src/nfc/qnearfieldtarget_openharmony_p.cpp b/src/nfc/qnearfieldtarget_openharmony_p.cpp
new file mode 100644
index 00000000..f7bc0390
--- /dev/null
+++ b/src/nfc/qnearfieldtarget_openharmony_p.cpp
@@ -0,0 +1,32 @@
+#include <QCoreApplication>
+
+#include "qnearfieldtarget_p.h"
+#include "qnearfieldtarget_openharmony_p.h"
+
+QT_BEGIN_NAMESPACE
+
+bool QNearFieldTargetPrivate::keepConnection() const
+{
+    NEARFIELDTARGET_Q();
+    return q->keepConnection();
+}
+
+bool QNearFieldTargetPrivate::setKeepConnection(bool isPersistent)
+{
+    NEARFIELDTARGET_Q();
+    return q->setKeepConnection(isPersistent);
+}
+
+bool QNearFieldTargetPrivate::disconnect()
+{
+    NEARFIELDTARGET_Q();
+    return q->disconnect();
+}
+
+int QNearFieldTargetPrivate::maxCommandLength() const
+{
+    NEARFIELDTARGET_Q();
+    return q->maxCommandLength();
+}
+
+QT_END_NAMESPACE
diff --git a/src/nfc/qnearfieldtarget_openharmony_p.h b/src/nfc/qnearfieldtarget_openharmony_p.h
new file mode 100644
index 00000000..aa4200a7
--- /dev/null
+++ b/src/nfc/qnearfieldtarget_openharmony_p.h
@@ -0,0 +1,72 @@
+#ifndef QNEARFIELDTARGET_OPENHARMONY_P_H
+#define QNEARFIELDTARGET_OPENHARMONY_P_H
+
+
+#include "qnearfieldtarget.h"
+#include "qnearfieldtarget_p.h"
+#include "qndefmessage.h"
+#include "qlist.h"
+#include "qstringlist.h"
+#include <QTimer>
+#include <QSharedPointer>
+// class QOpenHarmonyJsObject;
+
+// #include "openharmony/jsclass/qjstag.h"
+#include "openharmony/jsclass/qjscontroller.h"
+
+QT_BEGIN_NAMESPACE
+
+class NearFieldTarget : public QNearFieldTarget
+{
+    Q_OBJECT
+public:
+    NearFieldTarget(const QString &tag, const QByteArray &uid,
+                    QObject *parent = 0);
+    virtual ~NearFieldTarget();
+    virtual QByteArray uid() const;
+    virtual Type type() const;
+    virtual AccessMethods accessMethods() const;
+    bool keepConnection() const;
+    bool setKeepConnection(bool isPersistent);
+    bool disconnect();
+    virtual bool hasNdefMessage();
+    virtual RequestId readNdefMessages();
+    int maxCommandLength() const;
+    virtual RequestId sendCommand(const QByteArray &command);
+    virtual RequestId sendCommands(const QList<QByteArray> &commands);
+    virtual RequestId writeNdefMessages(const QList<QNdefMessage> &messages);
+    void setIndex(const QString &tag);
+
+signals:
+    void targetDestroyed(const QByteArray &tagId);
+    void targetLost(QNearFieldTarget *target);
+    void ndefMessageRead(const QNdefMessage &message, const QNearFieldTarget::RequestId &id);
+
+protected slots:
+    void checkIsTargetLost();
+
+protected:
+    void releaseIntent();
+    void updateTechList();
+    void updateType();
+    Type getTagType() const;
+    void setupTargetCheckTimer();
+    void handleTargetLost();
+    bool setTagTechnology(const QStringList &techList);
+    bool connect();
+
+protected:
+    QString m_tag;
+    // QSharedPointer<QOpenHarmonyJsObject> m_jsTag;
+    QSharedPointer<JsTagSession> m_jsTag;
+    QByteArray m_uid;
+    QStringList m_techList;
+    Type m_type;
+    QTimer *m_targetCheckTimer;
+    QString m_tech;
+    bool m_keepConnection;
+};
+
+QT_END_NAMESPACE
+
+#endif // QNEARFIELDTARGET_OPENHARMONY_P_H
diff --git a/src/openharmony/bluetooth/bluetooth.pro b/src/openharmony/bluetooth/bluetooth.pro
new file mode 100644
index 00000000..fa4a2436
--- /dev/null
+++ b/src/openharmony/bluetooth/bluetooth.pro
@@ -0,0 +1,9 @@
+TEMPLATE = aux
+
+CONFIG -= qt
+
+templates.files += $$files($$PWD/native/QtBluetooth/*.ts, true)
+templates.path = $$[QT_INSTALL_PREFIX]/openharmony/qtconnectivity
+templates.base = $$PWD
+
+INSTALLS += templates
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetooth.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetooth.ts
new file mode 100644
index 00000000..aa65a203
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetooth.ts
@@ -0,0 +1,25 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+
+export class QtBluetooth {
+
+  private deviceId = ''
+  private clientSocket = null
+  private ble : boolean = false;
+
+  constructor(deviceId : string, isBle: boolean) {
+    this.deviceId = deviceId;
+    this.ble = isBle;
+  }
+
+  getClass() {
+    return bluetoothManager.getRemoteDeviceClass(this.deviceId).classOfDevice;
+  }
+
+  getName() {
+    return bluetoothManager.getRemoteDeviceName(this.deviceId);
+  }
+
+  isBLE() : boolean {
+    return this.ble
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothBroadcastReceiver.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothBroadcastReceiver.ts
new file mode 100644
index 00000000..7c15cf3a
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothBroadcastReceiver.ts
@@ -0,0 +1,6 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+
+export class QtBluetoothBroadcastReceiver {
+  // bluetoothManager.on(‘pinRequired’)
+
+}
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothDevice.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothDevice.ts
new file mode 100644
index 00000000..7d09433d
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothDevice.ts
@@ -0,0 +1,31 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+import { QtBluetoothSocket } from './QtBluetoothSocket';
+
+export class QtBluetoothDevice {
+
+  private deviceId = ''
+  private clientSocket = null
+
+  constructor(deviceId) {
+    this.deviceId = deviceId;
+  }
+
+  getClass() {
+    return bluetoothManager.getRemoteDeviceClass(this.deviceId).classOfDevice;
+  }
+
+  getName() {
+    return bluetoothManager.getRemoteDeviceName(this.deviceId);
+  }
+
+  createSocket(name, id) {
+    let socket = new QtBluetoothSocket(id);
+    Reflect.defineProperty(globalThis, name, {value: socket});
+    return true;
+  }
+
+  closeSocket(name) {
+    Reflect.deleteProperty(globalThis, name);
+    return true;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattServer.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattServer.ts
new file mode 100644
index 00000000..ea05870c
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattServer.ts
@@ -0,0 +1,257 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+import HashMap from '@ohos.util.HashMap';
+import { QtBluetoothGattService } from './QtBluetoothGattService'
+import { QtBluetoothGattServerCallback } from './QtBluetoothGattServerCallback'
+
+export class QtBluetoothGattServer {
+  private gattServer : bluetoothManager.GattServer;
+  private qtObject : number;
+  private services : HashMap<string, QtBluetoothGattService>;
+  private devices : Array<string> = [];
+  private deviceId : string = '';
+  private callback : QtBluetoothGattServerCallback;
+
+  constructor() {
+    this.services = new HashMap();
+  }
+
+  setQtObject(qtObject: number) {
+    this.qtObject = qtObject;
+  }
+
+  getQtObject() : number {
+    return this.qtObject;
+  }
+
+  server() : bluetoothManager.GattServer {
+    return this.gattServer;
+  }
+
+  addDevice(deviceId: string) {
+    if (this.devices.indexOf(deviceId) == -1)
+      this.devices.push(deviceId)
+    this.deviceId = deviceId;
+  }
+
+  connectServer() : boolean {
+    if (this.gattServer)
+      return true;
+    this.gattServer = bluetoothManager.BLE.createGattServer();
+    return true;
+  }
+
+  disconnectServer() : boolean {
+    if (!this.gattServer)
+      return;
+
+    this.callback.stop();
+    this.gattServer.close();
+    this.callback = null;
+    this.gattServer = null;
+    globalThis.qtbluetooth.connectChanged(this.qtObject, 0 /*NoError*/, 0 /*QLowEnergyController::UnconnectedState*/);
+    return true;
+  }
+
+  startAdvertising(advertiseData : object, scanResponse : object, advertiseSettings : object) : boolean {
+    if (!this.connectServer()) {
+      console.error("Server::startAdvertising: Cannot open GATT server");
+      return false;
+    }
+    this.callback = new QtBluetoothGattServerCallback(this);
+    this.callback.start();
+
+    if (!this.gattServer)
+      return false;
+
+    console.log("Starting to advertise.", JSON.stringify(advertiseData), JSON.stringify(scanResponse), JSON.stringify(advertiseSettings));
+    try {
+
+      let _settings : bluetoothManager.AdvertiseSetting  = {
+        interval:advertiseSettings["maximumInterval"],
+        connectable:advertiseSettings["connectable"],
+      }
+
+      let _advertiseData : bluetoothManager.AdvertiseData = {
+        serviceUuids: advertiseData["serviceUuids"],
+        manufactureData:[],
+        serviceData:[],
+        includeDeviceName: advertiseData["includeDeviceName"]
+      }
+
+      if (advertiseData.hasOwnProperty("manufacturerId") && advertiseData.hasOwnProperty("manufacturerData")) {
+        let manufacturerData : bluetoothManager.ManufactureData;
+        manufacturerData.manufactureId = advertiseData["manufacturerId"];
+        manufacturerData.manufactureValue = advertiseData["manufacturerData"];
+        _advertiseData.manufactureData.push(manufacturerData)
+      }
+
+      let _scanResponse : bluetoothManager.AdvertiseData = {
+        serviceUuids: scanResponse["serviceUuids"],
+        manufactureData:[],
+        serviceData:[]
+      }
+      if (scanResponse.hasOwnProperty("manufacturerId") && scanResponse.hasOwnProperty("manufacturerData")) {
+        let manufacturerData : bluetoothManager.ManufactureData;
+        manufacturerData.manufactureId = scanResponse["manufacturerId"];
+        manufacturerData.manufactureValue = scanResponse["manufacturerData"];
+        _scanResponse.manufactureData.push(manufacturerData)
+      }
+      this.gattServer.startAdvertising(_settings, _advertiseData, _scanResponse);
+      return true;
+    } catch (err) {
+      console.error("startAdvertising errCode:" + err.code + ",errMessage:" + err.message);
+      globalThis.qtbluetooth.advertisementError(this.qtObject, err.message);
+      return false;
+    }
+  }
+
+  stopAdvertising() : void
+  {
+    if (!this.gattServer)
+      return;
+
+    try {
+      this.gattServer.stopAdvertising();
+      console.log("Advertisement stopped.");
+    } catch (err) {
+      console.error("stopAdvertising errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+
+  createService(service: string, uuid: string, isPrimary: boolean) : boolean {
+    if (this.services.hasKey(service))
+      return false;
+    let s : QtBluetoothGattService = new QtBluetoothGattService(uuid, isPrimary);
+    this.services.set(service, s);
+    Reflect.defineProperty(globalThis, service, {value: s});
+    this.addIncludeService(service);
+    return true;
+  }
+
+  addIncludeService(service: string) : boolean {
+    if (!this.connectServer()) {
+      console.log("Server::addService: Cannot open GATT server");
+      return false;
+    }
+    if (!this.services.hasKey(service))
+      return false;
+    this.gattServer.addService(this.services.get(service).service());
+    return true;
+  }
+
+  getCharacteristic(serviceUuid: string, charUuid: string) : bluetoothManager.BLECharacteristic {
+    for (let item of this.services) {
+      let c = item[1].service().characteristics;
+      for (let i = 0 ; i < c.length; ++i) {
+        if (c[i].serviceUuid == serviceUuid && c[i].characteristicUuid == charUuid)
+          return c[i];
+      }
+    }
+    return null
+  }
+
+  getDescriptor(serviceUuid: string, charUuid: string, descUuid: string) : bluetoothManager.BLEDescriptor {
+    for (let item of this.services) {
+      let c = item[1].service().characteristics;
+      for (let i = 0 ; i < c.length; ++i) {
+        let d = c[i].descriptors;
+        for (let j = 0; j < d.length; ++j) {
+          if (d[j].serviceUuid == serviceUuid
+            && d[j].characteristicUuid == charUuid
+            && d[j].descriptorUuid == descUuid) {
+            return d[j];
+          }
+        }
+      }
+    }
+    return null
+  }
+
+  writeCharacteristic(service: string, uuid: string, value: ArrayBuffer) : boolean {
+    console.log("writeCharacteristic", service, uuid);
+    if (!this.services.hasKey(service))
+      return false;
+    let s = this.services.get(service);
+    let gattService = s.service();
+    let foundChar : bluetoothManager.BLECharacteristic = null;
+    let cArray : Array<bluetoothManager.BLECharacteristic> = gattService.characteristics;
+    for (let i = 0; i < cArray.length; ++i) {
+      let c = cArray[i];
+      if (c.characteristicUuid == uuid && foundChar == null) {
+          foundChar = c;
+          // don't break here since we want to check next condition below on next iteration
+      } else if (c.characteristicUuid == uuid) {
+          console.error("Found second char with same UUID. Wrong char may have been selected.");
+          break;
+      }
+    }
+
+    if (foundChar == null) {
+        console.error("writeCharacteristic: update for unknown characteristic failed");
+        return false;
+    }
+
+    foundChar.characteristicValue = value;
+    this.sendNotificationsOrIndications(foundChar);
+
+    return true;
+  }
+
+  sendNotificationsOrIndications(characteristic: bluetoothManager.BLECharacteristic) : void {
+    if (!this.gattServer)
+      return;
+    for (let i = 0; i < this.devices.length; ++i) {
+      let notifyCharacteristic = {
+        serviceUuid: characteristic.serviceUuid,
+        characteristicUuid: characteristic.characteristicUuid,
+        characteristicValue: characteristic.characteristicValue,
+        confirm: false
+      };
+      this.gattServer.notifyCharacteristicChanged(this.devices[i], notifyCharacteristic);
+    }
+  }
+
+  writeDescriptor(service: string, charUuid: string, descUuid: string, value: ArrayBuffer) : boolean {
+    if (!this.services.hasKey(service))
+      return false;
+    let s = this.services.get(service);
+    let gattService = s.service();
+    let foundDesc : bluetoothManager.BLEDescriptor = null;
+    let foundChar : bluetoothManager.BLECharacteristic = null;
+    let cArray : Array<bluetoothManager.BLECharacteristic> = gattService.characteristics;
+    for (let i = 0; i < cArray.length; ++i) {
+      let c = cArray[i];
+      if (c.characteristicUuid == charUuid && foundChar == null) {
+        foundChar = c;
+        // don't break here since we want to check next condition below on next iteration
+      } else if (c.characteristicUuid == charUuid) {
+        console.error("Found second char with same UUID. Wrong char may have been selected.");
+        break;
+      }
+    }
+
+    for (let i = 0; i < foundChar.descriptors.length; ++i) {
+      let d = foundChar.descriptors[i];
+      if (d.descriptorUuid == descUuid) {
+        foundDesc = d;
+        break;
+      }
+    }
+
+    if (foundChar == null || foundDesc == null) {
+      console.error("writeDescriptor: update for unknown char or desc failed (" + foundChar + ")");
+      return false;
+    }
+
+    foundDesc.descriptorValue = value;
+    return true;
+  }
+
+  remoteName() : string {
+    return bluetoothManager.getRemoteDeviceName(this.deviceId);
+  }
+
+  remoteAddress() : string {
+    return this.deviceId;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattServerCallback.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattServerCallback.ts
new file mode 100644
index 00000000..a4dbe238
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattServerCallback.ts
@@ -0,0 +1,140 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+import { QtBluetoothGattServer } from './QtBluetoothGattServer'
+
+export class QtBluetoothGattServerCallback {
+
+  private gattServer : QtBluetoothGattServer;
+
+  constructor(gattServer : QtBluetoothGattServer) {
+    this.gattServer = gattServer;
+
+  }
+
+  start() {
+    let s = this.gattServer.server();
+
+    s.on("connectStateChange", (state : bluetoothManager.BLEConnectChangedState) => {
+      let deviceId : string = state.deviceId;
+      let s : bluetoothManager.ProfileConnectionState = state.state;
+      console.log("Our gatt server connection state changed, new state: " + deviceId + bluetoothManager.getRemoteDeviceName(deviceId));
+      let qtControllerState : number = 0;
+      if (s == bluetoothManager.ProfileConnectionState.STATE_DISCONNECTED)
+        qtControllerState = 0;// QLowEnergyController::UnconnectedState
+      else if (s = bluetoothManager.ProfileConnectionState.STATE_CONNECTED)
+        qtControllerState = 2;
+
+      this.gattServer.addDevice(deviceId);
+      globalThis.qtbluetooth.connectionChanged(this.gattServer.getQtObject(), 0 /*NoError*/, qtControllerState /*QLowEnergyController::UnconnectedState*/);
+    });
+
+    s.on("characteristicRead", (request: bluetoothManager.CharacteristicReadRequest) => {
+      let deviceId = request.deviceId;
+      let transId = request.transId;
+      let offset = request.offset;
+      let characteristicUuid = request.characteristicUuid;
+      console.log("onCharacteristicRead", deviceId, transId, offset, characteristicUuid);
+      let c = this.gattServer.getCharacteristic(request.serviceUuid, request.characteristicUuid);
+      let serverResponse = {deviceId: deviceId, transId: transId, status: 0, offset: offset, value: null};
+      if (c != null) {
+        serverResponse.value = c.characteristicValue.slice(offset);
+      }
+
+      try {
+          this.gattServer.server().sendResponse(serverResponse);
+      } catch (err) {
+          console.error("onCharacteristicRead errCode:" + err.code + ",errMessage:" + err.message);
+          this.gattServer.server().sendResponse({deviceId: deviceId, transId: transId, status: -1, offset: offset, value: null});
+      }
+    });
+
+    s.on("characteristicWrite", (request: bluetoothManager.CharacteristicWriteRequest) => {
+      let deviceId = request.deviceId;
+      let transId = request.transId;
+      let offset = request.offset;
+      let isPrep = request.isPrep;
+      let needRsp = request.needRsp;
+      console.log("onCharacteristicWrite", deviceId, transId, offset, isPrep, needRsp);
+      let sendNotificationOrIndication :boolean = false;
+      let characteristic : bluetoothManager.BLECharacteristic = {
+        characteristicUuid: request.characteristicUuid,
+        characteristicValue: request.value,
+        serviceUuid: request.serviceUuid,
+        descriptors: []
+      };
+      let status = 0
+      if (!isPrep) { // regular write
+        if (offset == 0) {
+            globalThis.qtbluetooth.serverCharacteristicChanged(this.gattServer.getQtObject(), request.serviceUuid, request.characteristicUuid, request.value);
+            sendNotificationOrIndication = true;
+          } else {
+            console.warn("onCharacteristicWriteRequest: !preparedWrite, offset " + offset + ", Not supported");
+            status = -1;
+          }
+      } else {
+        console.warn("onCharacteristicWriteRequest: preparedWrite, offset " + offset + ", Not supported");
+        status = -1;
+      }
+
+      if (needRsp)
+        this.gattServer.server().sendResponse({deviceId: deviceId, transId: transId, status: status, offset: offset, value: request.value});
+      if (sendNotificationOrIndication)
+        this.gattServer.sendNotificationsOrIndications(characteristic);
+    });
+
+    s.on("descriptorRead", (request: bluetoothManager.DescriptorReadRequest) => {
+      let deviceId = request.deviceId;
+      let transId = request.transId;
+      let offset = request.offset;
+      let descriptorUuid = request.descriptorUuid;
+
+      console.log("onDescriptorRead", deviceId, transId, offset, descriptorUuid);
+      let d = this.gattServer.getDescriptor(request.serviceUuid, request.characteristicUuid, request.descriptorUuid);
+      let serverResponse = {deviceId: deviceId, transId: transId, status: 0, offset: offset, value: null};
+      if (d != null) {
+        serverResponse.value = d.descriptorValue.slice(offset);
+      }
+
+      try {
+        this.gattServer.server().sendResponse(serverResponse);
+      } catch (err) {
+        console.error("onDescriptorRead errCode:" + err.code + ",errMessage:" + err.message);
+        this.gattServer.server().sendResponse({deviceId: deviceId, transId: transId, status: -1, offset: offset, value: null});
+      }
+    });
+
+    s.on("descriptorWrite", (request: bluetoothManager.DescriptorWriteRequest) => {
+      let deviceId = request.deviceId;
+      let transId = request.transId;
+      let offset = request.offset;
+      let isPrep = request.isPrep;
+      let needRsp = request.needRsp;
+      let status = 0;
+      console.log("onDescriptorWrite", deviceId, transId, offset, isPrep, needRsp);
+      if (!isPrep) { // regular write
+        if (offset == 0) {
+          globalThis.qtbluetooth.serverDescriptorWritten(this.gattServer.getQtObject(), request.serviceUuid, request.characteristicUuid, request.descriptorUuid, request.value);
+          status = -1;
+        } else {
+          console.warn("onDescriptorWriteRequest: !preparedWrite, offset " + offset + ", Not supported");
+        }
+      } else {
+        console.warn("onDescriptorWriteRequest: preparedWrite, offset " + offset + ", Not supported");
+        status = -1;
+      }
+
+
+      if (needRsp)
+        this.gattServer.server().sendResponse({deviceId: deviceId, transId: transId, status: status, offset: offset, value: request.value});
+    });
+  }
+
+  stop() {
+    let s = this.gattServer.server();
+    s.off("connectStateChange");
+    s.off("characteristicRead");
+    s.off("characteristicWrite");
+    s.off("descriptorRead");
+    s.off("descriptorWrite");
+  }
+
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattService.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattService.ts
new file mode 100644
index 00000000..3e3c81c7
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothGattService.ts
@@ -0,0 +1,65 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+
+export class QtBluetoothGattService {
+
+  private uuid : string = ''
+  private gattService : bluetoothManager.GattService = null;
+
+  constructor(uuid: string, isPrimary: boolean) {
+    this.uuid = uuid;
+    this.gattService = {
+      serviceUuid: uuid,
+      isPrimary: isPrimary,
+      characteristics: []
+    };
+  }
+
+  service() : bluetoothManager.GattService {
+    return this.gattService;
+  }
+
+  addCharacteristic(uuid, p, data) : boolean {
+    if (!this.gattService)
+      return;
+
+    let pro : bluetoothManager.GattProperties = {
+      write: Boolean(p & 0x08),
+      writeNoResponse: Boolean(p & 0x04),
+      read: Boolean(p & 0x02),
+      notify: Boolean(p & 0x10),
+      indicate: Boolean(p & 0x20)
+    }
+
+    let characteristic : bluetoothManager.BLECharacteristic = {
+      serviceUuid : this.uuid,
+      characteristicUuid : uuid,
+      characteristicValue: data,
+      descriptors: [],
+      properties: pro
+    }
+
+    this.gattService.characteristics.push(characteristic);
+    return true;
+  }
+
+  addDescriptor(cuuid, duuid, data) {
+    if (!this.gattService)
+      return false;
+
+    for (let i = 0; i < this.gattService.characteristics.length; ++i) {
+      let characteristic : bluetoothManager.BLECharacteristic = this.gattService.characteristics[i];
+      if (characteristic.characteristicUuid === cuuid) {
+        let descriptor : bluetoothManager.BLEDescriptor = {
+          serviceUuid : this.uuid,
+          characteristicUuid : cuuid,
+          descriptorUuid: duuid,
+          descriptorValue: data
+        }
+        characteristic.descriptors.push(descriptor);
+        return true;
+      }
+    }
+    return false;
+  }
+
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothLE.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothLE.ts
new file mode 100644
index 00000000..f81405e2
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothLE.ts
@@ -0,0 +1,658 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+import HashMap from '@ohos.util.HashMap';
+import LinkedList from '@ohos.util.LinkedList';
+
+export class ConnectionState {
+  static STATE_CONNECTING = 1;
+  static STATE_CONNECTED = 2;
+  static STATE_DISCONNECTING = 3;
+  static STATE_DISCONNECTED = 4;
+}
+
+enum GattEntryType
+{
+  Service, Characteristic, CharacteristicValue, Descriptor
+};
+
+class GattEntry
+{
+  type : GattEntryType;
+  valueKnown : boolean = false;
+  service: bluetoothManager.GattService = null;
+  characteristic : bluetoothManager.BLECharacteristic = null;
+  descriptor : bluetoothManager.BLEDescriptor = null;
+  endHandle : number = -1;
+  associatedServiceHandle : number;
+}
+
+export class QtBluetoothLE {
+
+  private address = null;
+  private qtObject;
+  private gattClient : bluetoothManager.GattClientDevice = null;
+  private state : ConnectionState = ConnectionState.STATE_DISCONNECTED;
+  private entries : GattEntry[] = [];
+  private uuidToEntry : HashMap<string, Array<number>>;
+  private servicesToBeDiscovered : LinkedList<number>;
+
+  constructor(address) {
+    this.address = address;
+    this.uuidToEntry = new HashMap();
+    this.servicesToBeDiscovered = new LinkedList();
+  }
+
+  setQtObject(qtObject) {
+    this.qtObject = qtObject;
+  }
+
+  private onBLEConnectionStateChange() {
+    if (!this.gattClient) {
+      return;
+    }
+    try {
+      this.gattClient.on('BLEConnectionStateChange', async (data: bluetoothManager.BLEConnectChangedState) => {
+        let deviceId: string = data.deviceId;
+        let state: bluetoothManager.ProfileConnectionState = data.state;
+        if (data) {
+          if (state === bluetoothManager.ProfileConnectionState.STATE_CONNECTED) {
+            try {
+              // Starts discovering services.
+              this.state = ConnectionState.STATE_CONNECTED;
+              globalThis.qtbluetooth.connectChanged(this.qtObject, 3, 0);
+            } catch (err) {
+              globalThis.qtbluetooth.connectChanged(this.qtObject, 0, 5);
+              console.error("onBLEConnectionStateChange: err =", err);
+            }
+          } else if (state === bluetoothManager.ProfileConnectionState.STATE_DISCONNECTED) {
+            this.resetData();
+             if (this.state === ConnectionState.STATE_CONNECTED || this.state === ConnectionState.STATE_DISCONNECTING) {
+              console.log("onBLEConnectionStateChange: Disconnected from GATT server.");
+              globalThis.qtbluetooth.connectChanged(this.qtObject, 0, 0);
+              this.close();
+            }
+          }
+        }
+      })
+    } catch (err) {
+      globalThis.qtbluetooth.connectChanged(this.qtObject, 0, 1);
+    }
+  }
+
+  connect() : boolean {
+    try {
+      this.gattClient = bluetoothManager.BLE.createGattClientDevice(this.address);
+      this.state = ConnectionState.STATE_CONNECTING;
+      this.onBLEConnectionStateChange();
+      this.onBLECharacteristicChange();
+      this.gattClient.connect();
+      return true;
+    } catch (error) {
+      console.error("connect errCode:" + error.code + ",errMessage:" + error.message);
+      return false;
+    }
+  }
+
+  private offBLEConnectionStateChange() {
+    if (!this.gattClient) {
+      return;
+    }
+    try {
+      this.gattClient.off('BLEConnectionStateChange');
+    } catch (err) {
+      console.error("offBLEConnectionStateChange: err =", err);
+    }
+  }
+
+  private onBLECharacteristicChange() {
+    if (!this.gattClient) {
+      return;
+    }
+    try {
+      this.gattClient.on('BLECharacteristicChange', async (data: bluetoothManager.BLECharacteristic) => {
+        let handle = -1;
+        for (let i = 0; i < this.entries.length; ++i) {
+          let e = this.entries[i];
+          if (e.type != GattEntryType.Characteristic)
+            continue;
+          if (e.characteristic.characteristicUuid == data.characteristicUuid) {
+            handle = i;
+            break;
+          }
+        }
+        if (handle == -1) {
+          console.warn("onCharacteristicChanged: cannot find handle");
+          return;
+        }
+        globalThis.qtbluetooth.characteristicChanged(this.qtObject, handle+1, data.characteristicValue);
+      })
+    } catch (err) {
+      console.error("error in BLECharacteristicChange");
+    }
+  }
+
+  private offBLECharacteristicChange() {
+    if (!this.gattClient) {
+      return;
+    }
+
+    this.gattClient.off('BLECharacteristicChange');
+  }
+
+  disconnectToServer() {
+    if (this.gattClient == null)
+      return;
+    try {
+        this.offBLEConnectionStateChange();
+        this.offBLECharacteristicChange();
+        if (this.state === ConnectionState.STATE_CONNECTING) {
+          this.close();
+        } else if (this.state === ConnectionState.STATE_CONNECTED) {
+          this.disconnect();
+          this.state = ConnectionState.STATE_DISCONNECTING;
+          this.close();
+        }
+    } catch  (err) {
+      console.error("disconnectToServer errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+
+  private close() {
+    try {
+      if (!this.gattClient) {
+        return;
+      }
+
+      this.gattClient.close();
+      this.state = ConnectionState.STATE_DISCONNECTED;
+    } catch (err) {
+      console.error("close: err =", err);
+    }
+  }
+
+  disconnect() {
+    this.disconnectToServer();
+  }
+
+  discoverServices() : boolean {
+    if (this.gattClient == null)
+      return false;
+    try {
+      this.gattClient.getServices().then(services => {
+        let uuids = [];
+        for (var i = 0; i < services.length; ++i) {
+          let service: bluetoothManager.GattService = services[i];
+          uuids.push(service.serviceUuid);
+        }
+        globalThis.qtbluetooth.servicesDiscovered(this.qtObject, uuids.join(" "), 0);
+      });
+      return true;
+    }
+   catch (err) {
+     console.error("errCode:" + err.code + ", errMessage:" + err.message);
+     return false;
+    }
+  }
+
+  private handleForCharacteristic(characteristic: bluetoothManager.BLECharacteristic) : number
+  {
+    if (characteristic == null)
+      return -1;
+
+    let handles : Array<number> = this.uuidToEntry.get(characteristic.serviceUuid);
+    if (handles == null || handles.length == 0)
+      return -1;
+
+    //TODO for now we assume we always want the first service in case of uuid collision
+    let serviceHandle = handles[0];
+
+    try {
+      let entry : GattEntry = null;
+      for (let i = serviceHandle+1; i < this.entries.length; i++) {
+        entry = this.entries[i];
+        if (entry == null)
+          continue;
+
+        switch (entry.type) {
+        case GattEntryType.Descriptor:
+        case GattEntryType.CharacteristicValue:
+          continue;
+        case GattEntryType.Service:
+          break;
+        case GattEntryType.Characteristic:
+        if (entry.characteristic == characteristic)
+          return i;
+        break;
+        }
+        }
+      } catch (error) { /*nothing*/ }
+      return -1;
+  }
+
+  private handleForDescriptor(descriptor : bluetoothManager.BLEDescriptor) : number {
+    if (descriptor == null)
+      return -1;
+
+    let handles : Array<number> = this.uuidToEntry[descriptor.serviceUuid];
+    if (handles == null || handles.length == 0)
+      return -1;
+
+    //TODO for now we assume we always want the first service in case of uuid collision
+    let serviceHandle = handles[0];
+
+    try {
+      let entry : GattEntry;
+      for (let i = serviceHandle+1; i < this.entries.length; i++) {
+        entry = this.entries[i];
+        if (entry == null)
+            continue;
+
+        switch (entry.type) {
+          case GattEntryType.Characteristic:
+          case GattEntryType.CharacteristicValue:
+          continue;
+          case GattEntryType.Service:
+          break;
+          case GattEntryType.Descriptor:
+          if (entry.descriptor == descriptor)
+            return i;
+          break;
+          }
+      }
+    } catch (error) { }
+    return -1;
+  }
+
+  private async populateHandles() {
+    let uuids = [];
+    let services : Array<bluetoothManager.GattService> = await this.gattClient.getServices();
+    for (var i = 0; i < services.length; ++i) {
+      let service: bluetoothManager.GattService = services[i];
+
+      let serviceEntry : GattEntry = new GattEntry;
+      serviceEntry.type = GattEntryType.Service;
+      serviceEntry.service = service;
+      this.entries.push(serviceEntry);
+      let serviceHandle : number = this.entries.length - 1;
+
+      let old : Array<number>  = this.uuidToEntry.get(service.serviceUuid);
+      if (old == null)
+        old = new Array<number>();
+      old.push(this.entries.length - 1);
+      this.uuidToEntry.set(service.serviceUuid, old);
+
+      let characteristics: Array<bluetoothManager.BLECharacteristic> = service.characteristics;
+      for (var j = 0; j < characteristics.length; ++j) {
+        let characteristic: bluetoothManager.BLECharacteristic = characteristics[j];
+        let entry: GattEntry = new GattEntry;
+        entry.type = GattEntryType.Characteristic;
+        entry.characteristic = characteristic;
+        entry.associatedServiceHandle = serviceHandle;
+        //entry.endHandle = .. undefined
+        this.entries.push(entry);
+
+        // this emulates GATT value attributes
+        entry = new GattEntry();
+        entry.type = GattEntryType.CharacteristicValue;
+        entry.associatedServiceHandle = serviceHandle;
+        entry.endHandle = this.entries.length; // special case -> current index in entries list
+        this.entries.push(entry);
+        // add all descriptors
+        let descList : Array<bluetoothManager.BLEDescriptor> = characteristic.descriptors;
+        for (var k =0; k < descList.length; ++k) {
+          entry = new GattEntry();
+          entry.type = GattEntryType.Descriptor;
+          entry.descriptor = descList[k];
+          entry.associatedServiceHandle = serviceHandle;
+          //entry.endHandle = .. undefined
+          this.entries.push(entry);
+        }
+        this.gattClient.setNotifyCharacteristicChanged(characteristic, true);
+      }
+      serviceEntry.endHandle = this.entries.length - 1;
+      uuids.push(service.serviceUuid);
+    }
+    globalThis.qtbluetooth.servicesDiscovered(this.qtObject, uuids.join(" "), 0);
+  }
+
+  async discoverServiceDetails(serviceUuid: string) {
+    if (this.gattClient == null)
+      return false;
+
+    if (this.entries.length == 0)
+      await this.populateHandles();
+
+    let entry : GattEntry;
+    let serviceHandle = 0;
+    try {
+      let handles : Array<number> = this.uuidToEntry.get(serviceUuid);
+      if (handles == null || handles.length == 0) {
+          console.warn("Unknown service uuid for current device: " + serviceUuid);
+          return false;
+      }
+
+      serviceHandle = handles[0];
+      entry = this.entries[serviceHandle];
+      if (entry == null) {
+          console.warn("Service with UUID " + serviceUuid + " not found");
+          return false;
+      }
+      } catch (error) {
+          //invalid UUID string passed
+          console.warn("Cannot parse given UUID");
+          return false;
+      }
+
+     if (entry.type != GattEntryType.Service) {
+         console.warn("Given UUID is not a service UUID: " + serviceUuid);
+         return false;
+     }
+
+     // current service already discovered or under investigation
+     if (entry.valueKnown || this.servicesToBeDiscovered.has(serviceHandle)) {
+         console.warn("Service already known or to be discovered");
+         return true;
+     }
+
+     this.servicesToBeDiscovered.add(serviceHandle);
+     this.scheduleServiceDetailDiscovery(serviceHandle);
+
+    return true;
+  }
+
+  propertyToInt(property : bluetoothManager.GattProperties) : number {
+    // Qt Property Type
+    // Unknown = 0x00,
+    // Broadcasting = 0x01,
+    // Read = 0x02,
+    // WriteNoResponse = 0x04,
+    // Write = 0x08,
+    // Notify = 0x10,
+    // Indicate = 0x20,
+    // WriteSigned = 0x40,
+    // ExtendedProperty = 0x80
+    let result : number = 0x00;
+    if (property.write) {
+      result = 0x08;
+    }
+    if (property.writeNoResponse) {
+      result = result | 0x04;
+    }
+    if (property.read) {
+      result = result | 0x02;
+    }
+    if (property.notify) {
+      result = result | 0x10;
+    }
+    if (property.indicate) {
+      result = result | 0x20;
+    }
+    return result;
+  }
+
+  async scheduleServiceDetailDiscovery(handler : number) {
+    let serviceEntry : GattEntry = this.entries[handler];
+    let endHandle : number = serviceEntry.endHandle;
+
+    if (handler == endHandle) {
+        console.warn("scheduleServiceDetailDiscovery: service is empty; nothing to discover");
+        this.finishCurrentServiceDiscovery(handler);
+        return;
+    }
+
+    // serviceHandle + 1 -> ignore service handle itself
+    for (let i = handler + 1; i <= endHandle; i++) {
+      let entry: GattEntry = this.entries[i];
+
+      switch (entry.type) {
+        case GattEntryType.Characteristic:
+        case GattEntryType.Descriptor:
+      // we schedule CharacteristicValue for initial discovery to simplify
+      // detection of the end of service discovery process
+      // performNextIO() ignores CharacteristicValue GATT entries
+        case GattEntryType.CharacteristicValue:
+          break;
+        case GattEntryType.Service:
+        // should not really happen unless endHandle is wrong
+          console.warn("scheduleServiceDetailDiscovery: wrong endHandle");
+          return;
+      }
+       let handle : number = -1;
+
+      switch (entry.type) {
+        case GattEntryType.Characteristic:
+          handle = this.handleForCharacteristic(entry.characteristic);
+          break;
+        case GattEntryType.Descriptor:
+          handle = this.handleForDescriptor(entry.descriptor);
+          break;
+        case GattEntryType.CharacteristicValue:
+          handle = entry.endHandle;
+        default:
+          break;
+      }
+      let skip = await this.readGattEntry(entry);
+      if (skip) {
+        if (handle > -1) {
+          let isServiceDiscovery : boolean = !entry.valueKnown;
+
+          if (isServiceDiscovery) {
+              entry.valueKnown = true;
+              switch (entry.type) {
+                  case GattEntryType.Characteristic:
+                      console.debug("Non-readable characteristic " + entry.characteristic.characteristicUuid +
+                              " for service " + entry.characteristic.serviceUuid);
+                      globalThis.qtbluetooth.characteristicRead(this.qtObject, entry.characteristic.serviceUuid,
+                              handle + 1, entry.characteristic.characteristicUuid,
+                              this.propertyToInt(entry.characteristic.properties), entry.characteristic.characteristicValue);
+                      break;
+                  case GattEntryType.Descriptor:
+                      // atm all descriptor types are readable
+                      console.debug("Non-readable descriptor " + entry.descriptor.descriptorUuid +
+                              " for service/char" + entry.descriptor.serviceUuid +
+                              "/" + entry.descriptor.characteristicUuid);
+                      globalThis.qtbluetooth.descriptorRead(this.qtObject,
+                              entry.descriptor.serviceUuid,
+                              entry.descriptor.characteristicUuid,
+                              handle + 1, entry.descriptor.descriptorUuid,
+                              entry.descriptor.descriptorValue);
+                      break;
+                  case GattEntryType.CharacteristicValue:
+                      // for more details see scheduleServiceDetailDiscovery(int)
+                      break;
+                  default :
+                      console.log("Scheduling of Service Gatt entry for service discovery should never happen.");
+                      break;
+              }
+
+              let serviceEntry: GattEntry = this.entries[entry.associatedServiceHandle];
+              if (serviceEntry.endHandle == handle)
+                  this.finishCurrentServiceDiscovery(entry.associatedServiceHandle);
+          } else {
+              let errorCode = 0;
+              errorCode = (entry.type == GattEntryType.Characteristic) ? 5 : 6;
+              globalThis.qtbluetooth.serviceError(this.qtObject, handle + 1, errorCode);
+          }
+          }
+      }
+    }
+  }
+
+  private async readGattEntry(entry: GattEntry) : Promise<boolean>
+  {
+   let result: boolean;
+    switch (entry.type) {
+      case GattEntryType.Characteristic:
+      try {
+        await this.gattClient.readCharacteristicValue(entry.characteristic);
+        result = true;
+      } catch (error) {
+        result = false;
+      }
+      if (!result)
+        return true; // skip
+      break;
+    case GattEntryType.Descriptor:
+      try {
+        await this.gattClient.readDescriptorValue(entry.descriptor);
+        result = true;
+      } catch (error) {
+        result = false;
+      }
+      if (!result)
+        return true; // skip
+      break;
+      case GattEntryType.Service:
+      return true;
+      case GattEntryType.CharacteristicValue:
+      return true; //skip
+      }
+      return false;
+  }
+
+  finishCurrentServiceDiscovery(handler : number) {
+    console.warn("Finished current discovery for service handle " + handler);
+    let discoveredService : GattEntry = this.entries[handler];
+    discoveredService.valueKnown = true;
+    this.servicesToBeDiscovered.removeFirst();
+    globalThis.qtbluetooth.serviceDetailDiscoveryFinished(this.qtObject, discoveredService.service.serviceUuid, handler + 1, discoveredService.endHandle + 1);
+  }
+
+
+  writeCharacteristic(charHandle, value, mode) : boolean {
+    if (this.gattClient == null)
+      return false;
+    let entry : GattEntry = null;
+    try {
+      entry = this.entries[charHandle-1]; //Qt always uses handles + 1
+    } catch (err) {
+      console.error("writeCharacteristic error", err);
+      return false;
+    }
+    if (entry == null)
+      return false;
+    entry.characteristic.characteristicValue = value;
+    try {
+      this.gattClient.writeCharacteristicValue(entry.characteristic);
+      return true;
+    } catch (err) {
+      console.error("writeCharacteristic error", err);
+      globalThis.qtbluetooth.serviceError(this.qtObject, charHandle, 2);
+      return false;
+    }
+  }
+
+  writeDescriptor(charHandle, value) : boolean {
+    if (this.gattClient == null)
+      return false;
+    let entry : GattEntry = null;
+    try {
+      entry = this.entries[charHandle-1]; //Qt always uses handles + 1
+    } catch (err) {
+      console.error("writeCharacteristic error", err);
+      return false;
+    }
+    if (entry == null)
+      return false;
+    entry.descriptor.descriptorValue = value;
+    try {
+      this.gattClient.writeDescriptorValue(entry.descriptor);
+      return true;
+    } catch (err) {
+      console.error("writeCharacteristic error", err);
+      globalThis.qtbluetooth.serviceError(this.qtObject, charHandle, 3);
+      return false;
+    }
+  }
+
+  readCharacteristic(charHandle) {
+    if (this.gattClient == null)
+      return false;
+    let entry : GattEntry = null;
+    try {
+      entry = this.entries[charHandle-1]; //Qt always uses handles + 1
+    } catch (err) {
+      console.error("readDescriptor error", err);
+      return false;
+    }
+    if (entry == null)
+      return false;
+    try {
+      this.gattClient.readCharacteristicValue(entry.characteristic, (code, BLECharacteristic) => {
+        if (code.code != 0) {
+          return;
+        }
+        console.log('bluetooth descriptor uuid: ' + BLECharacteristic.characteristicUuid);
+        let value = BLECharacteristic.characteristicValue;
+        globalThis.qtbluetooth.characteristicRead(this.qtObject, entry.characteristic.serviceUuid, charHandle + 1,
+          entry.characteristic.characteristicUuid, this.propertyToInt(entry.characteristic.properties), value);
+      });
+      return true;
+    } catch (err) {
+      console.error("readDescriptor error", err);
+      return false;
+    }
+  }
+
+  readDescriptor(descriptorHandle) {
+    if (this.gattClient == null)
+      return false;
+    let entry : GattEntry = null;
+    try {
+      entry = this.entries[descriptorHandle-1]; //Qt always uses handles + 1
+    } catch (err) {
+      console.error("readDescriptor error", err);
+      return false;
+    }
+    if (entry == null)
+      return false;
+    try {
+      this.gattClient.readDescriptorValue(entry.descriptor, (code, BLEDescriptor) => {
+        if (code.code != 0) {
+          return;
+        }
+        console.log('bluetooth descriptor uuid: ' + BLEDescriptor.descriptorUuid);
+        let value = BLEDescriptor.descriptorValue;
+        globalThis.qtbluetooth.descriptorRead(this.qtObject, entry.characteristic.serviceUuid, entry.characteristic.characteristicUuid, descriptorHandle + 1, BLEDescriptor.descriptorUuid, value);
+      });
+      return true;
+    } catch (err) {
+      console.error("readDescriptor error", err);
+      return false;
+    }
+  }
+
+  async  includedServices(serviceUuid : string) : Promise<string>
+  {
+    if (this.gattClient == null)
+      return "";
+    let services = await this.gattClient.getServices();
+    let target : bluetoothManager.GattService = null;
+    for (let i = 0; i < services.length; ++i) {
+      let service: bluetoothManager.GattService = services[i];
+      if (service == null)
+        continue;
+      if (service.serviceUuid == serviceUuid) {
+        target = service
+        break;
+      }
+    }
+    if (target == null)
+      return ""
+
+    let includes : Array<bluetoothManager.GattService> = target.includeServices;
+    if (includes.length == 0)
+      return "";
+
+    let uuids: Array<string> = [];
+    for (let i = 0; i < includes.length; ++i) {
+      uuids.push(includes[i].serviceUuid)
+    }
+    return uuids.join(" "); //space is separator
+  }
+
+  resetData() {
+    this.uuidToEntry.clear();
+    this.entries = [];
+    this.servicesToBeDiscovered.clear();
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothManager.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothManager.ts
new file mode 100644
index 00000000..66006f68
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothManager.ts
@@ -0,0 +1,236 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+import List from '@ohos.util.List';
+import { QtBluetooth } from './QtBluetooth';
+import { QtBluetoothDevice } from './QtBluetoothDevice'
+import { QtBluetoothServer } from './QtBluetoothServer'
+import { QtBluetoothLE } from './QtBluetoothLE'
+import { QtBluetoothGattServer } from './QtBluetoothGattServer'
+import { QtBluetoothServiceAdapter } from './QtBluetoothServiceAdapter'
+import qtbluetooth from 'libQt5Bluetooth.so';
+
+function onReceiveEvent(data) {
+  for (var i = 0; i < data.length; ++i) {
+    let target = new QtBluetooth(data[i], false);
+    let address = data[i];
+    globalThis.qtBluetoothManager.add(address);
+    Reflect.defineProperty(globalThis, address, { value: target });
+    qtbluetooth.discoveryResult(address);
+  }
+}
+
+function onBLEReceiveEvent(data) {
+  for (var i = 0; i < data.length; ++i) {
+    let target = new QtBluetooth(data[i], true);
+    let address = data[i];
+    globalThis.qtBluetoothManager.add(address);
+    Reflect.defineProperty(globalThis, address, { value: target });
+    qtbluetooth.discoveryResult(address);
+  }
+}
+
+export class QtBluetoothManager {
+  private targets = null;
+
+  constructor() {
+    this.targets = new List();
+    globalThis.qtBluetoothManager = this;
+    globalThis.qtbluetooth = qtbluetooth;
+  }
+
+  isSupport() {
+    return canIUse("SystemCapability.Communication.Bluetooth.Core");
+  }
+
+  enable() {
+    try {
+      if (bluetoothManager.getState() === bluetoothManager.BluetoothState.STATE_ON
+        || bluetoothManager.getState() === bluetoothManager.BluetoothState.STATE_TURNING_ON)
+        return true;
+      bluetoothManager.enableBluetooth();
+      return true;
+    } catch (err) {
+      console.error("enableBluetooth errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  disable() {
+    try {
+      bluetoothManager.disableBluetooth();
+      return true;
+    } catch (err) {
+      console.error("disableBluetooth errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  scanMode() {
+    try {
+      let mode = bluetoothManager.getBluetoothScanMode();
+      return mode;
+    } catch (err) {
+      console.error("getBluetoothScanMode errCode:" + err.code + ",errMessage:" + err.message);
+      return -1;
+    }
+  }
+
+  setScanMode(mode) {
+    try {
+      bluetoothManager.setBluetoothScanMode(mode, 0);
+    } catch (err) {
+      console.error("setBluetoothScanMode errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+
+  getLocalName() {
+    return bluetoothManager.getLocalName();
+  }
+
+  getAddress() {
+    return bluetoothManager.getLocalName();
+  }
+
+  pair(address, isPairing) {
+    try {
+      if (isPairing)
+        bluetoothManager.pairDevice(address);
+      // else
+      //     bluetoothManager.cancelPairedDevice(address);    //没有这个接口
+    } catch (err) {
+      console.error("pair errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+
+  pairedDevices() {
+    try {
+      let devices = bluetoothManager.getPairedDevices();
+      return devices;
+    } catch (err) {
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+      return [];
+    }
+  }
+
+  getBondState(address) {
+    if (this.pairedDevices().indexOf(address) == -1)
+      return bluetoothManager.BondState.BOND_STATE_INVALID;
+    return bluetoothManager.BondState.BOND_STATE_BONDED;
+  }
+
+  getState() {
+    return bluetoothManager.getState();
+  }
+
+  add(deviceId) {
+    if (this.targets.has(deviceId))
+      return;
+    this.targets.add(deviceId);
+  }
+
+  startBluetoothDiscovery() {
+    try {
+      bluetoothManager.on('bluetoothDeviceFind', onReceiveEvent);
+      bluetoothManager.startBluetoothDiscovery();
+      return true;
+    } catch (err) {
+      console.error("startBluetoothDiscovery errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  stopBluetoothDiscovery() {
+    try {
+      bluetoothManager.off('bluetoothDeviceFind');
+      bluetoothManager.stopBluetoothDiscovery();
+      return true;
+    } catch (err) {
+      console.error("stopBluetoothDiscovery errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  startBLEScan() {
+    try {
+      bluetoothManager.BLE.on("BLEDeviceFind", onBLEReceiveEvent);
+      bluetoothManager.BLE.startBLEScan(
+        null,
+        {
+          interval: 500,
+          dutyMode: bluetoothManager.ScanDuty.SCAN_MODE_LOW_POWER,
+          matchMode: bluetoothManager.MatchMode.MATCH_MODE_AGGRESSIVE,
+        }
+      );
+      return true;
+    } catch (err) {
+      console.error(" startBLEScan errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  stopBLEScan() {
+    try {
+      bluetoothManager.BLE.off("BLEDeviceFind");
+      bluetoothManager.BLE.stopBLEScan();
+      return true;
+    } catch (err) {
+      console.error("stopBLEScan errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  createBluetoothDevice(name, address) {
+    if (!this.targets.has(address))
+      return false;
+    let device = new QtBluetoothDevice(address);
+    Reflect.defineProperty(globalThis, name, { value: device });
+    return true;
+  }
+
+  destroyBluetoothDevice(name) {
+    console.log("delete js bluetooth device object for: ", name)
+    Reflect.deleteProperty(globalThis, name);
+    return true;
+  }
+
+  createServer(name, p) {
+    let server = new QtBluetoothServer(name, p);
+    Reflect.defineProperty(globalThis, name, { value: server });
+    return true;
+  }
+
+  createBluetoothLE(name, address) {
+    let target = new QtBluetoothLE(address);
+    Reflect.defineProperty(globalThis, name, { value: target });
+    return true;
+  }
+
+  destroyBluetoothLE(name) {
+    console.log("delete js bluetooth le object for: ", name)
+    Reflect.deleteProperty(globalThis, name);
+    return true;
+  }
+
+  createBluetoothGattServer(name) {
+    let target = new QtBluetoothGattServer;
+    Reflect.defineProperty(globalThis, name, { value: target });
+    return true;
+  }
+
+  destroyBluetoothGattServer(name) {
+    console.log("delete js bluetooth le object for: ", name)
+    Reflect.deleteProperty(globalThis, name);
+    return true;
+  }
+
+  createServiceAdapter(name, pointer) {
+    let adapter = new QtBluetoothServiceAdapter(pointer);
+    Reflect.defineProperty(globalThis, name, { value: adapter });
+    return true;
+  }
+
+  destroyServiceAdapter(name) {
+    console.log("delete js blue device object for: ", name)
+    Reflect.deleteProperty(globalThis, name);
+    return true;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothServer.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothServer.ts
new file mode 100644
index 00000000..ca70df73
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothServer.ts
@@ -0,0 +1,84 @@
+import qtbluetooth from 'libQt5Bluetooth.so';
+import bluetoothManager from '@ohos.bluetoothManager';
+import { QtBluetoothSocket } from '../native/QtBluetoothSocket'
+
+export class QtBluetoothServer {
+  private alive = false;
+  private pointerId = 0;
+  private serverNumber = -1;
+  private clientNumber = -1;
+  private name: string = '';
+
+  public constructor(name: string, p) {
+    this.name = name;
+    this.pointerId = p;
+  }
+
+  isAlive() {
+    return this.alive;
+  }
+
+  createServer(name: string, p) {
+    let server = new QtBluetoothServer(name, p);
+    Reflect.defineProperty(globalThis, name, { value: server });
+    return true;
+  }
+
+  destroyServer(name: string) {
+    Reflect.deleteProperty(globalThis, name);
+    this.name = '';
+    this.pointerId = 0;
+    this.alive = false;
+    return true;
+  }
+
+  closeClient(socket: number) {
+    try {
+      bluetoothManager.sppCloseClientSocket(socket);
+    } catch (err) {
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+
+  close() {
+    try {
+      bluetoothManager.sppCloseServerSocket(this.serverNumber);
+      this.alive = false;
+    } catch (err) {
+      qtbluetooth.occurError(this.pointerId, err);
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+
+  listen(srvName, uid, isSecure) {
+    try {
+      let sppOption = { uuid: uid, secure: isSecure, type: bluetoothManager.SppType.SPP_RFCOMM };
+
+      bluetoothManager.sppListen(srvName, sppOption, (code, number) => {
+        console.log('bluetooth error code: ' + code.code);
+        if (code.code == 0) {
+          this.serverNumber = number;
+          this.alive = true;
+          console.log('bluetooth serverSocket Number: ' + number);
+          try {
+            bluetoothManager.sppAccept(this.serverNumber, (code, number) => {
+              console.log('bluetooth clientSocket Number: ' + number);
+              // 获取的clientNumber用作服务端后续读/写操作socket的id。
+              this.clientNumber = number;
+              let server = new QtBluetoothSocket(this.clientNumber);
+              Reflect.defineProperty(globalThis, this.clientNumber, { value: server });
+              qtbluetooth.acceptClientSocket(this.pointerId, this.clientNumber);
+            });
+          } catch (err) {
+            qtbluetooth.occurError(this.pointerId, err);
+            console.error("errCode:" + err.code + ",errMessage:" + err.message);
+          }
+        }
+      });
+    } catch (err) {
+      this.alive = false;
+      qtbluetooth.occurError(this.pointerId, err);
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothServiceAdapter.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothServiceAdapter.ts
new file mode 100644
index 00000000..e4667274
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothServiceAdapter.ts
@@ -0,0 +1,39 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+import qtbluetooth from 'libQt5Bluetooth.so';
+
+export class QtBluetoothServiceAdapter {
+  private pointerId = 0;
+  private device = null;
+
+  constructor(p) {
+    this.pointerId = p;
+  }
+
+  createAdapter(adapter) {
+    try {
+      this.device = bluetoothManager.BLE.createGattClientDevice(adapter);
+    } catch (err) {
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+    return true;
+  }
+
+  fetchService() {
+    console.warn("<----------------fetchService---1");
+    this.device.connect();
+    console.warn("<----------------fetchService---3");
+    this.device.getServices((code, gattServices) => {
+      if (code.code == 0) {
+        let services = gattServices;
+        console.log('bluetooth code is ' + code.code);
+        console.log("bluetooth services size is ", services.length);
+
+        for (let i = 0; i < services.length; i++) {
+          console.log('bluetooth services is ' + JSON.stringify(services[i]));
+          qtbluetooth.servicesReceiver(this.pointerId, JSON.stringify(services[i]));
+        }
+      }
+    });
+  }
+}
diff --git a/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothSocket.ts b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothSocket.ts
new file mode 100644
index 00000000..be9b65ab
--- /dev/null
+++ b/src/openharmony/bluetooth/native/QtBluetooth/QtBluetoothSocket.ts
@@ -0,0 +1,65 @@
+import bluetoothManager from '@ohos.bluetoothManager';
+
+export class QtBluetoothSocket {
+  private clientSocket = null
+
+  private id = 0;
+
+  constructor(id) {
+    this.id = id;
+  }
+
+  setId(id) {
+    this.id = id;
+    return true;
+  }
+
+  setSocketNumber(number) {
+    this.clientSocket = number;
+    return true;
+  }
+
+  connect(address, uuid, sec) {
+    try {
+      let sppOption = { uuid: uuid, secure: sec, type: 0 };
+      bluetoothManager.sppConnect(address, sppOption, (code, client) => {
+        if (code.code != 0) {
+          return;
+        }
+        console.log('bluetooth serverSocket Number: ' + client);
+        // 获取的clientNumber用作客户端后续读/写操作socket的id。
+        this.clientSocket = client;
+      });
+      return true;
+    } catch (err) {
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  start() {
+    try {
+      bluetoothManager.on('sppRead', this.clientSocket, (dataBuffer) => {
+        globalThis.qtbluetooth.socketDataAvailable(this.id, dataBuffer);
+      });
+    } catch (err) {
+      console.error("sppRead errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  write(buffer) {
+    try {
+      bluetoothManager.sppWrite(this.clientSocket, buffer);
+      return true;
+    } catch (err) {
+      console.error("errCode:" + err.code + ",errMessage:" + err.message);
+      return false;
+    }
+  }
+
+  close() {
+    bluetoothManager.off('sppRead', this.clientSocket);
+    bluetoothManager.sppCloseClientSocket(this.clientSocket);
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/nfc/native/QtNfc/JsNfc.ts b/src/openharmony/nfc/native/QtNfc/JsNfc.ts
new file mode 100644
index 00000000..cf7558d8
--- /dev/null
+++ b/src/openharmony/nfc/native/QtNfc/JsNfc.ts
@@ -0,0 +1,63 @@
+import controller from '@ohos.nfc.controller';
+import tag from '@ohos.nfc.tag';
+import HashMap from '@ohos.util.HashMap';
+import { JsNfcTag }  from './JsNfcTag';
+import { BusinessError } from '@ohos.base';
+import JsDataStore from '../QtCore/JsDataStore'
+import JsLogger from '../QtCore/JsLogger'
+
+export class JsNfc {
+    private tagsIndex: number = 0;
+    private tags: HashMap<number, JsNfcTag> = null;
+
+    constructor() {
+        this.tags = new HashMap;
+    }
+
+    createTag(tagInfo: tag.TagInfo) {
+        if (tagInfo == null || tagInfo == undefined) {
+            JsLogger.info("no TagInfo to be created, ignore it.");
+            return;
+        }
+        let nfcTag = new JsNfcTag(tagInfo);
+        this.tagsIndex++;
+        this.tags.set(this.tagsIndex, nfcTag);
+        let name = "tagInfo" + this.tagsIndex;
+        JsDataStore.initObject(name, nfcTag);
+        JsDataStore.getQtNativeModule("QtNfc").nfcTargetDetected(name)
+    }
+
+    start() {
+        controller.on("nfcStateChange", (data) => {
+            JsLogger.info("controller on callback nfcState: %{public}s" + JSON.stringify(data));
+            JsDataStore.getQtNativeModule("QtNfc").nfcStateChanged(data);
+        });
+
+        try {
+            let discTech = [tag.NFC_A, tag.NFC_B];
+            tag.registerForegroundDispatch(JsDataStore.getElementName(), discTech, (err : BusinessError, tagInfo : tag.TagInfo) =>{
+                JsLogger.info("foreground callback: tag found tagInfo = %{public}s", JSON.stringify(tagInfo));
+                JsDataStore.getQtNativeModule("QtNfc").createTag(tagInfo);
+            });
+        } catch (e) {
+            JsLogger.error("registerForegroundDispatch error: " + e.message);
+        }
+    }
+
+    stop() {
+        try {
+            tag.unregisterForegroundDispatch(JsDataStore.getElementName());
+        } catch (e) {
+            JsLogger.info("registerForegroundDispatch error: " + e.message);
+        }
+        controller.off("nfcStateChange");
+    }
+
+    isAvailable() : boolean {
+        return this.isSupported() && controller.isNfcOpen();
+    }
+
+    isSupported() : boolean {
+        return canIUse("SystemCapability.Communication.NFC.Core")
+    }
+}
\ No newline at end of file
diff --git a/src/openharmony/nfc/native/QtNfc/JsNfcModule.ts b/src/openharmony/nfc/native/QtNfc/JsNfcModule.ts
new file mode 100644
index 00000000..83474c74
--- /dev/null
+++ b/src/openharmony/nfc/native/QtNfc/JsNfcModule.ts
@@ -0,0 +1,34 @@
+import { JsQtModule } from '../QtCore/JsQtModule';
+import JsDataStore from '../QtCore/JsDataStore';
+import JsLogger from '../QtCore/JsLogger';
+import { JsNfc } from './JsNfc';
+import { JsNfcTag } from './JsNfcTag';
+
+class JsNfcModule extends JsQtModule {
+
+  public constructor() {
+    super()
+    this.moduleJsObjects = {
+      JsNfc,
+      JsNfcTag
+    };
+    this.loadQtModule();
+  }
+
+  async loadQtModule(): Promise<void> {
+    let qtMajorVersion = JsDataStore.getQtMajorVersion();
+    let QtNfcModule: any = null;
+    if (qtMajorVersion == 5)
+      QtNfcModule = await import ("libQt5Nfc.so");
+    else if (qtMajorVersion == 6)
+      QtNfcModule = await import ("libQt6Nfc.so");
+    if (QtNfcModule == null) {
+      JsLogger.fatal("Cannot load QtNfc module");
+      return;
+    }
+    let QtNfc = QtNfcModule.default;
+    JsDataStore.addQtNativeModule("QtNfc", QtNfc);
+  }
+}
+
+export default new JsNfcModule;
\ No newline at end of file
diff --git a/src/openharmony/nfc/native/QtNfc/JsNfcTag.ts b/src/openharmony/nfc/native/QtNfc/JsNfcTag.ts
new file mode 100644
index 00000000..ed1834b7
--- /dev/null
+++ b/src/openharmony/nfc/native/QtNfc/JsNfcTag.ts
@@ -0,0 +1,171 @@
+import tag from '@ohos.nfc.tag';
+import JsLogger from '../QtCore/JsLogger'
+
+export class JsNfcTag {
+  private tagInfo: tag.TagInfo = null;
+  private target = null;
+
+  constructor(tagInfo: tag.TagInfo) {
+    this.tagInfo = tagInfo;
+    let target = null;
+    for (let i = 0; i < this.tagInfo.technology.length; i++) {
+      if (this.tagInfo.technology[i] == tag.NFC_A) {
+        target = tag.getNfcA(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.NFC_B) {
+        target = tag.getNfcB(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.ISO_DEP) {
+        target = tag.getIsoDep(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.NFC_F) {
+        target = tag.getNfcF(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.NFC_V) {
+        target = tag.getNfcV(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.NDEF) {
+        target = tag.getNdef(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.NDEF_FORMATABLE) {
+        target = tag.getNdefFormatable(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.MIFARE_CLASSIC) {
+        target = tag.getMifareClassic(this.tagInfo);
+        break;
+      }
+      if (this.tagInfo.technology[i] == tag.MIFARE_ULTRALIGHT) {
+        target = tag.getMifareUltralight(this.tagInfo);
+        break;
+      }
+      this.target = target;
+    }
+  }
+
+  uid(): ArrayBuffer {
+    let arrayBuffer = new Uint8Array(this.tagInfo.uid).buffer;
+    return arrayBuffer;
+  }
+
+  technologies(): string {
+    return this.tagInfo.technology.join(",");
+  }
+
+  getNdefMessage(): string {
+    let isNdef = false;
+    for (let i = 0; i < this.tagInfo.technology.length; i++) {
+      if (this.tagInfo.technology[i] == tag.NDEF) {
+        isNdef = true;
+        break;
+      }
+    }
+    if (!isNdef)
+      return null;
+    try {
+      let ndefTag = tag.getNdef(this.tagInfo);
+      let message = ndefTag.getNdefMessage();
+      return JSON.stringify(message);
+    } catch (error) {
+      JsLogger.info("tag.getNdefTag catched error: " + error);
+      return null;
+    }
+  }
+
+  isInRange(): boolean {
+    return true;
+  }
+
+  maxCommandLength(): number {
+    if (this.target != null)
+      return this.target.getMaxTransmitSize();
+    return 0;
+  }
+
+  connect(): boolean {
+    if (this.target != null) {
+      try {
+        this.target.connect();
+        return true;
+      } catch (error) {
+        JsLogger.error("tag connect busiError: " + error);
+        return false;
+      }
+    }
+    return false;
+  }
+
+  isConnected(): boolean {
+    if (this.target != null)
+      return this.target.isConnected();
+    return false;
+  }
+
+  async transceive(data): Promise<ArrayBuffer> {
+    if (this.target == null)
+      return null;
+    try {
+      let result = await this.target.sendData(data);
+      let arrayBuffer = new Uint8Array(result).buffer;
+      return arrayBuffer;
+    } catch(err) {
+      JsLogger.error("tagSession sendData Promise err: " + err);
+      return null;
+    }
+  }
+
+  format(data) {
+    let message = tag.ndef.createNdefMessage(data);
+    this.target?.format(message);
+  }
+
+  writeNdefMessage(data: number[]) {
+    let message: tag.NdefMessage = tag.ndef.createNdefMessage(data);
+    try {
+      this.target?.writeNdef(message);
+    } catch (error) {
+      JsLogger.info("ndef writeNdef Promise catch busiError Code: ${(busiError as Businsess).code}, " +
+        "message: ${(busiError as Businsess).message}");
+    }
+  }
+
+  getType(): string {
+    if (this.target == null)
+      return "";
+    let type = this.target.getNdefTagType();
+    try {
+      return this.target.getNdefTagTypeString(type);
+    } catch (err) {
+      JsLogger.error("ndef getNdefTagTypeString catch busiError Code: ${(busiError as Businsess).code}, " +
+        "message: ${(busiError as Businsess).message}");
+    }
+  }
+
+  getAtqa(): ArrayBuffer {
+    if (this.target == null)
+      return null;
+    let result = this.target.getAtqa();
+    let arrayBuffer = new Uint8Array(result).buffer;
+    return arrayBuffer;
+  }
+
+  getSak(): number {
+    if (this.target == null)
+      return 0;
+    return this.target.getSak();
+  }
+
+  close(): boolean {
+    if (this.target == null)
+      return true;
+    //Todo close
+    return true;
+  }
+
+}
\ No newline at end of file
diff --git a/src/openharmony/nfc/nfc.pro b/src/openharmony/nfc/nfc.pro
new file mode 100644
index 00000000..00614707
--- /dev/null
+++ b/src/openharmony/nfc/nfc.pro
@@ -0,0 +1,11 @@
+TEMPLATE = aux
+
+CONFIG -= qt
+
+templates.files += $$files($$PWD/native/QtNfc/*.ts, true)
+templates.path = $$[QT_INSTALL_PREFIX]/openharmony/qtconnectivity
+templates.base = $$PWD
+
+INSTALLS += templates
+
+OTHER_FILES += $$templates.files
diff --git a/src/openharmony/openharmony.pro b/src/openharmony/openharmony.pro
new file mode 100644
index 00000000..f8f5c05e
--- /dev/null
+++ b/src/openharmony/openharmony.pro
@@ -0,0 +1,3 @@
+TEMPLATE = subdirs
+qtHaveModule(bluetooth): SUBDIRS += bluetooth
+qtHaveModule(nfc): SUBDIRS += nfc
diff --git a/src/src.pro b/src/src.pro
index dba9de4b..53b11bb7 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -6,6 +6,11 @@ android {
     android.depends += bluetooth nfc
 }
 
+openharmony {
+    SUBDIRS += openharmony
+    openharmony.depends += bluetooth nfc
+}
+
 contains(QT_CONFIG, private_tests) {
     bluetooth_doc_snippets.subdir = bluetooth/doc/snippets
     bluetooth_doc_snippets.depends = bluetooth
