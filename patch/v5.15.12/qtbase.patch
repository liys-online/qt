diff --git a/config.tests/arch/write_info.pri b/config.tests/arch/write_info.pri
index 5b43ce1cd5..e0518dd242 100644
--- a/config.tests/arch/write_info.pri
+++ b/config.tests/arch/write_info.pri
@@ -3,6 +3,9 @@ targetinfofile ~= s/pro$/target.txt/
 
 win32 {
     ext = .exe
+} else:android|openharmony {
+    file_prefix = lib
+    ext = .so
 } else:wasm {
     ext = .wasm
 }
diff --git a/mkspecs/common/oh-base-head.conf b/mkspecs/common/oh-base-head.conf
new file mode 100644
index 0000000000..d7be212137
--- /dev/null
+++ b/mkspecs/common/oh-base-head.conf
@@ -0,0 +1,24 @@
+load(device_config)
+
+SDK_ROOT = $$(OHOS_SDK_PATH)
+
+isEmpty(NDK_TOOLCHAIN_PREFIX) {    
+    equals(OHOS_ARCH, arm64-v8a): NDK_TOOLCHAIN_PREFIX = aarch64-linux-ohos
+    else: equals(OHOS_ARCH, armeabi-v7a): NDK_TOOLCHAIN_PREFIX = arm-linux-ohos
+    else: equals(OHOS_ARCH, x86_64): NDK_TOOLCHAIN_PREFIX = x86_64-linux-ohos
+    else: NDK_TOOLCHAIN_PREFIX = arm-linux-ohos
+}
+
+QMAKE_CFLAGS = -D__MUSL__
+QMAKE_CXXFLAGS = -D__MUSL__
+QMAKE_CFLAGS += -DOPENHARMONY
+QMAKE_CXXFLAGS += -DOPENHARMONY
+
+CROSS_COMPILE = $$shell_path($$SDK_ROOT/native/llvm/bin/)
+
+QMAKE_PCH_OUTPUT_EXT    = .gch
+
+QMAKE_CFLAGS_PRECOMPILE       = -x c-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}
+QMAKE_CFLAGS_USE_PRECOMPILE   = -include ${QMAKE_PCH_OUTPUT_BASE}
+QMAKE_CXXFLAGS_PRECOMPILE     = -x c++-header -c ${QMAKE_PCH_INPUT} -o ${QMAKE_PCH_OUTPUT}
+QMAKE_CXXFLAGS_USE_PRECOMPILE = $$QMAKE_CFLAGS_USE_PRECOMPILE
diff --git a/mkspecs/common/oh-base-tail.conf b/mkspecs/common/oh-base-tail.conf
new file mode 100644
index 0000000000..4039af1e79
--- /dev/null
+++ b/mkspecs/common/oh-base-tail.conf
@@ -0,0 +1,78 @@
+equals(OHOS_ARCH, armeabi-v7a): \
+    QMAKE_CFLAGS += -march=armv7a -msoft-float -mfpu=vfp -fno-builtin-memmove
+else: equals(OHOS_ARCH, arm64-v8a): \
+    QMAKE_CFLAGS += -march=armv8a -msoft-float -mfpu=vfp -fno-builtin-memmove
+else: equals(OHOS_ARCH, x86_64): \
+    QMAKE_CFLAGS += -march=x86_64
+else: \
+    QMAKE_CFLAGS += -march=armv7a -msoft-float -mfpu=vfp -fno-builtin-memmove
+
+
+equals(OHOS_ARCH, armeabi-v7a) | equals(OHOS_ARCH, armeabi) {
+    CONFIG += optimize_size
+    QMAKE_CFLAGS_DEBUG = -g -marm -O0
+}
+
+QMAKE_CFLAGS_SHLIB      = -fPIC
+QMAKE_CFLAGS_YACC       = -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD     = -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+QMAKE_CFLAGS_NEON       = -mfpu=neon
+
+QMAKE_CFLAGS_GNUC99     = -std=gnu99
+QMAKE_CFLAGS_GNUC11     = -std=gnu11
+QMAKE_CXXFLAGS_CXX11    = -std=c++11
+QMAKE_CXXFLAGS_CXX14    = -std=c++14
+QMAKE_CXXFLAGS_CXX1Z    = -std=c++1z
+QMAKE_CXXFLAGS_GNUCXX11 = -std=gnu++11
+QMAKE_CXXFLAGS_GNUCXX14 = -std=gnu++14
+QMAKE_CXXFLAGS_GNUCXX1Z = -std=gnu++1z
+
+QMAKE_CXXFLAGS          = $$QMAKE_CFLAGS
+QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF = $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE += $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO
+QMAKE_CXXFLAGS_DEBUG   += $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB    = $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC     = $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD   = $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+# modifications to linux.conf
+QMAKE_AR                = $${CROSS_COMPILE}llvm-ar cqs
+QMAKE_OBJCOPY           = $${CROSS_COMPILE}llvm-objcopy
+QMAKE_NM                = $${CROSS_COMPILE}llvm-nm -P
+
+QMAKE_STRIP             =
+
+QMAKE_RANLIB            = $${CROSS_COMPILE}llvm-ranlib
+
+QMAKE_INCDIR_POST       += $$shell_path($$SDK_ROOT/native/sysroot/usr/include) \
+                           $$shell_path($$SDK_ROOT/native/sysroot/usr/include/$${NDK_TOOLCHAIN_PREFIX})
+
+QMAKE_LIBDIR_POST       = $$shell_path($$SDK_ROOT/native/sysroot/usr/lib/$${NDK_TOOLCHAIN_PREFIX})
+QMAKE_INCDIR_X11        =
+QMAKE_LIBDIR_X11        =
+QMAKE_INCDIR_OPENGL     =
+QMAKE_LIBDIR_OPENGL     =
+
+QMAKE_LINK_SHLIB        = $$QMAKE_LINK
+QMAKE_LFLAGS            = --sysroot=$$shell_path($$SDK_ROOT/native/sysroot)
+QMAKE_LFLAGS_APP        = -Wl,--no-undefined -Wl,-z,noexecstack -shared
+QMAKE_LFLAGS_SHLIB      = -Wl,--no-undefined -Wl,-z,noexecstack -shared
+QMAKE_LFLAGS_PLUGIN     = $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_NOUNDEF    = -Wl,--no-undefined
+QMAKE_LFLAGS_RPATH      = -Wl,-rpath=
+QMAKE_LFLAGS_RPATHLINK  = -Wl,-rpath-link=
+
+#QMAKE_LIBS_PRIVATE      = -lc++ -lz -lm -ldl -lc -lhilog_ndk.z
+QMAKE_LIBS_X11          =
+QMAKE_LIBS_THREAD       =
+QMAKE_LIBS_EGL          = -lEGL
+QMAKE_LIBS_OPENGL       =
+QMAKE_LIBS_OPENGL_ES2   = -lGLESv3
+
+!exists($$SDK_ROOT): error("You need to set the OHOS_SDK_PATH environment variable to point to your Harmony NDK.")
+
+load(qt_config)
diff --git a/mkspecs/features/openharmony/openharmony.prf b/mkspecs/features/openharmony/openharmony.prf
new file mode 100644
index 0000000000..14524b35ee
--- /dev/null
+++ b/mkspecs/features/openharmony/openharmony.prf
@@ -0,0 +1,4 @@
+contains(TEMPLATE, ".*app") {
+    !contains(TARGET, ".so"): TARGET = lib$${TARGET}.so
+    QMAKE_LFLAGS += -Wl,-soname,$$shell_quote($$TARGET)
+}
diff --git a/mkspecs/features/qt_plugin.prf b/mkspecs/features/qt_plugin.prf
index 573d717eea..94b8dd5666 100644
--- a/mkspecs/features/qt_plugin.prf
+++ b/mkspecs/features/qt_plugin.prf
@@ -91,8 +91,19 @@ CONFIG(static, static|shared)|prefix_build {
 target.path = $$[QT_INSTALL_PLUGINS]/$$PLUGIN_TYPE
 INSTALLS += target
 
-qt_libinfix_plugins: TARGET = $$TARGET$$QT_LIBINFIX
-TARGET = $$qt5LibraryTarget($$TARGET, "plugins/$$PLUGIN_TYPE/")
+defineReplace(qt5OpenHarmonyPluginTarget) {
+    LIBRARY_NAME_PREFIX = $$2
+    LIBRARY_NAME_PREFIX = $$replace(LIBRARY_NAME_PREFIX, "//", "/")
+    LIBRARY_NAME_PREFIX = $$replace(LIBRARY_NAME_PREFIX, "/", "_")
+    LIBRARY_NAME = $$LIBRARY_NAME_PREFIX$$qtLibraryTarget($$1)
+    unset(LIBRARY_NAME_PREFIX)
+   return($$LIBRARY_NAME)
+}
+
+
+TARGET = $$qt5OpenHarmonyPluginTarget($$TARGET, "plugins/$$PLUGIN_TYPE/")
+#qt_libinfix_plugins: TARGET = $$TARGET$$QT_LIBINFIX
+#TARGET = $$qt5LibraryTarget($$TARGET, "plugins/$$PLUGIN_TYPE/")
 
 CONFIG += create_cmake
 
diff --git a/mkspecs/oh-clang/qmake.conf b/mkspecs/oh-clang/qmake.conf
new file mode 100644
index 0000000000..5bfd38b4f5
--- /dev/null
+++ b/mkspecs/oh-clang/qmake.conf
@@ -0,0 +1,39 @@
+# qmake configuration for building with oh-clang
+MAKEFILE_GENERATOR      = UNIX
+QMAKE_PLATFORM          = openharmony
+QMAKE_COMPILER          = gcc clang llvm
+
+CONFIG                 += unversioned_soname unversioned_libname plugin_with_soname $$QMAKE_PLATFORM
+
+include(../common/linux.conf)
+include(../common/gcc-base-unix.conf)
+include(../common/clang.conf)
+include(../common/oh-base-head.conf)
+
+NDK_LLVM_PATH = $$SDK_ROOT/native/llvm
+QMAKE_CC      = $${CROSS_COMPILE}clang
+QMAKE_CXX     = $${CROSS_COMPILE}clang++
+
+equals(OHOS_ARCH, armeabi-v7a): \
+        QMAKE_CFLAGS += -target arm-linux-ohos
+else:equals(OHOS_ARCH,arm64-v8a): \
+        QMAKE_CFLAGS += -target aarch64-linux-ohos
+else:equals(OHOS_ARCH,x86-64): \
+        QMAKE_CFLAGS += -target x86_64-linux-ohos
+
+#QMAKE_CFLAGS+=--gcc-toolchain=$$NDK_LLVM_PATH
+QMAKE_LINK += -Wl,--exclude-libs,$$shell_path($$SDK_ROOT/native/llvm/lib/$$NDK_TOOLCHAIN_PREFIX/libunwind.a)
+
+QMAKE_CFLAGS += --sysroot=$$shell_path($$SDK_ROOT/native/sysroot) \
+                -isystem=$$shell_path($$SDK_ROOT/native/sysroot) \
+                -isystem=$$shell_path($$SDK_ROOT/native/sysroot/usr/include) \
+                -isystem=$$shell_path($$SDK_ROOT/native/llvm/include/libcxx-ohos/include/c++/v1)
+
+
+QMAKE_CLFAGS += -g -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -fno-addrsig -Wa,--noexecstack -Wformat -Werror=format-security
+
+QMAKE_LINK    = $$QMAKE_CXX $$QMAKE_CFLAGS
+
+QMAKE_CFLAGS_OPTIMIZE_SIZE = -Oz
+
+include(../common/oh-base-tail.conf)
diff --git a/mkspecs/oh-clang/qplatformdefs.h b/mkspecs/oh-clang/qplatformdefs.h
new file mode 100644
index 0000000000..f405c91ecb
--- /dev/null
+++ b/mkspecs/oh-clang/qplatformdefs.h
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the qmake spec of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QPLATFORMDEFS_H
+#define QPLATFORMDEFS_H
+
+// Get Qt defines/settings
+
+#include "qglobal.h"
+
+// Set any POSIX/XOPEN defines at the top of this file to turn on specific APIs
+
+// 1) need to reset default environment if _BSD_SOURCE is defined
+// 2) need to specify POSIX thread interfaces explicitly in glibc 2.0
+// 3) it seems older glibc need this to include the X/Open stuff
+
+#include <unistd.h>
+
+// We are hot - unistd.h should have turned on the specific APIs we requested
+
+#include <features.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <pwd.h>
+#include <signal.h>
+#include <dlfcn.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/ipc.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#ifndef _GNU_SOURCE
+#  define _GNU_SOURCE
+#endif
+
+#ifdef QT_LARGEFILE_SUPPORT
+#define QT_STATBUF              struct stat64
+#define QT_STATBUF4TSTAT        struct stat64
+#define QT_STAT                 ::stat64
+#define QT_FSTAT                ::fstat64
+#define QT_LSTAT                ::lstat64
+#define QT_OPEN                 ::open64
+#define QT_TRUNCATE             ::truncate64
+#define QT_FTRUNCATE            ::ftruncate64
+#define QT_LSEEK                ::lseek64
+#else
+#define QT_STATBUF              struct stat
+#define QT_STATBUF4TSTAT        struct stat
+#define QT_STAT                 ::stat
+#define QT_FSTAT                ::fstat
+#define QT_LSTAT                ::lstat
+#define QT_OPEN                 ::open
+#define QT_TRUNCATE             ::truncate
+#define QT_FTRUNCATE            ::ftruncate
+#define QT_LSEEK                ::lseek
+#endif
+
+#ifdef QT_LARGEFILE_SUPPORT
+#define QT_FOPEN                ::fopen64
+#define QT_FSEEK                ::fseeko64
+#define QT_FTELL                ::ftello64
+#define QT_FGETPOS              ::fgetpos64
+#define QT_FSETPOS              ::fsetpos64
+#define QT_MMAP                 ::mmap64
+#define QT_FPOS_T               fpos64_t
+#define QT_OFF_T                off64_t
+#else
+#define QT_FOPEN                ::fopen
+#define QT_FSEEK                ::fseek
+#define QT_FTELL                ::ftell
+#define QT_FGETPOS              ::fgetpos
+#define QT_FSETPOS              ::fsetpos
+#define QT_MMAP                 ::mmap
+#define QT_FPOS_T               fpos_t
+#define QT_OFF_T                long
+#endif
+
+#define QT_STAT_REG             S_IFREG
+#define QT_STAT_DIR             S_IFDIR
+#define QT_STAT_MASK            S_IFMT
+#define QT_STAT_LNK             S_IFLNK
+#define QT_SOCKET_CONNECT       ::connect
+#define QT_SOCKET_BIND          ::bind
+#define QT_FILENO               fileno
+#define QT_CLOSE                ::close
+#define QT_READ                 ::read
+#define QT_WRITE                ::write
+#define QT_ACCESS               ::access
+#define QT_GETCWD               ::getcwd
+#define QT_CHDIR                ::chdir
+#define QT_MKDIR                ::mkdir
+#define QT_RMDIR                ::rmdir
+#define QT_OPEN_LARGEFILE       O_LARGEFILE
+#define QT_OPEN_RDONLY          O_RDONLY
+#define QT_OPEN_WRONLY          O_WRONLY
+#define QT_OPEN_RDWR            O_RDWR
+#define QT_OPEN_CREAT           O_CREAT
+#define QT_OPEN_TRUNC           O_TRUNC
+#define QT_OPEN_APPEND          O_APPEND
+#define QT_OPEN_EXCL            O_EXCL
+
+// Directory iteration
+#define QT_DIR                  DIR
+
+#define QT_OPENDIR              ::opendir
+#define QT_CLOSEDIR             ::closedir
+
+#if defined(QT_LARGEFILE_SUPPORT) \
+        && defined(QT_USE_XOPEN_LFS_EXTENSIONS) \
+        && !defined(QT_NO_READDIR64)
+#define QT_DIRENT               struct dirent64
+#define QT_READDIR              ::readdir64
+#define QT_READDIR_R            ::readdir64_r
+#else
+#define QT_DIRENT               struct dirent
+#define QT_READDIR              ::readdir
+#define QT_READDIR_R            ::readdir_r
+#endif
+
+#define QT_SOCKET_CONNECT       ::connect
+#define QT_SOCKET_BIND          ::bind
+
+
+#define QT_SIGNAL_RETTYPE       void
+#define QT_SIGNAL_ARGS          int
+#define QT_SIGNAL_IGNORE        SIG_IGN
+
+#define QT_SOCKLEN_T            socklen_t
+
+#if defined(_XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500)
+#define QT_SNPRINTF             ::snprintf
+#define QT_VSNPRINTF            ::vsnprintf
+#endif
+
+#endif // QPLATFORMDEFS_H
diff --git a/src/corelib/global/qlogging.cpp b/src/corelib/global/qlogging.cpp
index 292116cc47..540d6f00a1 100644
--- a/src/corelib/global/qlogging.cpp
+++ b/src/corelib/global/qlogging.cpp
@@ -1668,6 +1668,36 @@ static bool android_default_message_handler(QtMsgType type,
 }
 #endif //Q_OS_ANDROID
 
+#ifdef Q_OS_OPENHARMONY
+#include <hilog/log.h>
+#define APP_LOG_DOMAIN 0xf000
+#define APP_LOG_TAG "QtForOpenHarmony"
+
+static bool openharmony_default_message_handler(QtMsgType type,
+                                                const QMessageLogContext &context,
+                                                const QString &message)
+{
+    if (shouldLogToStderr())
+        return false; // Leave logging up to stderr handler
+
+    QString formattedMessage = qFormatLogMessage(type, context, message);
+
+    LogLevel priority = LOG_INFO;
+    switch (type) {
+    //LOG_DEBUG unable to print, temporarily use LOG_ INFO replace.
+    case QtDebugMsg: priority = LOG_INFO; break;
+    case QtInfoMsg: priority = LOG_INFO; break;
+    case QtWarningMsg: priority = LOG_WARN; break;
+    case QtCriticalMsg: priority = LOG_ERROR; break;
+    case QtFatalMsg: priority = LOG_FATAL; break;
+    };
+
+    OH_LOG_Print(LOG_APP, priority, APP_LOG_DOMAIN, APP_LOG_TAG, "%{public}s %{public}s\n", qPrintable(QCoreApplication::applicationName()), qPrintable(formattedMessage));
+
+    return true; // Prevent further output to stderr
+}
+#endif
+
 #ifdef Q_OS_WIN
 static void win_outputDebugString_helper(const QString &message)
 {
@@ -1779,6 +1809,8 @@ static void qDefaultMessageHandler(QtMsgType type, const QMessageLogContext &con
     handledStderr |= AppleUnifiedLogger::messageHandler(type, context, message);
 # elif defined Q_OS_WASM
     handledStderr |= wasm_default_message_handler(type, context, message);
+#elif defined Q_OS_OPENHARMONY
+    handledStderr |= openharmony_default_message_handler(type, context, message);
 # endif
 #endif
 
diff --git a/src/corelib/global/qsystemdetection.h b/src/corelib/global/qsystemdetection.h
index ad5d30d544..72a026b182 100644
--- a/src/corelib/global/qsystemdetection.h
+++ b/src/corelib/global/qsystemdetection.h
@@ -118,6 +118,9 @@
 #elif defined(__ANDROID__) || defined(ANDROID)
 #  define Q_OS_ANDROID
 #  define Q_OS_LINUX
+#elif defined(__OHOS__) || defined(OPENHARMONY)
+#  define Q_OS_OPENHARMONY
+#  define Q_OS_LINUX
 #elif defined(__CYGWIN__)
 #  define Q_OS_CYGWIN
 #elif !defined(SAG_COM) && (!defined(WINAPI_FAMILY) || WINAPI_FAMILY==WINAPI_FAMILY_DESKTOP_APP) && (defined(WIN64) || defined(_WIN64) || defined(__WIN64__))
diff --git a/src/corelib/io/io.pri b/src/corelib/io/io.pri
index a33ffe75f2..721f07ddcc 100644
--- a/src/corelib/io/io.pri
+++ b/src/corelib/io/io.pri
@@ -195,6 +195,10 @@ win32 {
             SOURCES += \
                 io/qstandardpaths_android.cpp \
                 io/qstorageinfo_unix.cpp
+        } else:openharmony {
+            SOURCES += \
+                io/qstandardpaths_openharmony.cpp \
+                io/qstorageinfo_unix.cpp
         } else:haiku {
             SOURCES += \
                 io/qstandardpaths_haiku.cpp \
diff --git a/src/corelib/io/qfile.cpp b/src/corelib/io/qfile.cpp
index 14ce49da56..536a6849e2 100644
--- a/src/corelib/io/qfile.cpp
+++ b/src/corelib/io/qfile.cpp
@@ -864,7 +864,7 @@ QFile::copy(const QString &newName)
                 d->setError(QFile::CopyError, tr("Cannot open %1 for input").arg(d->fileName));
             } else {
                 const auto fileTemplate = QLatin1String("%1/qt_temp.XXXXXX");
-#ifdef QT_NO_TEMPORARYFILE
+#if defined(QT_NO_TEMPORARYFILE) || defined(Q_OS_OPENHARMONY)
                 QFile out(fileTemplate.arg(QFileInfo(newName).path()));
                 if (!out.open(QIODevice::ReadWrite))
                     error = true;
@@ -914,7 +914,7 @@ QFile::copy(const QString &newName)
                             d->setError(QFile::CopyError, tr("Cannot create %1 for output").arg(newName));
                         }
                     }
-#ifdef QT_NO_TEMPORARYFILE
+#if defined(QT_NO_TEMPORARYFILE) || defined(Q_OS_OPENHARMONY)
                     if (error)
                         out.remove();
 #else
diff --git a/src/corelib/io/qfileselector.cpp b/src/corelib/io/qfileselector.cpp
index ee378f6434..1798a905c6 100644
--- a/src/corelib/io/qfileselector.cpp
+++ b/src/corelib/io/qfileselector.cpp
@@ -199,6 +199,9 @@ static bool isLocalScheme(const QString &file)
     bool local = file == QLatin1String("qrc");
 #ifdef Q_OS_ANDROID
     local |= file == QLatin1String("assets");
+#endif
+#ifdef Q_OS_OPENHARMONY
+    local |= file == QLatin1String("rawfile");
 #endif
     return local;
 }
@@ -223,6 +226,10 @@ QUrl QFileSelector::select(const QUrl &filePath) const
         if (filePath.scheme() == QLatin1String("assets"))
             scheme = QLatin1String("assets:");
 #endif
+#ifdef Q_OS_OPENHARMONY
+        if (filePath.scheme() == QLatin1String("rawfile"))
+            scheme = QLatin1String("rawfile:");
+#endif
 
         QString equivalentPath = scheme + filePath.path();
         QString selectedPath = d->select(equivalentPath);
diff --git a/src/corelib/io/qsettings.cpp b/src/corelib/io/qsettings.cpp
index 46e661094a..ed3a9f0a47 100644
--- a/src/corelib/io/qsettings.cpp
+++ b/src/corelib/io/qsettings.cpp
@@ -1495,8 +1495,8 @@ void QConfFileSettingsPrivate::syncConfFile(QConfFile *confFile)
         bool ok = false;
         ensureAllSectionsParsed(confFile);
         ParsedSettingsMap mergedKeys = confFile->mergedKeyMap();
-
-#if !defined(QT_BOOTSTRAPPED) && QT_CONFIG(temporaryfile)
+/* FIXME 鸿蒙创建临时文件的权限问题,暂时使用QFile */
+#if !defined(QT_BOOTSTRAPPED) && QT_CONFIG(temporaryfile) && !defined(Q_OS_OPENHARMONY)
         QSaveFile sf(confFile->name);
         sf.setDirectWriteFallback(!atomicSyncOnly);
 #else
@@ -1525,11 +1525,10 @@ void QConfFileSettingsPrivate::syncConfFile(QConfFile *confFile)
             ok = writeFunc(sf, tempOriginalKeys);
         }
 
-#if !defined(QT_BOOTSTRAPPED) && QT_CONFIG(temporaryfile)
+#if !defined(QT_BOOTSTRAPPED) && QT_CONFIG(temporaryfile) && !defined(Q_OS_OPENHARMONY)
         if (ok)
             ok = sf.commit();
 #endif
-
         if (ok) {
             confFile->unparsedIniSections.clear();
             confFile->originalKeys = mergedKeys;
diff --git a/src/corelib/io/qstandardpaths_openharmony.cpp b/src/corelib/io/qstandardpaths_openharmony.cpp
new file mode 100644
index 0000000000..e4aa2cae6e
--- /dev/null
+++ b/src/corelib/io/qstandardpaths_openharmony.cpp
@@ -0,0 +1,137 @@
+#include "qstandardpaths.h"
+
+#ifndef QT_NO_STANDARDPATHS
+
+#include <QtCore/qmap.h>
+#include <QtCore/qopenharmonyjsobjectloader.h>
+#include <QtCore/qopenharmonyjsobject.h>
+#include <QDir>
+
+QT_BEGIN_NAMESPACE
+
+typedef QMap<QString, QString> OpenHarmonyDirCache;
+Q_GLOBAL_STATIC(OpenHarmonyDirCache, openHarmonyDirCache)
+
+static QString testDir()
+{
+    return QStandardPaths::isTestModeEnabled() ? QLatin1String("/qttest")
+                                               : QLatin1String("");
+}
+
+/*
+ * Locations where applications can place persistent files it owns.
+ * E.g., /storage/org.app/Music
+ */
+static QString getDir(const char *directoryField = 0)
+{
+    QString &path = (*openHarmonyDirCache)[QString(QLatin1String("APPNAME_%1")).arg(QLatin1String(directoryField))];
+    if (!path.isEmpty())
+        return path;
+
+    static QSharedPointer<QOpenHarmonyJsObject> jsStanardPaths;
+    if (jsStanardPaths.isNull())
+        jsStanardPaths = qJsObjectLoader->create("JsStandardPaths");
+    if (jsStanardPaths.isNull())
+        return QString();
+    QString result = jsStanardPaths->call<QString>("path", QString::fromLatin1(directoryField));
+    path = result;
+    return result;
+}
+
+QString QStandardPaths::writableLocation(StandardLocation type)
+{
+    switch (type) {
+    case QStandardPaths::MusicLocation:
+        return writableLocation(QStandardPaths::AppLocalDataLocation) + QLatin1String("/Music");
+//        return getDir("DIRECTORY_MUSIC");
+    case QStandardPaths::MoviesLocation:
+        return writableLocation(QStandardPaths::AppLocalDataLocation) + QLatin1String("/Videos");
+//        return getDir("DIRECTORY_MOVIES");
+    case QStandardPaths::PicturesLocation:
+        return writableLocation(QStandardPaths::AppLocalDataLocation) + QLatin1String("/Pictures");
+//        return getDir("DIRECTORY_PICTURES");
+    case QStandardPaths::DocumentsLocation:
+        return writableLocation(QStandardPaths::AppLocalDataLocation) + QLatin1String("/Documents");
+        return getDir("DIRECTORY_DOCUMENTS");
+    case QStandardPaths::DownloadLocation:
+        return writableLocation(QStandardPaths::AppLocalDataLocation) + QLatin1String("/Downloads");
+//        return getDir("DIRECTORY_DOWNLOADS");
+    case QStandardPaths::GenericConfigLocation:
+    case QStandardPaths::ConfigLocation:
+    case QStandardPaths::AppConfigLocation:
+        return getDir("DIRECTORY_CACHE") + testDir() + QLatin1String("/settings");
+    case QStandardPaths::GenericDataLocation:
+        return getDir("DIRECTORY_CACHE") + testDir();
+    case QStandardPaths::AppDataLocation:
+    case QStandardPaths::AppLocalDataLocation:
+        return getDir("DIRECTORY_FILES") + testDir();
+    case QStandardPaths::RuntimeLocation:
+        return getDir("DIRECTORY_CACHE");
+    case QStandardPaths::TempLocation:
+        return getDir("DIRECTORY_TEMP");
+    case QStandardPaths::GenericCacheLocation:
+    case QStandardPaths::CacheLocation:
+        return getDir("DIRECTORY_CACHE");
+    case QStandardPaths::DesktopLocation:
+    case QStandardPaths::HomeLocation:
+        return writableLocation(QStandardPaths::AppLocalDataLocation) + QLatin1String("/Desktop");
+//        return getDir("DIRECTORY_DESKTOP");
+    case QStandardPaths::ApplicationsLocation:
+    case QStandardPaths::FontsLocation:
+    default:
+        break;
+    }
+
+    return QString();
+}
+
+QStringList QStandardPaths::standardLocations(StandardLocation type)
+{
+    if (type == MusicLocation) {
+        return QStringList() << writableLocation(type);
+    }
+
+    if (type == MoviesLocation) {
+        return QStringList() << writableLocation(type);
+    }
+
+    if (type == PicturesLocation) {
+        return QStringList()  << writableLocation(type);
+    }
+
+    if (type == DocumentsLocation) {
+        return QStringList() << writableLocation(type);
+    }
+
+    if (type == DownloadLocation) {
+        return QStringList() << writableLocation(type);
+    }
+
+    if (type == AppDataLocation || type == AppLocalDataLocation) {
+        return QStringList() << writableLocation(type);
+    }
+
+    if (type == CacheLocation) {
+        return QStringList() << writableLocation(type);
+    }
+
+    if (type == FontsLocation) {
+        QString &fontLocation = (*openHarmonyDirCache)[QStringLiteral("FONT_LOCATION")];
+        if (!fontLocation.isEmpty())
+            return QStringList(fontLocation);
+
+        const QByteArray ba = qgetenv("QT_OpenHarmony_FONT_LOCATION");
+        if (!ba.isEmpty())
+            return QStringList((fontLocation = QDir::cleanPath(QString::fromLocal8Bit(ba))));
+
+        // Don't cache the fallback, as we might just have been called before
+        // QT_OpenHarmony_FONT_LOCATION has been set.
+        return QStringList(QLatin1String("/system/fonts"));
+    }
+
+    return QStringList(writableLocation(type));
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_STANDARDPATHS
diff --git a/src/corelib/io/qtemporaryfile_p.h b/src/corelib/io/qtemporaryfile_p.h
index 6bcff936b4..bec3494a2f 100644
--- a/src/corelib/io/qtemporaryfile_p.h
+++ b/src/corelib/io/qtemporaryfile_p.h
@@ -58,7 +58,7 @@
 #include "private/qfile_p.h"
 #include "qtemporaryfile.h"
 
-#if defined(Q_OS_LINUX) && QT_CONFIG(linkat)
+#if defined(Q_OS_LINUX) && QT_CONFIG(linkat) && !defined(Q_OS_OPENHARMONY)
 #  include <fcntl.h>
 #  ifdef O_TMPFILE
 // some early libc support had the wrong values for O_TMPFILE
diff --git a/src/corelib/kernel/kernel.pri b/src/corelib/kernel/kernel.pri
index 749672c899..602dce2d9f 100644
--- a/src/corelib/kernel/kernel.pri
+++ b/src/corelib/kernel/kernel.pri
@@ -212,4 +212,24 @@ android:!android-embedded {
                    kernel/qjni_p.h
 }
 
+openharmony {
+    SOURCES += kernel/qopenharmonyload.cpp \
+            kernel/qopenharmonyjsobject.cpp  \
+            kernel/qopenharmonyjsobjectloader.cpp  \
+            kernel/qopenharmonyjsobjectpool.cpp \
+            kernel/qopenharmonyjsenvironment.cpp \
+            kernel/qopenharmonyjsfunction.cpp \
+            kernel/qopenharmonyhelpers.cpp
+
+    HEADERS += kernel/qopenharmonyjsobject.h \
+            kernel/qopenharmonyjsobjectloader.h  \
+            kernel/qopenharmonyjsobjectpool.h \
+            kernel/qopenharmonyjsenvironment.h \
+            kernel/qopenharmonydefines.h \
+            kernel/qopenharmonyjsfunction.h \
+            kernel/qopenharmonyhelpers_p.h
+
+    LIBS += -lace_napi.z -luv -lc++ -lz -lm -ldl -lc -lhilog_ndk.z
+}
+
 !darwin:!unix:!win32: SOURCES += kernel/qelapsedtimer_generic.cpp
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index d671f70bd3..cebbec8e29 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -2335,7 +2335,7 @@ QString QCoreApplication::applicationFilePath()
     }
 #endif
 #if defined( Q_OS_UNIX )
-#  if defined(Q_OS_LINUX) && (!defined(Q_OS_ANDROID) || defined(Q_OS_ANDROID_EMBEDDED))
+#  if defined(Q_OS_LINUX) && !defined(Q_OS_OPENHARMONY) && (!defined(Q_OS_ANDROID) || defined(Q_OS_ANDROID_EMBEDDED))
     // Try looking for a /proc/<pid>/exe symlink first which points to
     // the absolute path of the executable
     QFileInfo pfi(QString::fromLatin1("/proc/%1/exe").arg(getpid()));
diff --git a/src/corelib/kernel/qopenharmonydefines.h b/src/corelib/kernel/qopenharmonydefines.h
new file mode 100644
index 0000000000..7480dc1c20
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonydefines.h
@@ -0,0 +1,107 @@
+#ifndef QOPENHARMONYDEFINES_H
+#define QOPENHARMONYDEFINES_H
+#include <hilog/log.h>
+
+#define QPA_LOG_DOMAIN 0xff11
+#define QPA_LOG_TAG "QtForOpenHarmony"
+#define LOGI(...) ((void)OH_LOG_Print(LOG_APP, LOG_INFO, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGD(...) ((void)OH_LOG_Print(LOG_APP, LOG_DEBUG, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGW(...) ((void)OH_LOG_Print(LOG_APP, LOG_WARN, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGE(...) ((void)OH_LOG_Print(LOG_APP, LOG_ERROR, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+
+#define NAPI_RETVAL_NOTHING
+
+#define GET_AND_THROW_LAST_ERROR(env, status, function)                                                     \
+    do {                                                                                                    \
+        const napi_extended_error_info* errorInfo = nullptr;                                                \
+        napi_get_last_error_info((env), &errorInfo);                                                        \
+        bool isPending = false;                                                                             \
+        napi_is_exception_pending((env), &isPending);                                                       \
+        if (!isPending && errorInfo != nullptr) {                                                           \
+            const char* errorMessage =                                                                      \
+                errorInfo->error_message != nullptr ? errorInfo->error_message : function;                  \
+                LOGE("call method %{public}s failed, the error code is %{public}d", errorMessage, status);  \
+        }                                                                                                   \
+    } while (0)
+
+#define NAPI_ASSERT_BASE(env, assertion, message, retVal)                                    \
+    do {                                                                                     \
+        if (!(assertion)) {                                                                  \
+            napi_throw_error((env), nullptr, "assertion (" #assertion ") failed: " message); \
+            return retVal;                                                                   \
+        }                                                                                    \
+    } while (0)
+
+#define NAPI_ASSERT(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, nullptr)
+
+#define NAPI_ASSERT_RETURN_VOID(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_BASE(env, theCall, retVal)                   \
+    do {                                                       \
+        napi_status status = (theCall);                        \
+        if (status != napi_ok) {                               \
+            GET_AND_THROW_LAST_ERROR((env), status, #theCall); \
+            return retVal;                                     \
+        }                                                      \
+    } while (0)
+
+#define NAPI_CALL_BASE_NO_THROW(env, theCall, retVal) \
+    do {                                     \
+        if ((theCall) != napi_ok) {          \
+            return retVal;                   \
+        }                                    \
+    } while (0)
+
+#define NAPI_CALL(env, theCall) NAPI_CALL_BASE(env, theCall, nullptr)
+
+#define NAPI_CALL_RETURN_VOID(env, theCall) NAPI_CALL_BASE(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_RETURN_VOID_NO_THROW(env, theCall) NAPI_CALL_BASE_NO_THROW(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define DECLARE_NAPI_PROPERTY(name, val)                                       \
+    {                                                                          \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_STATIC_PROPERTY(name, val)                               \
+    {                                                                         \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION_WITH_DATA(name, func, data)                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, data    \
+    }
+
+#define DECLARE_NAPI_STATIC_FUNCTION(name, func)                                 \
+    {                                                                            \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER(name, getter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, (getter), nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_SETTER(name, setter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, nullptr, (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER_SETTER(name, getter, setter)                             \
+    {                                                                                \
+        (name), nullptr, nullptr, (getter), (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+
+#endif // QOPENHARMONYDEFINES_H
diff --git a/src/corelib/kernel/qopenharmonyhelpers.cpp b/src/corelib/kernel/qopenharmonyhelpers.cpp
new file mode 100644
index 0000000000..8a85fb5ded
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyhelpers.cpp
@@ -0,0 +1,132 @@
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsenvironment.h"
+#include "qmutex.h"
+#include "qlist.h"
+#include "qsemaphore.h"
+#include "qsharedpointer.h"
+#include "qvector.h"
+#include "qthread.h"
+#include "qcoreapplication.h"
+#include <QtCore/qrunnable.h>
+
+#include <deque>
+#include <memory>
+
+QT_BEGIN_NAMESPACE
+
+namespace QtHarmonyPrivate {
+    ResumePauseListener::~ResumePauseListener() {}
+    void ResumePauseListener::handlePause() {}
+    void ResumePauseListener::handleResume() {}
+
+    napi_value variant_to_napi_value(const QVariant &value)
+    {
+        napi_value ret = nullptr;
+        int t = value.userType();
+        switch (t) {
+        case QVariant::Int:
+            ret = qJs::createInt32(value.toInt());
+            break;
+        case QVariant::String:
+            ret = qJs::createString(value.toString());
+            break;
+        case QVariant::StringList:
+            ret = qJs::createStringArray(value.toStringList());
+            break;
+        case QVariant::Bool:
+            ret = qJs::createBool(value.toBool());
+            break;
+        case QVariant::LongLong:
+            ret = qJs::createInt64(value.toLongLong());
+            break;
+        case QVariant::ByteArray:
+            ret = qJs::createArrayBuffer(value.toByteArray());
+            break;
+        case QVariant::Map:
+            ret = qJs::createObject(value.toMap());
+            break;
+        default:
+            ret = qJs::createObjectFromUserType(value);
+            break;
+        }
+        return ret;
+    }
+
+    QVariant napi_value_to_variant(napi_value value, int t)
+    {
+        QVariant ret;
+        switch (t) {
+        case QMetaType::Int:
+            ret = qJs::getInt32(value);
+            break;
+        case QMetaType::QString:
+            ret = qJs::getString(value);
+            break;
+        case QMetaType::QStringList:
+            ret = qJs::getStringList(value);
+            break;
+        case QMetaType::Bool:
+            ret = qJs::getBool(value);
+            break;
+        case QMetaType::LongLong:
+            ret = QVariant::fromValue(qJs::getInt64(value));
+            break;
+        case QMetaType::QByteArray:
+            ret = QVariant::fromValue(qJs::getByteArray(value));
+            break;
+        case QMetaType::QByteArrayList:
+            ret = QVariant::fromValue(qJs::getByteArrayList(value));
+            break;
+        case QMetaType::QRect:
+            ret = qJs::getRect(value);
+            break;
+        default:
+            ret = qJs::createQVariantFromNapiValue(t, value);
+            break;
+        }
+        return ret;
+    }
+
+
+}
+
+namespace {
+class ResumePauseListeners
+{
+public:
+    QMutex mutex;
+    QList<QtHarmonyPrivate::ResumePauseListener *> listeners;
+};
+}
+
+Q_GLOBAL_STATIC(ResumePauseListeners, g_resumePauseListeners)
+
+void QtHarmonyPrivate::registerResumePauseListener(ResumePauseListener *listener)
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    g_resumePauseListeners()->listeners.append(listener);
+}
+
+void QtHarmonyPrivate::unregisterResumePauseListener(ResumePauseListener *listener)
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    g_resumePauseListeners()->listeners.removeAll(listener);
+}
+
+void QtHarmonyPrivate::handlePause()
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    const QList<QtHarmonyPrivate::ResumePauseListener *> &listeners = g_resumePauseListeners()->listeners;
+    for (int i=0; i<listeners.size(); ++i)
+        listeners.at(i)->handlePause();
+}
+
+void QtHarmonyPrivate::handleResume()
+{
+    QMutexLocker locker(&g_resumePauseListeners()->mutex);
+    const QList<QtHarmonyPrivate::ResumePauseListener *> &listeners = g_resumePauseListeners()->listeners;
+    for (int i=0; i<listeners.size(); ++i)
+        listeners.at(i)->handleResume();
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qopenharmonyhelpers_p.h b/src/corelib/kernel/qopenharmonyhelpers_p.h
new file mode 100644
index 0000000000..0c0bd12c64
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyhelpers_p.h
@@ -0,0 +1,43 @@
+#ifndef QOPENHARMONYHELPERS_H
+#define QOPENHARMONYHELPERS_H
+
+
+#include <functional>
+#include <QtCore/private/qglobal_p.h>
+#include <QHash>
+#include <QMetaType>
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+
+QT_BEGIN_NAMESPACE
+
+
+namespace QtHarmonyPrivate
+{
+    class Q_CORE_EXPORT ResumePauseListener
+    {
+    public:
+        virtual ~ResumePauseListener();
+        virtual void handlePause();
+        virtual void handleResume();
+    };
+
+
+    enum class PermissionsResult {
+        Granted,
+        Denied
+    };
+
+    Q_CORE_EXPORT void handlePause();
+    Q_CORE_EXPORT void handleResume();
+    Q_CORE_EXPORT void registerResumePauseListener(ResumePauseListener *listener);
+    Q_CORE_EXPORT void unregisterResumePauseListener(ResumePauseListener *listener);
+
+    Q_CORE_EXPORT napi_value variant_to_napi_value(const QVariant &value);
+
+    Q_CORE_EXPORT QVariant napi_value_to_variant(napi_value value, int t);
+}
+
+QT_END_NAMESPACE
+
+#endif // QJNIHELPERS_H
diff --git a/src/corelib/kernel/qopenharmonyjsenvironment.cpp b/src/corelib/kernel/qopenharmonyjsenvironment.cpp
new file mode 100644
index 0000000000..31da31e358
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsenvironment.cpp
@@ -0,0 +1,487 @@
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsfunction.h"
+
+#include <QCoreApplication>
+
+static napi_threadsafe_function g_threadsafe_call_js_function = nullptr;
+static napi_threadsafe_function g_threadsafe_runonjs_thread_function = nullptr;
+napi_env QOpenHarmonyJsEnvironment::m_env = nullptr;
+bool QOpenHarmonyJsEnvironment::m_exit = false;
+static QHash<int, NapiValueCreator *> g_creators;
+static QHash<int, std::function<QVariant(napi_value)> > g_qvariant_creators;
+static std::thread::id g_jsThreadId;
+struct JsThreadParam
+{
+    std::function<void()> f;
+};
+
+static void cleanup_creators()
+{
+    qDeleteAll(g_creators);
+    g_creators.clear();
+    g_qvariant_creators.clear();
+}
+
+static void _runOnJsThread(napi_env env, napi_value js_cb, void* context, void* data)
+{
+    JsThreadParam *js = (JsThreadParam *)data;
+    if (js == nullptr);
+    js->f();
+    delete js;
+}
+
+static void callJsFunction(napi_env env, napi_value js_cb, void* context, void* data) {
+    Q_UNUSED(env);
+    Q_UNUSED(context);
+    QOpenHarmonyJsFunction *function = (QOpenHarmonyJsFunction*)data;
+    if (function == nullptr)
+        return;
+
+    napi_value jsObject = function->attachedObject();
+    napi_valuetype type;
+    napi_typeof(env, jsObject, &type);
+    if (type != napi_object) {
+        qWarning() << "get attached js object failed:" << function->objectName();
+        function->cancel();
+        return;
+    }
+
+    napi_value objectFunction = qJs::function(jsObject, function->name());
+
+    function->call(jsObject, objectFunction);
+}
+
+void QOpenHarmonyJsEnvironment::init(napi_env env)
+{
+    m_env = env;
+
+    napi_value name;
+    napi_create_string_utf8(env, "CallJsFunction", NAPI_AUTO_LENGTH, &name);
+    napi_create_threadsafe_function(env, nullptr, nullptr, name, 0, 1, nullptr,
+                                                          nullptr, nullptr, callJsFunction, &g_threadsafe_call_js_function);
+    if (g_threadsafe_call_js_function == nullptr) {
+        LOGW("init call js function failed");
+    }
+
+    napi_create_string_utf8(env, "RunOnJsThread", NAPI_AUTO_LENGTH, &name);
+    napi_create_threadsafe_function(env, nullptr, nullptr, name, 0, 1, nullptr,
+                                    nullptr, nullptr, _runOnJsThread, &g_threadsafe_runonjs_thread_function);
+    if (g_threadsafe_runonjs_thread_function == nullptr) {
+        LOGW("init run on js thread function failed");
+    }
+    qAddPostRoutine(cleanup_creators);
+    g_jsThreadId = std::this_thread::get_id();
+}
+
+void QOpenHarmonyJsEnvironment::quit()
+{
+    m_exit = true;
+}
+
+void QOpenHarmonyJsEnvironment::throwError(const QString &errorMessage)
+{
+    QByteArray _data = errorMessage.toUtf8();
+    napi_throw_type_error(m_env, NULL, _data.constData());
+}
+
+napi_value QOpenHarmonyJsEnvironment::createString(const QString &value)
+{
+    QByteArray text = value.toUtf8();
+    const char *textData = text.constData();
+    return createString(textData);
+}
+
+napi_value QOpenHarmonyJsEnvironment::createStringArray(const QStringList &strList)
+{
+    napi_value result = nullptr;
+    if (napi_ok == napi_create_array(m_env, &result)) {
+        for (int k = 0; k < strList.count(); ++k) {
+            napi_set_element(m_env, result, k, createString(strList.at(k)));
+        }
+    }
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createArrayBuffer(const QByteArray &buffer)
+{
+    napi_value result = nullptr;
+    void *data = nullptr;
+    NAPI_CALL_BASE(m_env, napi_create_arraybuffer(m_env, buffer.length(), &data, &result), nullptr);
+    memcpy(data, buffer.data(), buffer.length());
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createObject()
+{
+    napi_value result = nullptr;
+    NAPI_CALL_BASE(m_env, napi_create_object(m_env, &result), nullptr);
+    return result;
+}
+
+void QOpenHarmonyJsEnvironment::setProperty(napi_value o, const QString &key, const QVariant &value)
+{
+    napi_value name = createString(key);
+    napi_value v = QtHarmonyPrivate::variant_to_napi_value(value);
+    napi_set_property(m_env, o, name, v);
+}
+
+napi_value QOpenHarmonyJsEnvironment::createObject(const QVariantMap &map)
+{
+    napi_value result = createObject();
+    if (result == nullptr)
+        return nullptr;
+    for (auto i = map.cbegin(); i != map.cend(); ++i){
+        setProperty(result, i.key(), i.value());
+    }
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createObjectFromUserType(const QVariant &value)
+{
+    if (!g_creators.contains(value.userType()))
+        return nullptr;
+    NapiValueCreator *c = g_creators.value(value.userType());
+    return c->create(value);
+}
+
+QVariant QOpenHarmonyJsEnvironment::createQVariantFromNapiValue(int type, napi_value value)
+{
+    if (!g_qvariant_creators.contains(type))
+        return QVariant();
+    return g_qvariant_creators.value(type)(value);
+}
+
+void QOpenHarmonyJsEnvironment::registerCreator(int type, NapiValueCreator *creator)
+{
+    g_creators.insert(type, creator);
+}
+
+void QOpenHarmonyJsEnvironment::runOnJsThread(const std::function<void ()> &f)
+{
+    if (m_exit || g_threadsafe_runonjs_thread_function == nullptr)
+        return;
+    JsThreadParam *p = new JsThreadParam;
+    p->f = f;
+    napi_call_threadsafe_function(g_threadsafe_runonjs_thread_function, p, napi_tsfn_blocking) == napi_ok;
+}
+
+void QOpenHarmonyJsEnvironment::registerQVariantCreator(int type, const std::function<QVariant (napi_value)> &f)
+{
+    g_qvariant_creators.insert(type, f);
+}
+
+napi_value QOpenHarmonyJsEnvironment::globalObject() {
+    napi_value _global;
+    NAPI_CALL(m_env, napi_get_global(m_env, &_global));
+    return _global;
+}
+
+napi_value QOpenHarmonyJsEnvironment::callFunction(napi_value object, napi_value function, int argc, const napi_value *argv)
+{
+    napi_value return_value;
+    NAPI_CALL(m_env, napi_call_function(m_env, object, function, argc, argv, &return_value));
+    return return_value;
+}
+
+bool QOpenHarmonyJsEnvironment::callThreadSafeFunction(QOpenHarmonyJsFunction *func)
+{
+    if (m_exit || g_threadsafe_call_js_function == nullptr)
+        return false;
+    return napi_call_threadsafe_function(g_threadsafe_call_js_function, func, napi_tsfn_blocking) == napi_ok;
+}
+
+QString QOpenHarmonyJsEnvironment::getString(napi_value value)
+{
+    size_t strLen = 0;
+    NAPI_CALL_BASE(m_env, napi_get_value_string_utf8(m_env, value, nullptr, -1, &strLen), QString());
+    size_t bufLen = strLen + 1;
+    std::unique_ptr<char[]> strBuffer = std::make_unique<char[]>(bufLen);
+    NAPI_CALL_BASE(m_env, napi_get_value_string_utf8(m_env, value, strBuffer.get(), bufLen, &strLen), QString());
+    QString str = QString::fromUtf8(strBuffer.get());
+    return str;
+}
+
+QList<int> QOpenHarmonyJsEnvironment::getNumbers(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QList<int>());
+    if (!result)
+        return QList<int>();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QList<int>());
+    QList<int> ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getInt32(temp);
+    }
+    return ret;
+}
+
+QList<double> QOpenHarmonyJsEnvironment::getRealNumbers(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QList<double>());
+    if (!result)
+        return QList<double>();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QList<double>());
+    QList<double> ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getDouble(temp);
+    }
+    return ret;
+}
+
+QStringList QOpenHarmonyJsEnvironment::getStringList(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QStringList());
+    if (!result)
+        return QStringList();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QStringList());
+    QStringList ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getString(temp);
+    }
+    return ret;
+}
+
+QByteArray QOpenHarmonyJsEnvironment::getByteArray(napi_value value)
+{
+    bool isArraryBuffer = false;
+    NAPI_CALL_BASE(m_env, napi_is_arraybuffer(m_env, value, &isArraryBuffer), QByteArray());
+    if (!isArraryBuffer) {
+        return QByteArray();
+    }
+    void *data = nullptr;
+    size_t lenght = 0;
+    NAPI_CALL_BASE(m_env, napi_get_arraybuffer_info(m_env, value, &data, &lenght), QByteArray());
+    QByteArray result = QByteArray((char*)(data), lenght);
+    return result;
+}
+
+QByteArrayList QOpenHarmonyJsEnvironment::getByteArrayList(napi_value value)
+{
+    bool result = false;
+    NAPI_CALL_BASE(m_env, napi_is_array(m_env, value, &result), QByteArrayList());
+    if (!result)
+        return QByteArrayList();
+    uint32_t length = 0;
+    NAPI_CALL_BASE(m_env, napi_get_array_length(m_env, value, &length), QByteArrayList());
+    QByteArrayList ret;
+    for (uint32_t i = 0; i < length; ++i) {
+        napi_value temp = nullptr;
+        napi_get_element(m_env, value, i, &temp);
+        if (temp == nullptr)
+            continue;
+        ret << getByteArray(temp);
+    }
+    return ret;
+}
+
+
+//QVariantMap QOpenHarmonyJsEnvironment::getMap(napi_value value)
+//{
+//    napi_value names;
+//    NAPI_CALL_BASE(m_env, napi_get_property_names(m_env, value, &names), QVariantMap());
+//    QByteArrayList nameList = getByteArrayList(names);
+//    if (nameList.isEmpty())
+//        return QVariantMap();
+//    QVariantMap ret;
+//    for (int i = 0; i < nameList.count(); ++i) {
+//        napi_value result = nullptr;
+//        QByteArray name = nameList.at(i);
+//        napi_get_named_property(m_env, value, name.constData(), &result);
+////        napi_valuetype valueType;
+////        napi_typeof(m_env, value, &valueType);
+////        if (valueType == napi_number)
+////            return 0;
+//    }
+//    return ret;
+//}
+
+bool QOpenHarmonyJsEnvironment::getBool(napi_value value)
+{
+    bool result;
+    NAPI_CALL_BASE(m_env, napi_get_value_bool(m_env, value, &result), false);
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::objectPropertyValue(napi_value object, const QString &name)
+{
+    napi_value result = nullptr;
+    QByteArray data = name.toUtf8();
+    NAPI_CALL(m_env, napi_get_named_property(m_env, object, data.constData(), &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createString(const char *value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_create_string_utf8(m_env, value, NAPI_AUTO_LENGTH, &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createBool(bool value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_get_boolean(m_env, value, &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createInt32(int value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_create_int32(m_env, value, &result));
+    return result;
+}
+
+napi_value QOpenHarmonyJsEnvironment::createInt64(qlonglong value)
+{
+    napi_value result;
+    NAPI_CALL(m_env, napi_create_int64(m_env, value, &result));
+    return result;
+}
+
+int64_t QOpenHarmonyJsEnvironment::getInt64(napi_value value)
+{
+    int64_t result;
+    NAPI_CALL_BASE(m_env, napi_get_value_int64(m_env, value, &result), 0);
+    return result;
+}
+
+int32_t QOpenHarmonyJsEnvironment::getInt32(napi_value value)
+{
+    int32_t result;
+    NAPI_CALL_BASE(m_env, napi_get_value_int32(m_env, value, &result), 0);
+    return result;
+}
+
+double QOpenHarmonyJsEnvironment::getDouble(napi_value value)
+{
+//    napi_valuetype valueType;
+//    napi_typeof(m_env, value, &valueType);
+//    if (valueType != napi_number)
+//        return 0;
+    double result;
+    NAPI_CALL_BASE(m_env, napi_get_value_double(m_env, value, &result), 0);
+    return result;
+}
+
+template<>
+void QOpenHarmonyJsEnvironment::getObjectPropertyValue<void>(napi_value object, const QString &propertyName)
+{
+
+}
+
+template<>
+QByteArray QOpenHarmonyJsEnvironment::getObjectPropertyValue<QByteArray>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getByteArray(value);
+}
+
+template<>
+QString QOpenHarmonyJsEnvironment::getObjectPropertyValue<QString>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getString(value);
+}
+
+template<>
+bool QOpenHarmonyJsEnvironment::getObjectPropertyValue<bool>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getBool(value);
+}
+
+template<>
+int64_t QOpenHarmonyJsEnvironment::getObjectPropertyValue<int64_t>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getInt64(value);
+}
+
+template<>
+int32_t QOpenHarmonyJsEnvironment::getObjectPropertyValue<int32_t>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getInt32(value);
+}
+
+template<>
+double QOpenHarmonyJsEnvironment::getObjectPropertyValue<double>(napi_value object, const QString &propertyName)
+{
+    napi_value value = objectPropertyValue(object, propertyName);
+    return getDouble(value);
+}
+
+template<>
+void *QOpenHarmonyJsEnvironment::getValue<void *>(napi_value value)
+{
+    return value;
+}
+
+template<>
+QByteArray QOpenHarmonyJsEnvironment::getValue<QByteArray>(napi_value value)
+{
+    return getByteArray(value);
+}
+
+template<>
+QString QOpenHarmonyJsEnvironment::getValue<QString>(napi_value value)
+{
+    return getString(value);
+}
+
+template<>
+bool QOpenHarmonyJsEnvironment::getValue<bool>(napi_value value)
+{
+    return getBool(value);
+}
+
+template<>
+int64_t QOpenHarmonyJsEnvironment::getValue<int64_t>(napi_value value)
+{
+    return getInt64(value);
+}
+
+template<>
+int32_t QOpenHarmonyJsEnvironment::getValue<int32_t>(napi_value value)
+{
+    return getInt32(value);
+}
+
+template<>
+double QOpenHarmonyJsEnvironment::getValue<double>(napi_value value)
+{
+    return getDouble(value);
+}
+
+QRect QOpenHarmonyJsEnvironment::getRect(napi_value value)
+{
+    int64_t left = getInt64(objectPropertyValue(value, "left"));
+    int64_t top = getInt64(objectPropertyValue(value, "top"));
+    int64_t width = getInt64(objectPropertyValue(value, "width"));
+    int64_t height = getInt64(objectPropertyValue(value, "height"));
+    return QRect(left, top, width, height);
+}
+
+std::thread::id QOpenHarmonyJsEnvironment::jsThreadId()
+{
+    return g_jsThreadId;
+}
diff --git a/src/corelib/kernel/qopenharmonyjsenvironment.h b/src/corelib/kernel/qopenharmonyjsenvironment.h
new file mode 100644
index 0000000000..11a2c2bd64
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsenvironment.h
@@ -0,0 +1,175 @@
+#ifndef QOPENHARMONYJSENVIRONMENT_H
+#define QOPENHARMONYJSENVIRONMENT_H
+
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qrect.h>
+#include <thread>
+QT_BEGIN_NAMESPACE
+#define qJs QOpenHarmonyJsEnvironment
+class QOpenHarmonyJsFunction;
+
+struct NapiValueCreator
+{
+    virtual napi_value create(const QVariant &value) = 0;
+    virtual ~NapiValueCreator() {}
+};
+
+template <typename T>
+struct UserTypeNapiValueCreator : NapiValueCreator
+{
+    UserTypeNapiValueCreator(const std::function<napi_value(const T &)> &f) : _f(f) {}
+    virtual napi_value create(const QVariant &value)
+    {
+        if (_f && value.canConvert<T>()) {
+            return _f(value.value<T>());
+        }
+        return nullptr;
+    }
+    std::function<napi_value(const T &)> _f;
+};
+
+class Q_CORE_EXPORT QOpenHarmonyJsEnvironment
+{
+public:
+    QOpenHarmonyJsEnvironment();
+    ~QOpenHarmonyJsEnvironment();
+
+    static void init(napi_env env);
+
+    static void quit();
+
+    static std::thread::id jsThreadId();
+
+    static void throwError(const QString &errorMessage);
+
+    static napi_env env() { return m_env; }
+
+    static napi_value createString(const char *value);
+
+    static napi_value createString(const QString &value);
+
+    static napi_value createBool(bool value);
+
+    static napi_value createInt32(int value);
+
+    static napi_value createInt64(qlonglong value);
+
+    static napi_value createStringArray(const QStringList &strList);
+
+    static napi_value createArrayBuffer(const QByteArray &buffer);
+
+    static napi_value createObject();
+
+    static void setProperty(napi_value o, const QString &key, const QVariant &value);
+
+    static napi_value createObject(const QVariantMap &map);
+
+    static napi_value createObjectFromUserType(const QVariant &value);
+
+    static QVariant createQVariantFromNapiValue(int type, napi_value value);
+
+    template<typename T>
+    static void registerCreator(const std::function<napi_value(const T &)> &f)
+    {
+        int id = qMetaTypeId<T>();
+        NapiValueCreator *creator = new UserTypeNapiValueCreator<T>(f);
+        registerCreator(id, creator);
+    }
+
+    template<typename T>
+    static void registerQVariantCreator(const std::function<QVariant(napi_value)> &f)
+    {
+        int id = qMetaTypeId<T>();
+        registerQVariantCreator(id, f);
+    }
+
+    static void registerCreator(int type, NapiValueCreator *creator);
+
+    static void runOnJsThread(const std::function<void()> &f);
+
+    static void registerQVariantCreator(int type, const std::function<QVariant(napi_value)> &f);
+
+    static napi_value globalObject();
+
+    static napi_value globalThis()
+    {
+        return objectPropertyValue(globalObject(), QLatin1String("globalThis"));
+    }
+
+    static napi_value jsObject(const QString &name)
+    {
+        return objectPropertyValue(globalThis(), name);
+    }
+
+    static napi_value function(napi_value jsObject, const QString &functionName)
+    {
+        return objectPropertyValue(jsObject, functionName);
+    }
+
+    template<typename T>
+    static T getObjectPropertyValue(napi_value object, const QString &propertyName);
+
+    template<typename T>
+    static T getValue(napi_value value);
+
+    static napi_value callFunction(napi_value object, napi_value function, int argc = 0, const napi_value *argv = nullptr);
+
+    static bool callThreadSafeFunction(QOpenHarmonyJsFunction *func);
+
+    static QString getString(napi_value value);
+
+    static QList<int> getNumbers(napi_value value);
+    static QList<double> getRealNumbers(napi_value value);
+
+    static QStringList getStringList(napi_value value);
+
+    static QByteArray getByteArray(napi_value value);
+
+    static QByteArrayList getByteArrayList(napi_value value);
+
+    static bool getBool(napi_value value);
+
+    static int64_t getInt64(napi_value value);
+
+    static int32_t getInt32(napi_value value);
+
+    static double getDouble(napi_value value);
+
+    static QRect getRect(napi_value value);
+
+    static napi_value objectPropertyValue(napi_value object, const QString &propertyName);
+
+    static napi_value initJsObjectLoader(napi_env env, napi_callback_info info);
+    static napi_value initRemoveObject(napi_env env, napi_callback_info info);
+private:
+    static napi_env m_env;
+    static bool m_exit;
+};
+
+template<>
+inline QList<int> QOpenHarmonyJsEnvironment::getValue<QList<int>>(napi_value value)
+{
+    return getNumbers(value);
+}
+
+template<>
+inline QList<double> QOpenHarmonyJsEnvironment::getValue(napi_value value)
+{
+    return getRealNumbers(value);
+}
+
+template<>
+inline QByteArrayList QOpenHarmonyJsEnvironment::getValue<QByteArrayList>(napi_value value)
+{
+    return getByteArrayList(value);
+}
+
+template<>
+inline QStringList QOpenHarmonyJsEnvironment::getValue<QStringList>(napi_value value)
+{
+    return getStringList(value);
+}
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYJSENVIRONMENT_H
diff --git a/src/corelib/kernel/qopenharmonyjsfunction.cpp b/src/corelib/kernel/qopenharmonyjsfunction.cpp
new file mode 100644
index 0000000000..3488f9c73e
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsfunction.cpp
@@ -0,0 +1,208 @@
+#include "qopenharmonyjsfunction.h"
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsobject.h"
+
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qmetaobject.h>
+#include <QtCore/qthread.h>
+#include <QtCore/qelapsedtimer.h>
+#include <QtCore/qdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsFunctionPrivate
+{
+public:
+    QOpenHarmonyJsFunctionPrivate();
+    void init(napi_value function, const QString &functionName);
+    QString jsObjectName() const;
+    const QVariantList &args() const;
+    static napi_value then(napi_env, napi_callback_info info);
+
+    void setResult(napi_value result);
+    void wait(int timeout = 5000);
+
+    bool hasResult() const;
+
+    QOpenHarmonyJsFunction *q_ptr;
+    QString m_name;
+    QVariantList m_args;
+    QOpenHarmonyJsObject *m_jsObject;
+    QVariant m_result;
+    int m_resultType;
+    napi_ref m_objectRef;
+    QBasicAtomicInt m_bResultReceived; // bool
+};
+
+QOpenHarmonyJsFunctionPrivate::QOpenHarmonyJsFunctionPrivate() 
+    : m_resultType(QVariant::Invalid)
+    , m_objectRef(nullptr)
+{
+    m_bResultReceived.storeRelease(false);
+}
+
+
+const QVariantList &QOpenHarmonyJsFunctionPrivate::args() const
+{
+    return m_args;
+}
+
+QString QOpenHarmonyJsFunctionPrivate::jsObjectName() const
+{
+    return m_jsObject->objectName();
+}
+
+void QOpenHarmonyJsFunctionPrivate::wait(int timeout)
+{    
+    QElapsedTimer start;
+    start.start();
+    while (!m_bResultReceived.loadAcquire()) {
+        if (start.elapsed() > timeout)
+            break;
+    }
+    if (!m_bResultReceived.loadAcquire()) {
+        LOGW("Wait js method %{public}s result failded", qPrintable(m_name));
+        m_bResultReceived.storeRelease(true);
+    }
+}
+
+bool QOpenHarmonyJsFunctionPrivate::hasResult() const
+{
+    return m_resultType != QVariant::Invalid && m_resultType != QMetaType::Void;
+}
+
+napi_value QOpenHarmonyJsFunctionPrivate::then(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value argv[1] = {nullptr};
+    void *data = nullptr;
+    napi_get_cb_info(env, info, &argc, argv, nullptr, &data);
+    QOpenHarmonyJsFunctionPrivate *function = reinterpret_cast<QOpenHarmonyJsFunctionPrivate *>(data);
+    if (function != nullptr)
+        function->setResult(argv[0]);
+    return argv[0];
+}
+
+void QOpenHarmonyJsFunctionPrivate::setResult(napi_value result)
+{
+    if (m_resultType == QOpenHarmonyJsFunction::JsRefType) {
+        LOGI("Get js method %1 result object ref from callback: %{public}s", qPrintable(m_name));
+        napi_create_reference(qJs::env(), result, 1, &m_objectRef);
+        m_bResultReceived.storeRelease(true);
+        return;
+    }
+    m_result = QtHarmonyPrivate::napi_value_to_variant(result, m_resultType);
+    if (m_result.type() == QVariant::ByteArray) {
+        LOGI("Get js method %{public}s result from callback QByteArrary length: %{public}d", qPrintable(m_name), m_result.toByteArray().length());
+    } else {
+        LOGI("Get js method %{public}s result from callback: %{public}s", qPrintable(m_name), qPrintable(m_result.toString()));
+    }
+    m_bResultReceived.storeRelease(true);
+}
+
+QOpenHarmonyJsFunction::QOpenHarmonyJsFunction(const QOpenHarmonyJsObject *jsObject, const QString &functionName)
+{
+    d_ptr.reset(new QOpenHarmonyJsFunctionPrivate);
+    d_ptr->q_ptr = this;
+    d_ptr->m_jsObject = const_cast<QOpenHarmonyJsObject *>(jsObject);
+    d_ptr->m_name = functionName;
+}
+
+void QOpenHarmonyJsFunction::call(napi_value jsObject, napi_value function)
+{
+    Q_D(QOpenHarmonyJsFunction);
+    const QVariantList &args = d->args();
+
+    napi_value result = nullptr;
+    if (args.isEmpty()) {
+        result = qJs::callFunction(jsObject, function);
+    }
+    else {
+        size_t argc = static_cast<size_t>(args.count());
+        QScopedArrayPointer<napi_value> argv(new napi_value[argc]);
+        for (int i = 0; i < args.count(); ++i) {
+            argv[i] = nullptr;
+            argv[i] = QtHarmonyPrivate::variant_to_napi_value(args.at(i));
+        }
+        result = qJs::callFunction(jsObject, function, argc, argv.get());
+    }
+    if (!d->hasResult())
+        return;
+    bool is_promise = false;
+    napi_is_promise(qJs::env(), result, &is_promise);
+    napi_valuetype type;
+    napi_typeof(qJs::env(), result, &type);
+    LOGI("the result type is %{public}d the result is promise: %{public}d", type, is_promise);
+    if (is_promise) {
+        napi_value then = qJs::objectPropertyValue(result, "then");
+        napi_value func = nullptr;
+        napi_create_function(qJs::env(), "thenResult", 1, QOpenHarmonyJsFunctionPrivate::then, d, &func);
+        napi_value _argv[1] = {func};
+        //trigger then method
+        result = qJs::callFunction(result, then, 1, _argv);
+    } else {
+        d->setResult(result);
+    }
+}
+
+QOpenHarmonyJsFunction::~QOpenHarmonyJsFunction()
+{
+
+}
+
+void QOpenHarmonyJsFunction::call(const QVariantList &args)
+{    
+    d_ptr->m_bResultReceived.storeRelease(false);
+    d_ptr->m_args = args;
+    LOGI("call js function %{public}s", qPrintable(d_ptr->m_name));
+    if (!qJs::callThreadSafeFunction(this))
+        return;
+    if (!d_ptr->hasResult()) {
+        // 没有返回值的不等待
+        return;
+    }
+    d_ptr->wait();
+}
+
+QVariant QOpenHarmonyJsFunction::jsResult() const
+{
+    return d_ptr->m_result;
+}
+
+napi_ref QOpenHarmonyJsFunction::refResult() const
+{
+    Q_D(const QOpenHarmonyJsFunction);
+    return d->m_objectRef;
+}
+
+napi_value QOpenHarmonyJsFunction::attachedObject() const {
+    Q_D(const QOpenHarmonyJsFunction);
+    return d->m_jsObject->jsObject();
+}
+
+QString QOpenHarmonyJsFunction::name() const
+{
+    Q_D(const QOpenHarmonyJsFunction);
+    return d->m_name;
+}
+
+QString QOpenHarmonyJsFunction::objectName()
+{
+    Q_D(const QOpenHarmonyJsFunction);
+    return d->jsObjectName();
+}
+
+void QOpenHarmonyJsFunction::cancel()
+{
+    Q_D(QOpenHarmonyJsFunction);
+    d->m_bResultReceived.storeRelease(true);
+}
+
+void QOpenHarmonyJsFunction::setResultType(int t)
+{
+    d_ptr->m_resultType = t;
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qopenharmonyjsfunction.h b/src/corelib/kernel/qopenharmonyjsfunction.h
new file mode 100644
index 0000000000..17fb051a7b
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsfunction.h
@@ -0,0 +1,94 @@
+#ifndef QOPENHARMONYJSFUNCTION_H
+#define QOPENHARMONYJSFUNCTION_H
+
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qeventloop.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qopenharmonyjsenvironment.h>
+#include <QtCore/qobject.h>
+#include <QtCore/qtimer.h>
+#include <QDebug>
+QT_BEGIN_NAMESPACE
+class QOpenHarmonyJsObject;
+class QOpenHarmonyJsFunctionPrivate;
+
+class Q_CORE_EXPORT QOpenHarmonyJsFunction
+{
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsFunction)
+public:
+    enum { JsRefType = QMetaType::User + 1000 };
+    ~QOpenHarmonyJsFunction();
+
+    template <typename... Args> 
+    void callReturnRef(Args &&...args) {
+        QVariantList params;
+        setResultType(JsRefType);
+        call(packParams(params, std::forward<Args>(args)...));
+    }
+
+    template<typename RET, typename... Args>
+    void call(Args&&... args)
+    {
+        QVariantList params;
+        setResultType(qMetaTypeId<RET>());
+        call(packParams(params, std::forward<Args>(args)...));
+    }
+
+    template<typename... Args>
+    void callWithoutReturn(Args&&... args)
+    {
+        QVariantList params;
+        call(packParams(params, std::forward<Args>(args)...));
+    }
+
+    void call(const QVariantList &args);
+
+    template<typename RETURN_TYPE>
+    RETURN_TYPE result() const;
+
+    QVariant jsResult() const;
+
+    napi_ref refResult() const;
+
+    napi_value attachedObject() const;
+
+    QString name() const;
+
+    QString objectName();
+
+    void cancel();
+
+    void call(napi_value jsObject, napi_value function);
+private:
+    template<typename Arg0, typename... Args>
+    const QVariantList &packParams(QVariantList& paramList, Arg0&& arg, Args&&... args)
+    {
+        QVariant v;
+        v.setValue(std::forward<Arg0>(arg));
+        paramList.push_back(v);
+        packParams(paramList, std::forward<Args>(args)...);
+        return paramList;
+    }
+
+    const QVariantList& packParams(QVariantList& paramList)
+    {
+        return paramList;
+    }
+
+    void setResultType(int t);
+
+    friend class QOpenHarmonyJsObject;
+    QOpenHarmonyJsFunction(const QOpenHarmonyJsObject *jsObject, const QString &functionName);
+
+    QScopedPointer<QOpenHarmonyJsFunctionPrivate> d_ptr;
+};
+
+template<typename RET>
+RET QOpenHarmonyJsFunction::result() const
+{
+    return jsResult().value<RET>();
+}
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYJSFUNCTION_H
diff --git a/src/corelib/kernel/qopenharmonyjsobject.cpp b/src/corelib/kernel/qopenharmonyjsobject.cpp
new file mode 100644
index 0000000000..4bc0750e2a
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobject.cpp
@@ -0,0 +1,102 @@
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyjsfunction.h"
+#include "qopenharmonyjsobjectpool.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonyjsenvironment.h"
+
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectPrivate
+{
+    QOpenHarmonyJsObject *q_ptr;
+    Q_DECLARE_PUBLIC(QOpenHarmonyJsObject)
+public:
+    QOpenHarmonyJsObjectPrivate(const QString &objectType, const QString &objectName);
+    virtual ~QOpenHarmonyJsObjectPrivate();
+    QOpenHarmonyJsFunction *createJsFunction(const QString &jsFunction);
+
+    napi_ref m_jsObject = nullptr;
+    QString m_objectType;
+    QString m_objectName;
+
+    QHash<QString, QOpenHarmonyJsFunction *> m_functions;
+};
+
+QOpenHarmonyJsObject::QOpenHarmonyJsObject(const QString &objectType, const QString &objectName, napi_value jsObject)
+    : d_ptr(new QOpenHarmonyJsObjectPrivate(objectType, objectName))
+{
+    d_ptr->q_ptr = this;
+    // 必须使用ref, 否则会崩溃
+    napi_create_reference(qJs::env(), jsObject, 1, &d_ptr->m_jsObject);
+}
+
+QOpenHarmonyJsObject::~QOpenHarmonyJsObject()
+{
+    napi_ref object = d_ptr->m_jsObject;
+    qJs::runOnJsThread([object]{
+        napi_delete_reference(qJs::env(), object);
+    });
+}
+
+bool QOpenHarmonyJsObject::isValid() const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    return d->m_jsObject != nullptr;
+}
+
+QOpenHarmonyJsFunction *QOpenHarmonyJsObject::getJsFunction(const QString &name) const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    if (d->m_functions.contains(name)) {
+        return d->m_functions.value(name);
+    }
+
+    QOpenHarmonyJsFunction *function = new QOpenHarmonyJsFunction(this, name);
+    const_cast<QOpenHarmonyJsObjectPrivate *>(d)->m_functions.insert(name, function);
+    return function;
+}
+
+QString QOpenHarmonyJsObject::uniqueName() const
+{
+    return objectType() + "_" + objectName();
+}
+
+QString QOpenHarmonyJsObject::objectType() const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    return d->m_objectType;
+}
+
+QString QOpenHarmonyJsObject::objectName() const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    return d->m_objectName;
+}
+
+napi_value QOpenHarmonyJsObject::jsObject() const
+{
+    Q_D(const QOpenHarmonyJsObject);
+    napi_value jsObject;
+    napi_get_reference_value(qJs::env(), d->m_jsObject, &jsObject);
+    return jsObject;
+}
+
+
+QOpenHarmonyJsObjectPrivate::QOpenHarmonyJsObjectPrivate(const QString &objectType, const QString &objectName)
+    : m_objectType(objectType)
+    , m_objectName(objectName)
+{
+
+}
+
+QOpenHarmonyJsObjectPrivate::~QOpenHarmonyJsObjectPrivate()
+{
+    qDeleteAll(m_functions);
+    m_functions.clear();
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/corelib/kernel/qopenharmonyjsobject.h b/src/corelib/kernel/qopenharmonyjsobject.h
new file mode 100644
index 0000000000..6540813735
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobject.h
@@ -0,0 +1,79 @@
+#ifndef QOPENHARMONYJSOBJECT_H
+#define QOPENHARMONYJSOBJECT_H
+
+#include <napi/native_api.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qeventloop.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qopenharmonyjsfunction.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qscopedpointer.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectPrivate;
+
+class Q_CORE_EXPORT QOpenHarmonyJsObject
+{
+    friend class QOpenHarmonyJsObjectPool;
+    friend class QOpenHarmonyJsFunction;
+    friend class QSharedPointer<QOpenHarmonyJsObject>;
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsObject)
+public:
+    virtual ~QOpenHarmonyJsObject();
+
+    bool isValid() const;
+
+    template <typename... Args> 
+    napi_ref callReturnRef(const QString &jsFunction, Args &&...args)
+    {
+        QOpenHarmonyJsFunction *f = getJsFunction(jsFunction);
+        if (f == nullptr)
+            return nullptr;
+
+        f->callReturnRef(std::forward<Args>(args)...);
+        return f->refResult();
+    }
+
+    template<typename RET, typename... Args>
+    RET call(const QString &jsFunction, Args&&... args);
+
+    template<typename... Args>
+    void callWithoutReturn(const QString &jsFunction, Args&&... args)
+    {
+        QOpenHarmonyJsFunction *f = getJsFunction(jsFunction);
+        if (f == nullptr)
+            return;
+        f->callWithoutReturn(std::forward<Args>(args)...);
+    }
+
+    QOpenHarmonyJsFunction *getJsFunction(const QString &name) const;
+
+    QString objectName() const;
+    QString objectType() const;
+
+    QString uniqueName() const;
+
+private:
+    Q_DISABLE_COPY(QOpenHarmonyJsObject)
+    QOpenHarmonyJsObject(const QString &objectType, const QString &objectName, napi_value jsObject);
+
+    napi_value jsObject() const;
+
+    QScopedPointer<QOpenHarmonyJsObjectPrivate> d_ptr;
+};
+
+template<typename RET, typename... Args>
+RET QOpenHarmonyJsObject::call(const QString &jsFunction, Args&&... args)
+{
+    QOpenHarmonyJsFunction *f = getJsFunction(jsFunction);
+    if (f == nullptr)
+        return RET();
+
+    f->call<RET>(std::forward<Args>(args)...);
+    return f->result<RET>();
+}
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/corelib/kernel/qopenharmonyjsobjectloader.cpp b/src/corelib/kernel/qopenharmonyjsobjectloader.cpp
new file mode 100644
index 0000000000..20ec43c33c
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectloader.cpp
@@ -0,0 +1,181 @@
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonyjsobjectpool.h"
+#include "qopenharmonyhelpers_p.h"
+#include "qopenharmonydefines.h"
+
+#include <QtCore/qelapsedtimer.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qmap.h>
+
+Q_GLOBAL_STATIC(QOpenHarmonyJsObjectLoader, loader)
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectLoaderPrivate
+{
+    Q_DECLARE_PUBLIC(QOpenHarmonyJsObjectLoader)
+public:
+    QOpenHarmonyJsObjectLoader *q_ptr;
+    QBasicAtomicInt m_bObjectCreated; // bool
+
+    void wait(const QString &objectType, const QString &objectName, int timeout);
+    void objectCreated();
+};
+
+static napi_threadsafe_function g_threadsafe_new_object_function = nullptr;
+static napi_ref g_new_object_function_ref = nullptr;
+static napi_threadsafe_function g_threadsafe_remove_object_function = nullptr;
+static napi_ref g_remove_object_function_ref = nullptr;
+
+struct ObjectParams {
+    QOpenHarmonyJsObjectLoaderPrivate *loader;
+    QVariantList constructArgs;
+    QString type;
+    QString name;
+};
+
+static void cleanup()
+{
+    napi_release_threadsafe_function(g_threadsafe_new_object_function, napi_tsfn_release);
+    napi_release_threadsafe_function(g_threadsafe_remove_object_function, napi_tsfn_release);
+    napi_delete_reference(qJs::env(), g_new_object_function_ref);
+    napi_delete_reference(qJs::env(), g_remove_object_function_ref);
+}
+
+static void callNewObject(napi_env env, napi_value js_cb, void* context, void* data) {
+    Q_UNUSED(env);
+    Q_UNUSED(context);
+
+    ObjectParams *p = (ObjectParams*)data;
+    size_t argc = 1 + 1 + static_cast<size_t>(p->constructArgs.count());
+    QScopedArrayPointer<napi_value> argv(new napi_value[argc]);
+    argv[0] = qJs::createString(p->type);
+    argv[1] = qJs::createString(p->name);
+    if (!p->constructArgs.isEmpty()) {
+        for (int i = 0; i < p->constructArgs.count(); ++i) {
+            argv[i + 2] = nullptr;
+            argv[i + 2] = QtHarmonyPrivate::variant_to_napi_value(p->constructArgs.at(i));
+        }
+    }
+    napi_value undefined = nullptr;
+    napi_get_undefined(qJs::env(), &undefined);
+    napi_value object = qJs::callFunction(undefined, js_cb, argc, argv.get());
+    qJsObjectPool->create(p->type, p->name, object);
+    p->loader->objectCreated();
+    delete p;
+}
+
+static void callRemoveObject(napi_env env, napi_value js_cb, void* context, void* data) {
+    Q_UNUSED(env);
+    Q_UNUSED(context);
+    const char *objectName = (const char *)(data);
+
+    napi_value undefined = nullptr;
+    napi_get_undefined(qJs::env(), &undefined);
+    napi_value argv[1] = {qJs::createString(objectName)};
+    qJs::callFunction(undefined, js_cb, 1, argv);
+}
+
+
+napi_value QOpenHarmonyJsObjectLoader::initJsObjectLoader(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
+
+    if (argc != 2) {
+        return qJs::createBool(false);
+    }
+
+    napi_value newObject = args[0];
+    napi_create_reference(env, newObject, 1, &g_new_object_function_ref);
+    napi_value removeObject = args[1];
+    napi_create_reference(env, removeObject, 1, &g_remove_object_function_ref);
+
+    napi_value name_newObject;
+    napi_create_string_utf8(env, "JsObjectLoader", NAPI_AUTO_LENGTH, &name_newObject);
+    napi_create_threadsafe_function(env, newObject, nullptr, name_newObject, 0, 1, nullptr,
+                                                          nullptr, nullptr, callNewObject, &g_threadsafe_new_object_function);
+
+    napi_value name_removeObject;
+    napi_create_string_utf8(env, "RemoveObject", NAPI_AUTO_LENGTH, &name_removeObject);
+    napi_create_threadsafe_function(env, removeObject, nullptr, name_removeObject, 0, 1, nullptr,
+                                                          nullptr, nullptr, callRemoveObject, &g_threadsafe_remove_object_function);
+
+    if (g_threadsafe_new_object_function == nullptr || g_threadsafe_remove_object_function == nullptr)
+        return qJs::createBool(false);
+    qAddPostRoutine(cleanup);
+    return qJs::createBool(true);
+}
+
+QOpenHarmonyJsObjectLoader::QOpenHarmonyJsObjectLoader()
+{
+    d_ptr.reset(new QOpenHarmonyJsObjectLoaderPrivate);
+    d_ptr->q_ptr = this;
+}
+
+QOpenHarmonyJsObjectLoader::~QOpenHarmonyJsObjectLoader()
+{
+
+}
+
+QOpenHarmonyJsObjectLoader *QOpenHarmonyJsObjectLoader::instance()
+{
+    return loader();
+}
+
+QSharedPointer<QOpenHarmonyJsObject> QOpenHarmonyJsObjectLoader::create(const QString &objectType, const QString &objectName, const QVariantList &constructArgs)
+{
+    LOGI("request js object: %{public}s %{public}s", qPrintable(objectType), qPrintable(objectName));
+    if (objectType.isEmpty())
+        return QSharedPointer<QOpenHarmonyJsObject>();
+
+    QString _objectName = objectName;
+    if (_objectName.isEmpty())
+        _objectName = objectType;
+    QSharedPointer<QOpenHarmonyJsObject> object = qJsObjectPool->find(objectType, _objectName);
+    if (object.isNull() && g_threadsafe_new_object_function != nullptr) {
+        d_ptr->m_bObjectCreated.storeRelease(false);
+        ObjectParams *p = new ObjectParams;
+        p->constructArgs = constructArgs;
+        p->name = _objectName;
+        p->type = objectType;
+        p->loader = d_ptr.data();
+        napi_call_threadsafe_function(g_threadsafe_new_object_function, p, napi_tsfn_blocking);
+        d_ptr->wait(objectType, _objectName, 3000);
+    }
+    return qJsObjectPool->find(objectType, _objectName);
+}
+
+void QOpenHarmonyJsObjectLoader::remove(const QString &name)
+{
+    if (g_threadsafe_remove_object_function != nullptr) {
+        QByteArray dataArray = name.toLatin1();
+        char *_data = dataArray.data();
+        napi_call_threadsafe_function(g_threadsafe_remove_object_function, (void *)_data, napi_tsfn_blocking);
+    }
+    qJsObjectPool->remove(name);
+}
+
+void QOpenHarmonyJsObjectLoaderPrivate::wait(const QString &objectType, const QString &objectName, int timeout)
+{
+    QElapsedTimer start;
+    start.start();
+    while (!m_bObjectCreated.loadAcquire()) {
+        if (start.elapsed() > timeout)
+            break;
+    }
+    if (!m_bObjectCreated.loadAcquire()) {
+        LOGW("create type of %{public}s js object %{public}s result failded", qPrintable(objectType), qPrintable(objectName));
+    }
+}
+
+void QOpenHarmonyJsObjectLoaderPrivate::objectCreated()
+{
+    m_bObjectCreated.storeRelease(true);
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/corelib/kernel/qopenharmonyjsobjectloader.h b/src/corelib/kernel/qopenharmonyjsobjectloader.h
new file mode 100644
index 0000000000..6ef2855374
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectloader.h
@@ -0,0 +1,36 @@
+#ifndef QOPENHARMONYJSOBJECTLOADER_H
+#define QOPENHARMONYJSOBJECTLOADER_H
+
+#include <QtCore/qstring.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qsharedpointer.h>
+#include <napi/native_api.h>
+
+QT_BEGIN_NAMESPACE
+
+#define qJsObjectLoader QOpenHarmonyJsObjectLoader::instance()
+
+class QOpenHarmonyJsObject;
+class QOpenHarmonyJsObjectLoaderPrivate;
+
+class Q_CORE_EXPORT QOpenHarmonyJsObjectLoader
+{
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsObjectLoader)
+public:
+    QOpenHarmonyJsObjectLoader();
+    virtual ~QOpenHarmonyJsObjectLoader();
+
+    static QOpenHarmonyJsObjectLoader *instance();
+
+    QSharedPointer<QOpenHarmonyJsObject> create(const QString &objectType, const QString &objectName = QString(), const QVariantList &constructArgs = QVariantList());
+
+    void remove(const QString &name);
+
+    static napi_value initJsObjectLoader(napi_env env, napi_callback_info info);
+private:
+    QScopedPointer<QOpenHarmonyJsObjectLoaderPrivate> d_ptr;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/corelib/kernel/qopenharmonyjsobjectpool.cpp b/src/corelib/kernel/qopenharmonyjsobjectpool.cpp
new file mode 100644
index 0000000000..5812add919
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectpool.cpp
@@ -0,0 +1,72 @@
+#include "qopenharmonyjsobjectpool.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyjsfunction.h"
+#include "qopenharmonyjsobject.h"
+
+
+Q_GLOBAL_STATIC(QOpenHarmonyJsObjectPool, pool)
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObjectPoolPrivate
+{
+    Q_DECLARE_PUBLIC(QOpenHarmonyJsObjectPool)
+
+    QOpenHarmonyJsObjectPool *q_ptr;
+
+    QHash<QString, QSharedPointer<QOpenHarmonyJsObject>> m_jsObjects;
+
+    QSharedPointer<QOpenHarmonyJsObject> add(const QString &objectType, const QString &objectName, napi_value jsObject);
+    QString uniqueName(const QString &objectType, const QString &objectName) const;
+};
+
+QOpenHarmonyJsObjectPool::QOpenHarmonyJsObjectPool()
+    : d_ptr(new QOpenHarmonyJsObjectPoolPrivate)
+{
+    d_ptr->q_ptr = this;
+}
+
+QOpenHarmonyJsObjectPool::~QOpenHarmonyJsObjectPool()
+{
+
+}
+
+QOpenHarmonyJsObjectPool *QOpenHarmonyJsObjectPool::instance()
+{
+    return pool();
+}
+
+QSharedPointer<QOpenHarmonyJsObject> QOpenHarmonyJsObjectPoolPrivate::add(const QString &objectType, const QString &objectName, napi_value jsObject)
+{
+    QSharedPointer<QOpenHarmonyJsObject> object = QSharedPointer<QOpenHarmonyJsObject>::create(objectType, objectName, jsObject);
+    m_jsObjects.insert(object->uniqueName(), object);
+    return object;
+}
+
+QString QOpenHarmonyJsObjectPoolPrivate::uniqueName(const QString &objectType, const QString &objectName) const
+{
+    return objectType + "_" + objectName;
+}
+
+bool QOpenHarmonyJsObjectPool::remove(const QString &name)
+{
+    Q_D(QOpenHarmonyJsObjectPool);
+    if (d->m_jsObjects.contains(name)) {
+         QSharedPointer<QOpenHarmonyJsObject> object = d->m_jsObjects.take(name);
+    }
+    return true;
+}
+
+QSharedPointer<QOpenHarmonyJsObject> QOpenHarmonyJsObjectPool::find(const QString &objectType, const QString &objectName)
+{
+    Q_D(QOpenHarmonyJsObjectPool);
+    return  d->m_jsObjects.value(d->uniqueName(objectType, objectName));
+}
+
+void QOpenHarmonyJsObjectPool::create(const QString &objectType, const QString &objectName, napi_value jsObject)
+{
+    Q_D(QOpenHarmonyJsObjectPool);
+    d->add(objectType, objectName, jsObject);
+}
+
+QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qopenharmonyjsobjectpool.h b/src/corelib/kernel/qopenharmonyjsobjectpool.h
new file mode 100644
index 0000000000..460a17ecf1
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyjsobjectpool.h
@@ -0,0 +1,39 @@
+#ifndef QOPENHARMONYJSOBJECTPOOL_H
+#define QOPENHARMONYJSOBJECTPOOL_H
+
+#include <napi/native_api.h>
+#include <QtCore/qscopedpointer.h>
+#include <QtCore/qsharedpointer.h>
+#include <QtCore/qvariant.h>
+#include <QtCore/qeventloop.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qopenharmonyjsfunction.h>
+#include <QtCore/qtimer.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObject;
+
+class QOpenHarmonyJsObjectPoolPrivate;
+
+#define qJsObjectPool QOpenHarmonyJsObjectPool::instance()
+
+class QOpenHarmonyJsObjectPool
+{
+    Q_DECLARE_PRIVATE(QOpenHarmonyJsObjectPool)
+public:
+    QOpenHarmonyJsObjectPool();
+    virtual ~QOpenHarmonyJsObjectPool();
+
+    static QOpenHarmonyJsObjectPool *instance();
+
+    bool remove(const QString &name);
+
+    QSharedPointer<QOpenHarmonyJsObject> find(const QString &objectType, const QString &objectName = QString());
+
+    void create(const QString &objectType, const QString &objectName, napi_value jsObject);
+private:
+    QScopedPointer<QOpenHarmonyJsObjectPoolPrivate> d_ptr;
+};
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/corelib/kernel/qopenharmonyload.cpp b/src/corelib/kernel/qopenharmonyload.cpp
new file mode 100644
index 0000000000..e980f4cf8d
--- /dev/null
+++ b/src/corelib/kernel/qopenharmonyload.cpp
@@ -0,0 +1,48 @@
+#include <napi/native_api.h>
+#include <hilog/log.h>
+
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonydefines.h"
+
+/*
+ * function for module exports
+ */
+EXTERN_C_START
+static napi_value Init(napi_env env, napi_value exports)
+{
+    static bool initialized = false;
+    if (initialized)
+        return exports;
+
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("initJsObjectLoader", QOpenHarmonyJsObjectLoader::initJsObjectLoader),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+
+    initialized = true;
+    LOGI("init in qt core");
+    qJs::init(env);
+    return exports;
+}
+EXTERN_C_END
+
+/*
+ * Napi Module define
+ */
+static napi_module openharmonyQtCoreModule = {
+    .nm_version = 1,
+    .nm_flags = 0,
+    .nm_filename = nullptr,
+    .nm_register_func = Init,
+    .nm_modname = "Qt5Core",
+    .nm_priv = ((void*)0),
+    .reserved = { 0 },
+};
+/*
+ * Module register function
+ */
+extern "C" __attribute__((constructor)) void RegisterModule(void)
+{
+    napi_module_register(&openharmonyQtCoreModule);
+}
diff --git a/src/corelib/plugin/qfactoryloader.cpp b/src/corelib/plugin/qfactoryloader.cpp
index 582f48e93e..d9032f61ed 100644
--- a/src/corelib/plugin/qfactoryloader.cpp
+++ b/src/corelib/plugin/qfactoryloader.cpp
@@ -196,10 +196,10 @@ void QFactoryLoader::update()
             continue;
         d->loadedPaths << pluginDir;
 
-#ifdef Q_OS_ANDROID
+#if defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
         QString path = pluginDir;
 #else
-        QString path = pluginDir + d->suffix;
+        QString path = pluginDir + d->suffix;        
 #endif
 
         if (qt_debug_component())
@@ -211,10 +211,10 @@ void QFactoryLoader::update()
         QStringList plugins = QDir(path).entryList(
 #if defined(Q_OS_WIN)
                     QStringList(QStringLiteral("*.dll")),
-#elif defined(Q_OS_ANDROID)
+#elif defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
                     QStringList(QLatin1String("libplugins_%1_*.so").arg(d->suffix)),
 #endif
-                    QDir::Files);
+                    QDir::Files);        
         QLibraryPrivate *library = nullptr;
 
         for (int j = 0; j < plugins.count(); ++j) {
@@ -349,9 +349,9 @@ QFactoryLoader::QFactoryLoader(const char *iid,
 #if QT_CONFIG(library)
     d->cs = cs;
     d->suffix = suffix;
-# ifdef Q_OS_ANDROID
+#if defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
     if (!d->suffix.isEmpty() && d->suffix.at(0) == QLatin1Char('/'))
-        d->suffix.remove(0, 1);
+        d->suffix.remove(0, 1);    
 # endif
 
     QMutexLocker locker(qt_factoryloader_mutex());
diff --git a/src/corelib/text/qlocale_harmony.cpp b/src/corelib/text/qlocale_harmony.cpp
new file mode 100644
index 0000000000..c74e0d4ee5
--- /dev/null
+++ b/src/corelib/text/qlocale_harmony.cpp
@@ -0,0 +1,274 @@
+#include "qlocale_p.h"
+#include "qstringbuilder.h"
+#include "qdatetime.h"
+#include "qstringlist.h"
+#include "qvariant.h"
+#include "qreadwritelock.h"
+
+#include "qopenharmonydefines.h"
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonyjsobjectloader.h"
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_SYSTEMLOCALE
+struct QSystemLocaleData
+{
+    QSystemLocaleData()
+        : lc_numeric(QLocale::C)
+          , lc_time(QLocale::C)
+          , lc_monetary(QLocale::C)
+          , lc_messages(QLocale::C)
+          , m_jsLocale(nullptr)
+    {
+        readEnvironment();
+    }
+
+    void readEnvironment();
+
+    QReadWriteLock lock;
+
+    QLocale lc_numeric;
+    QLocale lc_time;
+    QLocale lc_monetary;
+    QLocale lc_messages;
+    QByteArray lc_messages_var;
+    QByteArray lc_measurement_var;
+    QByteArray lc_collate_var;
+    QStringList uiLanguages;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsLocale;
+};
+
+void QSystemLocaleData::readEnvironment()
+{
+    QWriteLocker locker(&lock);
+    m_jsLocale = qJsObjectLoader->create("JsLocale");
+    QString tmpAll = m_jsLocale->call<QString>("getSystemLocale");
+    QString tmpLanguage = m_jsLocale->call<QString>("getSystemLanguage");
+    QByteArray all = tmpAll.toLocal8Bit();
+    QByteArray language = tmpLanguage.toLocal8Bit();
+
+    QByteArray numeric  = all.isEmpty() ? language : all;
+    QByteArray time     = all.isEmpty() ? language : all;
+    QByteArray monetary = all.isEmpty() ? language : all;
+    lc_messages_var     = all.isEmpty() ? language : all;
+    lc_measurement_var  = all.isEmpty() ? language : all;
+    lc_collate_var      = all.isEmpty() ? language : all;
+    QByteArray lang = language;
+    if (lang.isEmpty())
+        lang = QByteArray("C");
+    if (numeric.isEmpty())
+        numeric = lang;
+    if (time.isEmpty())
+        time = lang;
+    if (monetary.isEmpty())
+        monetary = lang;
+    if (lc_messages_var.isEmpty())
+        lc_messages_var = lang;
+    if (lc_measurement_var.isEmpty())
+        lc_measurement_var = lang;
+    if (lc_collate_var.isEmpty())
+        lc_collate_var = lang;
+    lc_numeric = QLocale(QString::fromLatin1(numeric));
+    lc_time = QLocale(QString::fromLatin1(time));
+    lc_monetary = QLocale(QString::fromLatin1(monetary));
+    lc_messages = QLocale(QString::fromLatin1(lc_messages_var));
+}
+
+Q_GLOBAL_STATIC(QSystemLocaleData, qSystemLocaleData)
+
+#endif
+
+#ifndef QT_NO_SYSTEMLOCALE
+
+static bool contradicts(const QString &maybe, const QString &known)
+{
+    if (maybe.isEmpty())
+        return false;
+
+    /*
+      If \a known (our current best shot at deciding which language to use)
+      provides more information (e.g. script, country) than \a maybe (a
+      candidate to replace \a known) and \a maybe agrees with \a known in what
+      it does provide, we keep \a known; this happens when \a maybe comes from
+      LANGUAGE (usually a simple language code) and LANG includes script and/or
+      country.  A textual comparison won't do because, for example, bn (Bengali)
+      isn't a prefix of ben_IN, but the latter is a refinement of the former.
+      (Meanwhile, bn is a prefix of bnt, Bantu; and a prefix of ben is be,
+      Belarusian.  There are many more such prefixings between two- and
+      three-letter codes.)
+     */
+    QLocale::Language langm, langk;
+    QLocale::Script scriptm, scriptk;
+    QLocale::Country landm, landk;
+    QLocalePrivate::getLangAndCountry(maybe, langm, scriptm, landm);
+    QLocalePrivate::getLangAndCountry(known, langk, scriptk, landk);
+    return (langm != QLocale::AnyLanguage && langm != langk)
+        || (scriptm != QLocale::AnyScript && scriptm != scriptk)
+        || (landm != QLocale::AnyCountry && landm != landk);
+}
+
+QLocale QSystemLocale::fallbackUiLocale() const
+{    
+    QString lang = qSystemLocaleData()->m_jsLocale->call<QString>("getSystemLocale");
+    if (lang.isEmpty())
+        lang = qSystemLocaleData()->m_jsLocale->call<QString>("getSystemLanguage");
+    if (lang.isEmpty())
+        lang = qSystemLocaleData()->m_jsLocale->call<QString>("getSystemRegion");
+    // if the locale is the "C" locale, then we can return the language we found here:
+    if (lang.isEmpty() || lang == QLatin1String("C") || lang == QLatin1String("POSIX"))
+        return QLocale(lang);
+
+
+    QString prefer = qSystemLocaleData()->m_jsLocale->call<QString>("getFirstPreferredLanguage");
+    if (!prefer.isEmpty())
+        return QLocale(prefer);
+
+    return QLocale(QLocale::C);
+#if 0
+    QString language = qSystemLocaleData()->m_jsLocale->call<QString>("getSystemLocale");
+    if (!language.isEmpty()) {
+        language = language.split(QLatin1Char(':')).constFirst();
+        if (contradicts(language, lang))
+            return QLocale(language);
+    }
+    return QLocale(lang);
+#endif
+}
+
+QVariant QSystemLocale::query(QueryType type, QVariant in) const
+{
+    QSystemLocaleData *d = qSystemLocaleData();
+
+    if (type == LocaleChanged) {
+        d->readEnvironment();
+        return QVariant();
+    }
+
+    QReadLocker locker(&d->lock);
+
+    const QLocale &lc_numeric = d->lc_numeric;
+    const QLocale &lc_time = d->lc_time;
+    const QLocale &lc_monetary = d->lc_monetary;
+    const QLocale &lc_messages = d->lc_messages;
+
+    switch (type) {
+    case DecimalPoint:
+        return lc_numeric.decimalPoint();
+    case GroupSeparator:
+        return lc_numeric.groupSeparator();
+    case ZeroDigit:
+        return lc_numeric.zeroDigit();
+    case NegativeSign:
+        return lc_numeric.negativeSign();
+    case DateFormatLong:
+        return lc_time.dateFormat(QLocale::LongFormat);
+    case DateFormatShort:
+        return lc_time.dateFormat(QLocale::ShortFormat);
+    case TimeFormatLong:
+        return lc_time.timeFormat(QLocale::LongFormat);
+    case TimeFormatShort:
+        return lc_time.timeFormat(QLocale::ShortFormat);
+    case DayNameLong:
+        return lc_time.dayName(in.toInt(), QLocale::LongFormat);
+    case DayNameShort:
+        return lc_time.dayName(in.toInt(), QLocale::ShortFormat);
+    case MonthNameLong:
+        return lc_time.monthName(in.toInt(), QLocale::LongFormat);
+    case MonthNameShort:
+        return lc_time.monthName(in.toInt(), QLocale::ShortFormat);
+    case StandaloneMonthNameLong:
+        return lc_time.standaloneMonthName(in.toInt(), QLocale::LongFormat);
+    case StandaloneMonthNameShort:
+        return lc_time.standaloneMonthName(in.toInt(), QLocale::ShortFormat);
+    case DateToStringLong:
+        return lc_time.toString(in.toDate(), QLocale::LongFormat);
+    case DateToStringShort:
+        return lc_time.toString(in.toDate(), QLocale::ShortFormat);
+    case TimeToStringLong:
+        return lc_time.toString(in.toTime(), QLocale::LongFormat);
+    case TimeToStringShort:
+        return lc_time.toString(in.toTime(), QLocale::ShortFormat);
+    case DateTimeFormatLong:
+        return lc_time.dateTimeFormat(QLocale::LongFormat);
+    case DateTimeFormatShort:
+        return lc_time.dateTimeFormat(QLocale::ShortFormat);
+    case DateTimeToStringLong:
+        return lc_time.toString(in.toDateTime(), QLocale::LongFormat);
+    case DateTimeToStringShort:
+        return lc_time.toString(in.toDateTime(), QLocale::ShortFormat);
+    case PositiveSign:
+        return lc_numeric.positiveSign();
+    case AMText:
+        return lc_time.amText();
+    case PMText:
+        return lc_time.pmText();
+    case FirstDayOfWeek:
+        return lc_time.firstDayOfWeek();
+    case CurrencySymbol:
+        return lc_monetary.currencySymbol(QLocale::CurrencySymbolFormat(in.toUInt()));
+    case CurrencyToString: {
+        switch (in.userType()) {
+        case QMetaType::Int:
+            return lc_monetary.toCurrencyString(in.toInt());
+        case QMetaType::UInt:
+            return lc_monetary.toCurrencyString(in.toUInt());
+        case QMetaType::Double:
+            return lc_monetary.toCurrencyString(in.toDouble());
+        case QMetaType::LongLong:
+            return lc_monetary.toCurrencyString(in.toLongLong());
+        case QMetaType::ULongLong:
+            return lc_monetary.toCurrencyString(in.toULongLong());
+        default:
+            break;
+        }
+        return QString();
+    }
+    case MeasurementSystem: {
+        const QString meas_locale = QString::fromLatin1(d->lc_measurement_var);
+        if (meas_locale.compare(QLatin1String("Metric"), Qt::CaseInsensitive) == 0)
+            return QLocale::MetricSystem;
+        if (meas_locale.compare(QLatin1String("Other"), Qt::CaseInsensitive) == 0)
+            return QLocale::MetricSystem;
+        return QVariant((int)QLocale(meas_locale).measurementSystem());
+    }
+    case Collation:
+        return QString::fromLatin1(d->lc_collate_var);
+    case UILanguages: {
+        if (!d->uiLanguages.isEmpty())
+            return d->uiLanguages;
+        QString languages = QString::fromLatin1(qSystemLocaleData()->m_jsLocale->call<QByteArray>("getSystemLocale"));
+        QStringList lst;
+        if (languages.isEmpty())
+            lst.append(QString::fromLatin1(d->lc_messages_var));
+        else
+            lst = languages.split(QLatin1Char(':'));
+
+        for (int i = 0; i < lst.size(); ++i) {
+            const QString &name = lst.at(i);
+            QString lang, script, cntry;
+            if (qt_splitLocaleName(name, lang, script, cntry)) {
+                if (!cntry.length())
+                    d->uiLanguages.append(lang);
+                else
+                    d->uiLanguages.append(lang % QLatin1Char('-') % cntry);
+            }
+        }
+        return d->uiLanguages.isEmpty() ? QVariant() : QVariant(d->uiLanguages);
+    }
+    case StringToStandardQuotation:
+        return lc_messages.quoteString(qvariant_cast<QStringRef>(in));
+    case StringToAlternateQuotation:
+        return lc_messages.quoteString(qvariant_cast<QStringRef>(in), QLocale::AlternateQuotation);
+    case ListToSeparatedString:
+        return lc_messages.createSeparatedList(in.toStringList());
+    case LocaleChanged:
+        Q_ASSERT(false);
+    default:
+        break;
+    }
+    return QVariant();
+}
+#endif // QT_NO_SYSTEMLOCALE
+
+QT_END_NAMESPACE
diff --git a/src/corelib/text/text.pri b/src/corelib/text/text.pri
index d2a02059c7..d565a21c0d 100644
--- a/src/corelib/text/text.pri
+++ b/src/corelib/text/text.pri
@@ -52,7 +52,11 @@ false: SOURCES += $$NO_PCH_SOURCES # Hack for QtCreator
     SOURCES += text/qlocale_mac.mm
 }
 else:unix {
-    SOURCES += text/qlocale_unix.cpp
+    openharmony {
+        SOURCES += text/qlocale_harmony.cpp
+    } else {
+        SOURCES += text/qlocale_unix.cpp
+    }
 }
 else:win32 {
     SOURCES += text/qlocale_win.cpp
diff --git a/src/corelib/thread/qthread_unix.cpp b/src/corelib/thread/qthread_unix.cpp
index a27782d37c..f900b4eb5c 100644
--- a/src/corelib/thread/qthread_unix.cpp
+++ b/src/corelib/thread/qthread_unix.cpp
@@ -302,7 +302,7 @@ void terminate_on_exception(T &&t)
 
 void *QThreadPrivate::start(void *arg)
 {
-#if !defined(Q_OS_ANDROID)
+#if !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
     pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, nullptr);
 #endif
     pthread_cleanup_push(QThreadPrivate::finish, arg);
@@ -343,7 +343,7 @@ void *QThreadPrivate::start(void *arg)
 #endif
 
         emit thr->started(QThread::QPrivateSignal());
-#if !defined(Q_OS_ANDROID)
+#if !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
         pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, nullptr);
         pthread_testcancel();
 #endif
@@ -721,7 +721,7 @@ void QThread::start(Priority priority)
 
 void QThread::terminate()
 {
-#if !defined(Q_OS_ANDROID)
+#if !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
     Q_D(QThread);
     QMutexLocker locker(&d->mutex);
 
@@ -764,7 +764,7 @@ void QThread::setTerminationEnabled(bool enabled)
                "Current thread was not started with QThread.");
 
     Q_UNUSED(thr)
-#if defined(Q_OS_ANDROID)
+#if defined(Q_OS_ANDROID) || defined(Q_OS_OPENHARMONY)
     Q_UNUSED(enabled);
 #else
     pthread_setcancelstate(enabled ? PTHREAD_CANCEL_ENABLE : PTHREAD_CANCEL_DISABLE, nullptr);
diff --git a/src/gui/configure.json b/src/gui/configure.json
index 1f08795c57..af84bac739 100644
--- a/src/gui/configure.json
+++ b/src/gui/configure.json
@@ -1096,6 +1096,17 @@
             "pkg-config-variable": "prefix",
             "value": "/usr",
             "log": "value"
+        },
+        "wheelevent": {
+            "label": "Harmony mouse wheel event",
+            "type": "compile",
+            "test": {
+                "include": "arkui/ui_input_event.h",
+                "main": [
+                    "ArkUI_UIInputEvent *event = nullptr;"
+                ],
+                "qmake": "LIBS += -lace_ndk.z"
+            }
         }
      },
 
@@ -1306,7 +1317,7 @@
             "label": "OpenGL ES 2.0",
             "enable": "input.opengl == 'es2' || input.angle == 'yes'",
             "disable": "input.opengl == 'desktop' || input.opengl == 'dynamic' || input.opengl == 'no'",
-            "condition": "(config.win32 && !features.opengl-dynamic) || (!config.watchos && !features.opengl-desktop && libs.opengl_es2)",
+            "condition": "config.openharmony || (config.win32 && !features.opengl-dynamic) || (!config.watchos && !features.opengl-desktop && libs.opengl_es2)",
             "output": [
                 "publicFeature",
                 "publicQtConfig",
@@ -1316,7 +1327,7 @@
         },
         "opengles3": {
             "label": "OpenGL ES 3.0",
-            "condition": "features.opengles2 && !features.angle && tests.opengles3",
+            "condition": "features.opengles2 && !features.angle",
             "output": [
                 "publicFeature",
                 { "type": "define", "name": "QT_OPENGL_ES_3" }
@@ -1674,6 +1685,7 @@
             "label": "QWheelEvent",
             "purpose": "Supports wheel events.",
             "section": "Kernel",
+            "condition": "config.openharmony && tests.wheelevent || !config.openharmony",
             "output": [ "publicFeature", "feature" ]
         },
         "tabletevent": {
diff --git a/src/gui/configure.pri b/src/gui/configure.pri
index 490ef0df28..537fd3ff69 100644
--- a/src/gui/configure.pri
+++ b/src/gui/configure.pri
@@ -70,6 +70,7 @@ defineTest(qtConfTest_qpaDefaultPlatform) {
     else: integrity: name = integrityfb
     else: haiku: name = haiku
     else: wasm: name = wasm
+    else: openharmony: name = openharmony
     else: name = xcb
 
     $${1}.value = $$name
diff --git a/src/gui/kernel/qscreen.cpp b/src/gui/kernel/qscreen.cpp
index 990272b0c2..b1b539bfb3 100644
--- a/src/gui/kernel/qscreen.cpp
+++ b/src/gui/kernel/qscreen.cpp
@@ -427,7 +427,11 @@ QRect QScreen::geometry() const
 QRect QScreen::availableGeometry() const
 {
     Q_D(const QScreen);
+#ifdef Q_OS_OPENHARMONY
+    return d->platformScreen->availableGeometry();
+#else
     return d->availableGeometry;
+#endif
 }
 
 /*!
diff --git a/src/gui/util/adapter_c.cpp b/src/gui/util/adapter_c.cpp
new file mode 100644
index 0000000000..18e4736b0b
--- /dev/null
+++ b/src/gui/util/adapter_c.cpp
@@ -0,0 +1,895 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2023-2024. All rights reserved.
+
+#include "adapter_c.h"
+#include <hilog/log.h>
+
+static thread_local std::thread::id main_thread_id;
+static napi_env MainEnv = nullptr;
+thread_local napi_ref AddChildNodeCallback = nullptr;
+thread_local napi_ref RemoveChildNodeCallback = nullptr;
+thread_local napi_ref ResizeNodeCallback = nullptr;
+thread_local napi_ref AdjustNodeZOrderCallback = nullptr;
+thread_local napi_ref SetNodeVisibilityCallback = nullptr;
+thread_local napi_ref GetNodeRectCallback = nullptr;
+thread_local napi_ref GetObjectCallback = nullptr;
+thread_local napi_ref ReParentNodeCallback = nullptr;
+thread_local napi_ref RaiseNodeCallback = nullptr;
+thread_local napi_ref LowerNodeCallback = nullptr;
+thread_local napi_ref MoveNodeCallback = nullptr;
+thread_local napi_ref GetRootNodeCallBack = nullptr;
+
+napi_value InitFunc(napi_env env, napi_callback_info info) {
+    size_t argc = 2;
+    napi_value args[2] = {nullptr};
+
+    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
+
+    size_t length = 0;
+    if (napi_ok != napi_get_value_string_utf8(env, args[0], nullptr, 0, &length)) {
+        napi_throw_error(env, "-1003", "napi_get_value_string_utf8 error");
+        return nullptr;
+    }
+
+    if (length == 0) {
+        napi_throw_error(env, "-1004", "the param length invalid");
+        return nullptr;
+    }
+
+    char *funcStrBuffer = new char[length + 1];
+    if (napi_ok != napi_get_value_string_utf8(env, args[0], funcStrBuffer, length + 1, &length)) {
+        delete[] funcStrBuffer;
+        funcStrBuffer = nullptr;
+        napi_throw_error(env, "-1005", "napi_get_value_string_utf8 error");
+        return nullptr;
+    }
+    if (strcmp(funcStrBuffer, "AddChildNode") == 0) {
+        napi_create_reference(env, args[1], 1, &AddChildNodeCallback);
+    } else if (strcmp(funcStrBuffer, "RemoveChildNode") == 0) {
+        napi_create_reference(env, args[1], 1, &RemoveChildNodeCallback);
+    } else if (strcmp(funcStrBuffer, "ResizeNode") == 0) {
+        napi_create_reference(env, args[1], 1, &ResizeNodeCallback);
+    } else if (strcmp(funcStrBuffer, "AdjustNodeZOrder") == 0) {
+        napi_create_reference(env, args[1], 1, &AdjustNodeZOrderCallback);
+    } else if (strcmp(funcStrBuffer, "SetNodeVisibility") == 0) {
+        napi_create_reference(env, args[1], 1, &SetNodeVisibilityCallback);
+    } else if (strcmp(funcStrBuffer, "GetNodeRect") == 0) {
+        napi_create_reference(env, args[1], 1, &GetNodeRectCallback);
+    } else if (strcmp(funcStrBuffer, "GetObject") == 0) {
+        napi_create_reference(env, args[1], 1, &GetObjectCallback);
+    } else if (strcmp(funcStrBuffer, "ReParentNode") == 0) {
+        napi_create_reference(env, args[1], 1, &ReParentNodeCallback);
+    } else if (strcmp(funcStrBuffer, "RaiseNode") == 0) {
+        napi_create_reference(env, args[1], 1, &RaiseNodeCallback);
+    } else if (strcmp(funcStrBuffer, "LowerNode") == 0) {
+        napi_create_reference(env, args[1], 1, &LowerNodeCallback);
+    } else if (strcmp(funcStrBuffer, "MoveNode") == 0) {
+        napi_create_reference(env, args[1], 1, &MoveNodeCallback);
+    } else if (strcmp(funcStrBuffer, "GetRootNode") == 0) {
+        napi_create_reference(env, args[1], 1, &GetRootNodeCallBack);
+    }
+
+    delete[] funcStrBuffer;
+    return nullptr;
+}
+
+napi_ref GetRootNode(int windowId) {
+    napi_ref resultRef = nullptr;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value id;
+        napi_create_int32(MainEnv, windowId, &id);
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, GetRootNodeCallBack, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &id, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call GetRootNode Failed!");
+        }
+        napi_create_reference(MainEnv, result, 1, &resultRef);
+    } else {
+        WorkParam *workParam = new WorkParam{windowId, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value id;
+            napi_create_int32(MainEnv, param->windowId, &id);
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, GetRootNodeCallBack, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &id, &result);
+
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call GetRootNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        if (GetThreadWorkResult(workParam, afterFunc)) {
+            resultRef = workParam->replyParam;
+        }
+        delete workParam;
+    }
+    return resultRef;
+}
+
+void configNode(const NodeParams &nodeParams, napi_value *nodeParamsNapi) {
+    napi_value width;
+    napi_create_string_utf8(MainEnv, nodeParams.width.c_str(), nodeParams.width.length(), &width);
+    napi_value height;
+    napi_create_string_utf8(MainEnv, nodeParams.height.c_str(), nodeParams.height.length(), &height);
+    napi_value x;
+    napi_create_string_utf8(MainEnv, nodeParams.x.c_str(), nodeParams.x.length(), &x);
+    napi_value y;
+    napi_create_string_utf8(MainEnv, nodeParams.y.c_str(), nodeParams.y.length(), &y);
+    napi_value nodeType;
+    napi_create_int32(MainEnv, nodeParams.nodeType, &nodeType);
+
+    napi_value id;
+    napi_create_string_utf8(MainEnv, nodeParams.componentModel->id.c_str(), nodeParams.componentModel->id.length(),
+                            &id);
+    napi_value type;
+    napi_create_int32(MainEnv, nodeParams.componentModel->type, &type);
+    napi_value libraryName;
+    napi_create_string_utf8(MainEnv, nodeParams.componentModel->libraryName.c_str(),
+                            nodeParams.componentModel->libraryName.length(), &libraryName);
+
+    napi_value model;
+    napi_create_object(MainEnv, &model);
+    napi_set_named_property(MainEnv, model, "id", id);
+    napi_set_named_property(MainEnv, model, "type", type);
+    napi_set_named_property(MainEnv, model, "libraryname", libraryName);
+    if (nodeParams.componentModel->onLoad) {
+        napi_value onload;
+        onload = (napi_value)nodeParams.componentModel->onLoad;
+        napi_set_named_property(MainEnv, model, "onLoad", onload);
+    }
+    if (nodeParams.componentModel->onDestroy) {
+        napi_value onDestroy;
+        onDestroy = (napi_value)nodeParams.componentModel->onDestroy;
+        napi_set_named_property(MainEnv, model, "onDestroy", onDestroy);
+    }
+
+    napi_create_object(MainEnv, nodeParamsNapi);
+    napi_set_named_property(MainEnv, *nodeParamsNapi, "width", width);
+    napi_set_named_property(MainEnv, *nodeParamsNapi, "height", height);
+    napi_set_named_property(MainEnv, *nodeParamsNapi, "position_x", x);
+    napi_set_named_property(MainEnv, *nodeParamsNapi, "position_y", y);
+    napi_set_named_property(MainEnv, *nodeParamsNapi, "node_type", nodeType);
+    napi_set_named_property(MainEnv, *nodeParamsNapi, "node_xcomponent", model);
+}
+
+bool GetThreadWorkResult(WorkParam *workParam, uv_after_work_cb uvAfterWork) {
+    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "Adapter_c", "RunCallbackType begin");
+    uv_loop_s *loop = nullptr;
+    napi_get_uv_event_loop(MainEnv, &loop);
+    if (loop == nullptr) {
+        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Failed to get_uv_event_loop");
+        return false;
+    }
+    uv_work_t *work = new uv_work_t;
+    if (work == nullptr) {
+        OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Failed to new uv_work_t");
+        delete workParam;
+        return false;
+    }
+    work->data = (void *)(workParam);
+    uv_work_cb uvWork = [](uv_work_t *work) {};
+    uv_queue_work(loop, work, uvWork, uvAfterWork);
+
+    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "Adapter_c", "childThread lock and wait");
+    std::unique_lock<std::mutex> lock(workParam->lockInfo->mutex);
+    workParam->lockInfo->condition.wait(lock, [&workParam] { return workParam->lockInfo->ready; });
+    OH_LOG_Print(LOG_APP, LOG_INFO, LOG_PRINT_DOMAIN, "Adapter_c", "wait work end");
+
+    delete work;
+    return workParam->replyStatus;
+}
+
+napi_ref AddChildNode(napi_ref nodeRef, NodeParams *nodeParams) {
+    napi_ref resultRef = nullptr;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        // Invoked in the JS main thread.
+        napi_value nodeParamsNapi;
+        configNode(*nodeParams, &nodeParamsNapi);
+        napi_value callback;
+        napi_get_reference_value(MainEnv, AddChildNodeCallback, &callback);
+
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+        // 创建ArkTS function的入参。
+        napi_value args[2];
+        args[0] = node;
+        args[1] = nodeParamsNapi;
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call AddChildNode Failed!");
+        }
+        napi_create_reference(MainEnv, result, 1, &resultRef);
+    } else {
+        // Not invoked in the JS main thread.
+        WorkParam *workParam = new WorkParam(nodeRef, nodeParams, std::make_shared<ThreadLockInfo>());
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value nodeParamsNapi;
+            configNode(*param->nodeParams, &nodeParamsNapi);
+
+            napi_value node;
+            if (napi_ok != napi_get_reference_value(MainEnv, param->nodeRef, &node)) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c",
+                             "AddChildNode napi_get_reference_value Failed!");
+            }
+            // 创建ArkTS function的入参。
+            napi_value args[2];
+            args[0] = node;
+            args[1] = nodeParamsNapi;
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, AddChildNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call AddChildNodeFailed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        if (GetThreadWorkResult(workParam, afterFunc)) {
+            resultRef = workParam->replyParam;
+        }
+
+        delete workParam;
+    }
+    return resultRef;
+}
+
+bool RemoveChildNode(napi_ref nodeChildRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeChildRef, &node);
+
+        napi_value args[1];
+        args[0] = node;
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, RemoveChildNodeCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, args, &result);
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call RemoveChildNodeCallback Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam(nodeChildRef, std::make_shared<ThreadLockInfo>());
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            napi_value args[1];
+            args[0] = node;
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, RemoveChildNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, args, &result);
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call RemoveChildNodeCallback Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool ReleaseNodeRef(napi_ref nodeRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        return napi_delete_reference(MainEnv, nodeRef) == napi_ok;
+    } else {
+        WorkParam *workParam = new WorkParam{nodeRef, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+            
+            param->replyStatus = napi_delete_reference(MainEnv, param->nodeRef) == napi_ok;
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool RaiseNode(napi_ref nodeRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        napi_value args[1];
+        args[0] = node;
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, RaiseNodeCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &node, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call RaiseNode Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam{nodeRef, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            napi_value args[1];
+            args[0] = node;
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, RaiseNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, args, &result);
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call RaiseNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool LowerNode(napi_ref nodeRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, LowerNodeCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &node, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call LowerNode Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam{nodeRef, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, LowerNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &node, &result);
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call LowerNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool ResizeNode(napi_ref nodeRef, std::string width, std::string height) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value callback;
+        napi_value args[3];
+
+        napi_value w;
+        napi_create_string_utf8(MainEnv, width.c_str(), NAPI_AUTO_LENGTH, &w);
+
+        napi_value h;
+        napi_create_string_utf8(MainEnv, height.c_str(), NAPI_AUTO_LENGTH, &h);
+
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        args[0] = node;
+        args[1] = w;
+        args[2] = h;
+
+        napi_get_reference_value(MainEnv, ResizeNodeCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 3, args, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call ResizeNode Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam =
+            new WorkParam(nodeRef, width, height, WorkParam::SIZE_FLAG, std::make_shared<ThreadLockInfo>());
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+            napi_value callback;
+            napi_value args[3];
+
+            napi_value w;
+            napi_create_string_utf8(MainEnv, param->width.c_str(), NAPI_AUTO_LENGTH, &w);
+
+            napi_value h;
+            napi_create_string_utf8(MainEnv, param->height.c_str(), NAPI_AUTO_LENGTH, &h);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            args[0] = node;
+            args[1] = w;
+            args[2] = h;
+
+            napi_get_reference_value(MainEnv, ResizeNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 3, args, &result);
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call ResizeNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool ReParentNode(napi_ref nodeParentNewRef, napi_ref nodeChildRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value nodeParentNew;
+        napi_get_reference_value(MainEnv, nodeParentNewRef, &nodeParentNew);
+
+        napi_value nodeChild;
+        napi_get_reference_value(MainEnv, nodeChildRef, &nodeChild);
+
+        napi_value args[2];
+        args[0] = nodeParentNew;
+        args[1] = nodeChild;
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, ReParentNodeCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call ReParentNode Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam(nodeParentNewRef, nodeChildRef, std::make_shared<ThreadLockInfo>());
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value nodeParentNew;
+            napi_get_reference_value(MainEnv, param->nodeRef, &nodeParentNew);
+
+            napi_value nodeChild;
+            napi_get_reference_value(MainEnv, param->nodeChildRef, &nodeChild);
+
+            napi_value args[2];
+            args[0] = nodeParentNew;
+            args[1] = nodeChild;
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, ReParentNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call ReParentNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool ShowNode(napi_ref nodeRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        napi_value visibility;
+        napi_create_int32(MainEnv, 0, &visibility);
+
+        napi_value args[2];
+        args[0] = node;
+        args[1] = visibility;
+
+        napi_value callback = nullptr;
+        napi_get_reference_value(MainEnv, SetNodeVisibilityCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call ShowNode Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam{nodeRef, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            napi_value visibility;
+            napi_create_int32(MainEnv, 0, &visibility);
+
+            napi_value args[2];
+            args[0] = node;
+            args[1] = visibility;
+
+            napi_value callback = nullptr;
+            napi_get_reference_value(MainEnv, SetNodeVisibilityCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call ShowNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+bool HideNode(napi_ref nodeRef) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        napi_value visibility;
+        napi_create_int32(MainEnv, 1, &visibility);
+
+        napi_value args[2];
+        args[0] = node;
+        args[1] = visibility;
+
+        napi_value callback = nullptr;
+        napi_get_reference_value(MainEnv, SetNodeVisibilityCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call HideNode Failed! %{public}%d",
+                         status);
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam{nodeRef, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            napi_value visibility;
+            napi_create_int32(MainEnv, 1, &visibility);
+
+            napi_value args[2];
+            args[0] = node;
+            args[1] = visibility;
+
+            napi_value callback = nullptr;
+            napi_get_reference_value(MainEnv, SetNodeVisibilityCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 2, args, &result);
+
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call HideNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+napi_ref GetNodeRect(napi_ref nodeRef) {
+    napi_ref resultRef = nullptr;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, GetNodeRectCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &node, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call GetNodeRect Failed!");
+        }
+        napi_create_reference(MainEnv, result, 1, &resultRef);
+    } else {
+        WorkParam *workParam = new WorkParam{nodeRef, std::make_shared<ThreadLockInfo>()};
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, GetNodeRectCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 1, &node, &result);
+
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call GetNodeRect Failed!");
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        if (GetThreadWorkResult(workParam, afterFunc)) {
+            resultRef = workParam->replyParam;
+        }
+        delete workParam;
+    }
+    return resultRef;
+}
+
+napi_ref GetXComponent(napi_ref nodeRef) { return nullptr; }
+
+bool DeleteFunc() {
+    if (AddChildNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, AddChildNodeCallback);
+    if (RemoveChildNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, RemoveChildNodeCallback);
+    if (ResizeNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, ResizeNodeCallback);
+    if (AdjustNodeZOrderCallback != nullptr)
+        napi_delete_reference(MainEnv, AdjustNodeZOrderCallback);
+    if (SetNodeVisibilityCallback != nullptr)
+        napi_delete_reference(MainEnv, SetNodeVisibilityCallback);
+    if (GetNodeRectCallback != nullptr)
+        napi_delete_reference(MainEnv, GetNodeRectCallback);
+    if (GetObjectCallback != nullptr)
+        napi_delete_reference(MainEnv, GetObjectCallback);
+    if (ReParentNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, ReParentNodeCallback);
+    if (RaiseNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, RaiseNodeCallback);
+    if (LowerNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, LowerNodeCallback);
+    if (MoveNodeCallback != nullptr)
+        napi_delete_reference(MainEnv, MoveNodeCallback);
+    if (GetRootNodeCallBack != nullptr)
+        napi_delete_reference(MainEnv, GetRootNodeCallBack);
+
+    return true;
+}
+
+bool MoveNode(napi_ref nodeRef, std::string x, std::string y) {
+    bool res = false;
+    std::thread::id cur_thread_id = std::this_thread::get_id();
+    if (cur_thread_id == main_thread_id) {
+        napi_value args[3];
+
+        napi_value _x;
+        napi_create_string_utf8(MainEnv, x.c_str(), NAPI_AUTO_LENGTH, &_x);
+
+        napi_value _y;
+        napi_create_string_utf8(MainEnv, y.c_str(), NAPI_AUTO_LENGTH, &_y);
+
+        napi_value node;
+        napi_get_reference_value(MainEnv, nodeRef, &node);
+
+        args[0] = node;
+        args[1] = _x;
+        args[2] = _y;
+
+        napi_value callback;
+        napi_get_reference_value(MainEnv, MoveNodeCallback, &callback);
+
+        napi_value result = nullptr;
+        napi_status status = napi_call_function(MainEnv, nullptr, callback, 3, args, &result);
+
+        if (status != napi_ok) {
+            OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call MoveNode Failed!");
+            res = false;
+        } else {
+            res = true;
+        }
+    } else {
+        WorkParam *workParam = new WorkParam(nodeRef, x, y, WorkParam::OFFSET_FLAG, std::make_shared<ThreadLockInfo>());
+        uv_after_work_cb afterFunc = [](uv_work_t *work, int _status) {
+            WorkParam *param = (WorkParam *)(work->data);
+
+            napi_value args[3];
+
+            napi_value _x;
+            napi_create_string_utf8(MainEnv, param->x.c_str(), NAPI_AUTO_LENGTH, &_x);
+
+            napi_value _y;
+            napi_create_string_utf8(MainEnv, param->y.c_str(), NAPI_AUTO_LENGTH, &_y);
+
+            napi_value node;
+            napi_get_reference_value(MainEnv, param->nodeRef, &node);
+
+            args[0] = node;
+            args[1] = _x;
+            args[2] = _y;
+
+            napi_value callback;
+            napi_get_reference_value(MainEnv, MoveNodeCallback, &callback);
+
+            napi_value result = nullptr;
+            napi_status status = napi_call_function(MainEnv, nullptr, callback, 3, args, &result);
+
+            if (status != napi_ok) {
+                OH_LOG_Print(LOG_APP, LOG_ERROR, LOG_PRINT_DOMAIN, "Adapter_c", "Call MoveNode Failed!");
+                param->replyStatus = false;
+            } else {
+                param->replyStatus = true;
+            }
+            napi_create_reference(MainEnv, result, 1, &(param->replyParam));
+
+            std::unique_lock<std::mutex> lock(param->lockInfo->mutex);
+            param->lockInfo->ready = true;
+            param->lockInfo->condition.notify_all();
+        };
+
+        res = GetThreadWorkResult(workParam, afterFunc);
+        delete workParam;
+    }
+    return res;
+}
+
+napi_env GetAdapterEnv() { return MainEnv; }
+
+napi_value AdapterInit(napi_env env, napi_value exports)
+{
+    MainEnv = env;
+    main_thread_id = std::this_thread::get_id();
+    napi_property_descriptor desc[] = {
+        {"initFunc", nullptr, InitFunc, nullptr, nullptr, nullptr, napi_default, nullptr}};
+    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
+    return exports;
+}
diff --git a/src/gui/util/adapter_c.h b/src/gui/util/adapter_c.h
new file mode 100644
index 0000000000..8b3295e2cf
--- /dev/null
+++ b/src/gui/util/adapter_c.h
@@ -0,0 +1,276 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2023-2024. All rights reserved.
+
+#ifndef ADAPTER_C_H
+#define ADAPTER_C_H
+
+#include "napi/native_api.h"
+#include <string.h>
+#include <string>
+#include <thread>
+#include <future>
+#include <uv.h>
+
+const unsigned int LOG_PRINT_DOMAIN = 0xFF00;
+
+/**
+ * NodeType: Node Component Type
+ */
+enum NodeType {
+    XComponent,  // xcomponent
+    UIExtension, // uiextension not support now
+    Container    // notused
+};
+
+/**
+ * XComponentType: The type of XComponent
+ */
+enum XComponentType {
+    SURFACE,
+    COMPONENT,
+    TEXTURE,
+};
+
+/**
+ * XComponent component attribute configuration
+ */
+class XComponentModel {
+public:
+    XComponentModel(std::string id, XComponentType type, std::string libraryName) {
+        this->id = id;
+        this->type = type;
+        this->libraryName = libraryName;
+    }
+
+    std::string id = "";
+    XComponentType type = XComponentType::SURFACE;
+    std::string libraryName = "";
+    void *onLoad = nullptr;    // Not supported
+    void *onDestroy = nullptr; // Not supported
+    bool focusable = true;
+};
+
+/**
+ * Node attribute configuration
+ */
+class NodeParams {
+public:
+    NodeParams(std::string width, std::string height, std::string x, std::string y, NodeType nodeType,
+               XComponentModel *componentModel) {
+        this->width = width;
+        this->height = height;
+        this->x = x;
+        this->y = y;
+        this->nodeType = nodeType;
+        this->componentModel = componentModel;
+    }
+
+    ~NodeParams() {
+        if (componentModel != nullptr) {
+            delete componentModel;
+            componentModel = nullptr;
+        }
+    }
+
+    std::string width = "50%";
+    std::string height = "50%";
+    std::string x = "0";
+    std::string y = "0";
+    XComponentModel *componentModel = nullptr;
+    NodeType nodeType = NodeType::XComponent;
+};
+
+// Defines locks and semaphores.
+using ThreadLockInfo = struct {
+    std::mutex mutex;
+    std::condition_variable condition;
+    bool ready = false;
+};
+
+// Define the parameter structure in the thread.
+struct WorkParam {
+    napi_env env = nullptr;
+    // input parameter
+    int windowId = 0;
+    std::string inParam = "";
+    napi_ref nodeRef = nullptr;
+    napi_ref nodeChildRef = nullptr;
+    NodeParams *nodeParams = nullptr;
+    std::string width = "0";
+    std::string height = "0";
+    std::string x = "0";
+    std::string y = "0";
+    // return
+    napi_ref replyParam = nullptr;
+    bool replyStatus = false;
+    // lock structure
+    std::shared_ptr<ThreadLockInfo> lockInfo;
+
+
+    WorkParam(napi_ref node, NodeParams *nodeParams, std::shared_ptr<ThreadLockInfo> lockInfo) {
+        this->nodeRef = node;
+        this->nodeParams = nodeParams;
+        this->lockInfo = lockInfo;
+    }
+
+    enum flag { SIZE_FLAG, OFFSET_FLAG };
+
+    WorkParam(int windowId, std::shared_ptr<ThreadLockInfo> lockInfo) {
+        this->windowId = windowId;
+        this->lockInfo = lockInfo;
+    }
+
+    /**
+     * WorkParam
+     * @param a width or x
+     * @param b height or y
+     * @param f SIZE or OFFSET
+     */
+    WorkParam(napi_ref nodeRef, std::string a, std::string b, flag f, std::shared_ptr<ThreadLockInfo> lockInfo) {
+        this->nodeRef = nodeRef;
+        if (f != SIZE_FLAG) {
+            this->x = a;
+            this->y = b;
+        } else {
+            this->width = a;
+            this->height = b;
+        }
+        this->lockInfo = lockInfo;
+    }
+
+    WorkParam(napi_ref nodeRef, napi_ref nodeChildRef, std::shared_ptr<ThreadLockInfo> lockInfo) {
+        this->nodeRef = nodeRef;
+        this->nodeChildRef = nodeChildRef;
+        this->lockInfo = lockInfo;
+    }
+
+    WorkParam(napi_ref nodeRef, std::shared_ptr<ThreadLockInfo> lockInfo) {
+        this->nodeRef = nodeRef;
+        this->lockInfo = lockInfo;
+    }
+
+    WorkParam() {}
+};
+
+struct NodeRect {
+    int offsetX = 0;
+    int offsetY = 0;
+    int width = 0;
+    int height = 0;
+};
+
+napi_env GetAdapterEnv();
+
+/**
+ * This interface is invoked by the JS to initialize the interface on the adapter_c side.
+ * @param env: The environment that the API is invoked under.
+ * @param info
+ * @return
+ */
+napi_value InitFunc(napi_env env, napi_callback_info info);
+
+/**
+ * Obtains the root node of a window.
+ * @param windowId: Specifies the ID of the window.
+ * @return
+ */
+napi_ref GetRootNode(int windowId);
+
+/**
+ * Add a child node to the parent node and returns the child node.
+ * @param node: Parent node.
+ * @return Child node.
+ */
+napi_ref AddChildNode(napi_ref nodeRef, NodeParams *nodeParams);
+
+/**
+ * Remove a child node from a parent node.
+ * @param nodeChild: Child node to be removed.
+ * @return An array containing the elements that were deleted.
+ */
+bool RemoveChildNode(napi_ref nodeChildRef);
+
+/**
+ * Place the node at the top layer.
+ * @param node: Indicates the node to be operated
+ * @return null
+ */
+bool RaiseNode(napi_ref nodeRef);
+
+/**
+ * Place the node at the bottom layer.
+ * @param node: Indicates the node to be operated
+ * @return null
+ */
+bool LowerNode(napi_ref nodeRef);
+
+/**
+ * Adjusting the Width and Height of a Node.
+ * @param node: Indicates the node to be operated
+ * @param width
+ * @param height
+ * @return null
+ */
+bool ResizeNode(napi_ref nodeRef, std::string width, std::string height);
+
+/**
+ * Move a child node to another parent node. Cross-window movement is not supported.
+ * @param nodeParentNew: new Parent
+ * @param nodeChild: Node needs to be Moved
+ * @return null
+ */
+bool ReParentNode(napi_ref nodeParentNewRef, napi_ref nodeChildRef);
+
+/**
+ * Modifying the Position of a Node in the Parent Window.
+ * @param node
+ * @param x
+ * @param y
+ * @return null
+ */
+bool MoveNode(napi_ref nodeRef, std::string x, std::string y);
+
+/**
+ * Set Node to visible.
+ * @param node
+ * @return null
+ */
+bool ShowNode(napi_ref nodeRef);
+
+/**
+ * Set the node to invisible.
+ * @param node
+ * @return null
+ */
+bool HideNode(napi_ref nodeRef);
+
+/**
+ * Obtaining the Rect of a Node
+ * @param node
+ * @return {x, y, w, h}
+ */
+napi_ref GetNodeRect(napi_ref nodeRef);
+
+/**
+ * Returns the XComponent object in the specified node.
+ * This object needs to support OH_NativeXComponent_RegisterCallback invoking on the Native side.
+ * @param node
+ * @return OH_NativeXComponent
+ * @todo
+ */
+napi_ref GetXComponent(napi_ref nodeRef);
+
+/**
+ * Release refs
+ * @return
+ */
+bool DeleteFunc();
+
+void configNode(const NodeParams &nodeParams, napi_value *nodeParamsNapi);
+
+bool ReleaseNodeRef(napi_ref nodeRef);
+
+bool GetThreadWorkResult(WorkParam *workParam, uv_after_work_cb uvAfterWork);
+
+napi_value AdapterInit(napi_env env, napi_value exports);
+
+#endif // ADAPTER_C_H
diff --git a/src/gui/util/qopenharmonywindowadapter.cpp b/src/gui/util/qopenharmonywindowadapter.cpp
new file mode 100644
index 0000000000..2cb7aeff90
--- /dev/null
+++ b/src/gui/util/qopenharmonywindowadapter.cpp
@@ -0,0 +1,72 @@
+#include <QDebug>
+#include <adapter_c.h>
+#include <QtCore/qopenharmonydefines.h>
+#include <QtGui/qtguiglobal.h>
+
+#include "qopenharmonywindowadapter.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace QOpenHarmonyWindowAdapter {
+
+bool ReParentNode(WId parent, WId child)
+{
+    napi_ref childNodeRef = reinterpret_cast<napi_ref>(child);
+    napi_ref parentNodeRef = reinterpret_cast<napi_ref>(parent);
+
+    qWarning() << "<-------------reParent node===111";
+    if (nullptr == childNodeRef ||
+        nullptr == parentNodeRef)
+        return false;
+
+    bool result = ::ReParentNode(parentNodeRef, parentNodeRef);
+    qWarning() << "<-------------reParent node===222" << result;
+    return result;
+}
+
+bool AddChildNode(WId parent, NodeParams *nodeParams)
+{
+    napi_ref parentNodeRef = reinterpret_cast<napi_ref>(parent);
+    if (parentNodeRef == nullptr)
+        return false;
+
+    return ::AddChildNode(parentNodeRef, nodeParams) != 0;
+}
+
+}
+QT_END_NAMESPACE
+
+/*
+ * function for module exports
+ */
+EXTERN_C_START
+static napi_value Init(napi_env env, napi_value exports)
+{
+    static bool inited = false;    
+    if (!inited) {
+        AdapterInit(env, exports);
+        inited = true;
+    }
+    return exports;
+}
+EXTERN_C_END
+
+/*
+ * Napi Module define
+ */
+static napi_module Qt5GuiModule = {
+    .nm_version = 1,
+    .nm_flags = 0,
+    .nm_filename = nullptr,
+    .nm_register_func = Init,
+    .nm_modname = "Qt5Gui",
+    .nm_priv = ((void*)0),
+    .reserved = { 0 },
+};
+/*
+ * Module register function
+ */
+extern "C" __attribute__((constructor)) void RegisterModule(void)
+{
+    napi_module_register(&Qt5GuiModule);
+}
diff --git a/src/gui/util/qopenharmonywindowadapter.h b/src/gui/util/qopenharmonywindowadapter.h
new file mode 100644
index 0000000000..32f78e8b4e
--- /dev/null
+++ b/src/gui/util/qopenharmonywindowadapter.h
@@ -0,0 +1,14 @@
+#pragma once
+#include <qwindowdefs.h>
+#include <QtGui/qtguiglobal.h>
+#include "adapter_c.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace QOpenHarmonyWindowAdapter
+{
+    Q_GUI_EXPORT bool AddChildNode(WId parent, NodeParams *nodeParams);
+    Q_GUI_EXPORT bool ReParentNode(WId parent, WId child);
+};
+
+QT_END_NAMESPACE
diff --git a/src/gui/util/util.pri b/src/gui/util/util.pri
index d3402133d6..63c99d7771 100644
--- a/src/gui/util/util.pri
+++ b/src/gui/util/util.pri
@@ -40,6 +40,16 @@ SOURCES += \
         util/qktxhandler.cpp \
         util/qastchandler.cpp
 
+openharmony {
+HEADERS += \
+    util/adapter_c.h \
+    util/qopenharmonywindowadapter.h
+
+SOURCES += \
+    util/adapter_c.cpp \
+    util/qopenharmonywindowadapter.cpp
+}
+
 qtConfig(regularexpression) {
     HEADERS += \
         util/qshadergenerator_p.h
diff --git a/src/network/access/qnetworkaccessfilebackend.cpp b/src/network/access/qnetworkaccessfilebackend.cpp
index 507417f86c..a29678555e 100644
--- a/src/network/access/qnetworkaccessfilebackend.cpp
+++ b/src/network/access/qnetworkaccessfilebackend.cpp
@@ -57,6 +57,9 @@ QStringList QNetworkAccessFileBackendFactory::supportedSchemes() const
             << QStringLiteral("qrc");
 #if defined(Q_OS_ANDROID)
     schemes << QStringLiteral("assets");
+#endif
+#if defined(Q_OS_OPENHARMONY)
+    schemes << QStringLiteral("rawfile");
 #endif
     return schemes;
 }
@@ -80,6 +83,9 @@ QNetworkAccessFileBackendFactory::create(QNetworkAccessManager::Operation op,
     if (url.scheme().compare(QLatin1String("qrc"), Qt::CaseInsensitive) == 0
 #if defined(Q_OS_ANDROID)
             || url.scheme().compare(QLatin1String("assets"), Qt::CaseInsensitive) == 0
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            || url.scheme().compare(QLatin1String("rawfile"), Qt::CaseInsensitive) == 0
 #endif
             || url.isLocalFile()) {
         return new QNetworkAccessFileBackend;
@@ -136,6 +142,11 @@ void QNetworkAccessFileBackend::open()
             if (url.scheme() == QLatin1String("assets"))
                 fileName = QLatin1String("assets:") + url.path();
             else
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            if (url.scheme() == QLatin1String("rawfile"))
+                fileName = QLatin1String("rawfile:") + url.path();
+            else
 #endif
                 fileName = url.toString(QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemoveQuery);
         }
diff --git a/src/network/access/qnetworkaccessmanager.cpp b/src/network/access/qnetworkaccessmanager.cpp
index a10fe9e3fe..7c363279a2 100644
--- a/src/network/access/qnetworkaccessmanager.cpp
+++ b/src/network/access/qnetworkaccessmanager.cpp
@@ -1419,6 +1419,9 @@ QNetworkReply *QNetworkAccessManager::createRequest(QNetworkAccessManager::Opera
         if (isLocalFile
 #ifdef Q_OS_ANDROID
             || scheme == QLatin1String("assets")
+#endif
+#ifdef Q_OS_OPENHARMONY
+            || scheme == QLatin1String("rawfile")
 #endif
             || scheme == QLatin1String("qrc")) {
             return new QNetworkReplyFileImpl(this, req, op);
diff --git a/src/network/access/qnetworkreplyfileimpl.cpp b/src/network/access/qnetworkreplyfileimpl.cpp
index 6e69b4c4d3..ff8ff19361 100644
--- a/src/network/access/qnetworkreplyfileimpl.cpp
+++ b/src/network/access/qnetworkreplyfileimpl.cpp
@@ -110,6 +110,11 @@ QNetworkReplyFileImpl::QNetworkReplyFileImpl(QNetworkAccessManager *manager, con
             if (scheme == QLatin1String("assets"))
                 fileName = QLatin1String("assets:") + url.path();
             else
+#endif
+#if defined(Q_OS_OPENHARMONY)
+                if (scheme == QLatin1String("rawfile"))
+                    fileName = QLatin1String("rawfile:") + url.path();
+                else
 #endif
                 fileName = url.toString(QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemoveQuery);
         }
diff --git a/src/openharmony/entryability/EntryAbility.ets b/src/openharmony/entryability/EntryAbility.ets
new file mode 100644
index 0000000000..d543b3c6fe
--- /dev/null
+++ b/src/openharmony/entryability/EntryAbility.ets
@@ -0,0 +1,54 @@
+import AbilityConstant from '@ohos.app.ability.AbilityConstant';
+import UIAbility from '@ohos.app.ability.UIAbility';
+import Window from '@ohos.window'
+import Want from '@ohos.app.ability.Want';
+import JsApplication from '../native/QtCore/JsApplication'
+import JsDataStore from '../native/QtCore/JsDataStore'
+import JSLogger from '../native/QtCore/JsLogger'
+import window from '@ohos.window'
+
+export default class EntryAbility extends UIAbility {
+  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
+    JsDataStore.setContext(this.context);
+    if (want) {
+      JsDataStore.setElementName({
+        bundleName: want.bundleName,
+        abilityName: want.abilityName,
+        moduleName: want.moduleName
+      });
+    }
+  }
+
+  onDestroy() {
+    JSLogger.info('%{public}s', 'Ability onDestroy');
+    JsApplication.quit();
+  }
+
+  onWindowStageCreate(windowStage: Window.WindowStage) {
+    // Main window is created, set main page for this ability
+    JSLogger.info('%{public}s', 'Ability onWindowStageCreate');
+    JsApplication.run(windowStage, this.launchWant);
+  }
+
+  onWindowStageDestroy() {
+    // Main window is destroyed, release UI related resources
+    JSLogger.info('%{public}s', 'Ability onWindowStageDestroy');
+  }
+
+  onForeground() {
+    // Ability has brought to foreground
+    JSLogger.info('%{public}s', 'Ability onForeground');
+  }
+
+  onBackground() {
+    // Ability has back to background
+    JSLogger.info('%{public}s', 'Ability onBackground');
+  }
+
+  onPrepareToTerminate() {
+    //关闭窗体时通知qt
+    JsDataStore.getQtNativeModule("QPA").handleWindowEvent("openharmony_qt_mainwindow", window.WindowEventType.WINDOW_DESTROYED);
+    //阻止ts程序退出，由qt程序确定是否退出
+    return true;
+  }
+};
diff --git a/src/openharmony/native/QtCore/JsApplication.ets b/src/openharmony/native/QtCore/JsApplication.ets
new file mode 100644
index 0000000000..ab4eec2747
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsApplication.ets
@@ -0,0 +1,194 @@
+import window from '@ohos.window';
+import display from '@ohos.display';
+import process from '@ohos.process';
+import fs, { ReadOptions } from '@ohos.file.fs';
+import util from '@ohos.util';
+import resourceManager from '@ohos.resourceManager';
+import JsDataStore from './JsDataStore';
+import JsLogger from './JsLogger';
+import { JsWindowManager } from './JsWindowManager';
+import JsIndependentWindow from './JsIndependentWindow';
+import JsQtCore from './JsQtCore';
+import JsQtGui from '../QtGui/JsQtGui';
+import Want from '@ohos.app.ability.Want';
+import Font from '@ohos.arkui.UIContext';
+import font from '@ohos.font';
+
+interface Files {
+  files: Array<string>;
+}
+
+class JsApplication {
+  updateQtScreen(): void {
+    let d = display.getDefaultDisplaySync();
+    // let statusBarHeight: number = JsDataStore.statusBarHeight();
+    // let navigationBarHeight: number = JsDataStore.navigationBarHeight();
+    // if (JsDataStore.defaultShowIsMaximized()) {
+    //   JsDataStore.getQtNativeModule("QPA")
+    //     .setDisplayMetrics(d.width, d.height, d.densityDPI, d.scaledDensity, d.xDPI, d.yDPI,
+    //       0, 0, d.width, d.height);
+    // } else {
+    //   JsDataStore.getQtNativeModule("QPA")
+    //     .setDisplayMetrics(d.width, d.height, d.densityDPI, d.scaledDensity, d.xDPI, d.yDPI,
+    //       0, statusBarHeight, d.width, d.height - statusBarHeight - navigationBarHeight);
+    // }
+      JsDataStore.getQtNativeModule("QPA")
+        .setDisplayMetrics(d.width, d.height, d.densityDPI, d.scaledDensity, d.xDPI, d.yDPI,
+          0, 0, d.width, d.height);
+  }
+
+  async run(windowStage: window.WindowStage, want: Want) {
+    this.loadQtModules();
+    let mainWindow = windowStage.getMainWindowSync();
+    if (JsDataStore.defaultShowIsMaximized()) {
+      mainWindow.setWindowLayoutFullScreen(true);
+      mainWindow.setWindowSystemBarEnable([]);
+    }
+    let name = "openharmony_qt_mainwindow";
+    let window = new JsIndependentWindow(name, mainWindow);
+    let localStore = new LocalStorage();
+    let manager = JsDataStore.getJsObjectLoader().createObject("JsWindowManager", "JsWindowManager") as JsWindowManager;
+    manager.addWindow(name, window);
+    localStore.setOrCreate("idName", name);
+    JsDataStore.getJsObjectLoader().addJsObject("JsApplication", this);
+    await windowStage.loadContent('pages/Index', localStore);
+    JsDataStore.getQtNativeModule("QPA").setDeviceType(JsDataStore.deviceType());
+    this.updateQtScreen();
+    JsDataStore.getQtNativeModule("QPA").setTouchPad(await JsDataStore.isTouchPad());
+    JsDataStore.getQtNativeModule("QPA").setDefaultShowIsMaximized(JsDataStore.defaultShowIsMaximized());
+    /* NOTE 获取字体信息 */
+    let mainClass = await windowStage.getMainWindow();
+    let f: Font.Font = mainClass.getUIContext().getFont();
+    let fonts: Array<string> = new Array<string>();
+    for (let _f of f.getSystemFontList()) {
+      let fontInfo: font.FontInfo = font.getFontByName(_f);
+      fonts.push(fontInfo.path);
+    }
+    JsDataStore.getQtNativeModule("QPA").setFontInfos(fonts);
+    JsDataStore.getQtNativeModule("QPA").setJsQuitFunction(() => {
+      JsLogger.info("quit ts application");
+      JsDataStore.getContext().getApplicationContext().killAllProcesses();
+    });
+    JsDataStore.setWindowStage(windowStage);
+    await this.extractFilesToCache();
+    this.loadQtApplication(want);
+  }
+
+  quit() {
+    JsDataStore.getQtNativeModule("QPA").quitQtApplication();
+  }
+
+  formatParams(want: Want, params: string[]): string[] {
+    if (want != undefined && want.uri) {
+      params.push(want.uri)
+    }
+    if (want.parameters) {
+      let keys = Object.keys(want.parameters);
+      keys.forEach(key => {
+        if (want.parameters) {
+          let value: Object = want.parameters[key];
+          if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {
+            if (value.toString().length != 0) {
+              params.push("--" + key);
+              params.push(value.toString());
+            }
+          }
+        }
+      })
+    }
+    return params;
+  }
+
+  loadQtApplication(want: Want) {
+    JsDataStore.getQtNativeModule("QPA").setResourceManager(JsDataStore.getResourceManager());
+    JsDataStore.getQtNativeModule("QPA").setDisplayVersion(JsDataStore.displayVersion());
+    let params: string[] = ["libentry.so"];
+    //todo：默认关闭参数传递
+    // this.formatParams(want, params);
+    let result: boolean =
+      JsDataStore.getQtNativeModule("QPA").startQtApplication(JsDataStore.getApplicationDirs(), params.join("\t"));
+    JsLogger.info("load qt application result: %{public}s", result);
+    if (false == result) {
+      let pro = new process.ProcessManager();
+      pro.exit(0);
+    }
+  }
+
+  private saveFileToCache(file: resourceManager.RawFileDescriptor, des: string) {
+    let paths = des.split("/").slice(0, -1);
+    let dirs = JsDataStore.getApplicationDirs();
+    let temp = dirs.cacheDir + "/";
+    for (let i = 0; i < paths.length; ++i) {
+      temp = temp + paths[i];
+      let result = fs.accessSync(temp);
+      if (!result) {
+        fs.mkdirSync(temp);
+      }
+      temp = temp + "/";
+    }
+
+    let fileName = dirs.cacheDir + "/" + des;
+    // 创建缓存文件(当前是覆盖式创建)
+    let cacheFile = fs.openSync(fileName,
+      fs.OpenMode.WRITE_ONLY | fs.OpenMode.CREATE | fs.OpenMode.TRUNC)
+    let buffer = new ArrayBuffer(4096);
+    let currentOffset = file.offset;
+    let lengthNeedToReed = file.length;
+    let readOption: ReadOptions = {
+      offset: currentOffset,
+      length: lengthNeedToReed > buffer.byteLength ? 4096 : lengthNeedToReed
+    }
+    while (true) {
+      // 读取buffer容量的内容
+      let readLength = fs.readSync(file.fd, buffer, readOption);
+      // 写入buffer容量的内容
+      fs.writeSync(cacheFile.fd, buffer, {
+        length: readLength
+      })
+      // 判断后续内容 修改读文件的参数
+      if (readLength < 4096) {
+        break;
+      }
+      lengthNeedToReed -= readLength;
+      if (readOption.offset != undefined) {
+        readOption.offset += readLength;
+      }
+      if (readOption.length != undefined) {
+        readOption.length = lengthNeedToReed > buffer.byteLength ? 4096 : lengthNeedToReed;
+      }
+    }
+    fs.close(cacheFile);
+  }
+
+  async extractFile(src: string) {
+    try {
+      let R = JsDataStore.getResourceManager();
+      let file: resourceManager.RawFileDescriptor = await R.getRawFd(src);
+      this.saveFileToCache(file, src);
+    } catch (err) {
+      JsLogger.error("extract file failed: %{public}s %{public}s", JSON.stringify(err), src);
+    }
+  }
+
+  async extractFilesToCache() {
+    try {
+      let R = JsDataStore.getResourceManager();
+      let rawContent: Uint8Array = await R.getRawFileContent("qt.json");
+      let textDecoder = util.TextDecoder.create("utf-8", { ignoreBOM: true });
+      let jsonStr = textDecoder.decodeWithStream(rawContent, { stream: false });
+      let files = JSON.parse(jsonStr) as Files;
+      for (let i = 0; i < files.files.length; ++i) {
+        await this.extractFile(files.files[i]);
+      }
+    } catch (err) {
+      JsLogger.error("read file qt.json failed: %{public}s", JSON.stringify(err));
+    }
+  }
+
+  loadQtModules() {
+    JsQtCore.loadQtCore();
+    JsQtGui.loadQtGui();
+  }
+}
+
+export default new JsApplication;
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsCursor.ets b/src/openharmony/native/QtCore/JsCursor.ets
new file mode 100644
index 0000000000..9c5f79e7a3
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsCursor.ets
@@ -0,0 +1,72 @@
+import window from '@ohos.window';
+import pointer from '@ohos.multimodalInput.pointer';
+import image from '@ohos.multimedia.image';
+import { BusinessError } from '@ohos.base';
+import JsDataStore from './JsDataStore';
+import JsIndependentWindow from './JsIndependentWindow';
+import JSLogger from './JsLogger';
+
+export class JsCursor {
+  constructor() {
+  }
+
+  setPointerStyle(pointerStyle: pointer.PointerStyle, windowName: string) {
+    let windowId: number | undefined = this.getWindowId(windowName);
+    if (windowId == undefined || windowId < 0) {
+      JSLogger.info('Invalid windowId');
+      return;
+    }
+    try {
+      pointer.setPointerStyle(windowId, pointerStyle).then(() => {
+        JSLogger.info('Set pointer style success, pointerStyle：%{public}d', pointerStyle as number);
+      });
+    } catch (error) {
+      JSLogger.error("Set pointer style failed, error: %{public}s", JSON.stringify(error));
+    }
+  }
+
+  getWindowId(windowName: string): number | undefined {
+    let win = JsDataStore.getJsObjectLoader().getJsObject(windowName) as JsIndependentWindow;
+    return win == undefined ? undefined : win.getWindowId();
+  }
+
+  setPointerVisible(isVisible: boolean) {
+    try {
+      pointer.setPointerVisible(isVisible, (error: Error) => {
+        if (error) {
+          JSLogger.error("Set pointer visible failed, error: %{public}s", JSON.stringify(error));
+          return;
+        }
+      });
+    } catch (error) {
+      JSLogger.error("Set pointer visible failed, error: %{public}s", JSON.stringify(error));
+    }
+  }
+
+  async setCustomCursorStyle(styleRes: ArrayBuffer, theWidth: number, theHeight: number, focusX: number, focusY: number) {
+    JSLogger.info("setCustomCursorStyle--->theWidth：%{public}d, theHeight：%{public}d, focusX：%{public}d, " +
+      "focusY：%{public}d", theWidth, theHeight, focusX, focusY);
+
+    let decodingOptions: image.DecodingOptions = { desiredSize: { width: theWidth, height: theHeight } };
+    let imageSource: image.ImageSource = image.createImageSource(styleRes);
+    let actualFocusX: number = 0;
+    let actualFocusY: number = 0;
+    //鸿蒙系统自定义光标大小固定为64*64
+    if (theWidth != 0 && theHeight != 0) {
+      actualFocusX = (64 / theWidth) * focusX;
+      actualFocusY = (64 / theHeight) * focusY;
+    }
+    imageSource.createPixelMap(decodingOptions).then((pixelMap) => {
+      window.getLastWindow(getContext(), (_error: BusinessError, win: window.Window) => {
+        let windowId = win.getWindowProperties().id;
+        try {
+          pointer.setCustomCursor(windowId, pixelMap, actualFocusX, actualFocusY).then(() => {
+            JSLogger.info("setCustomCursor success");
+          });
+        } catch (error) {
+          JSLogger.error("setCustomCursor failed, error: %{public}s", JSON.stringify(error));
+        }
+      });
+    });
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsDataStore.ts b/src/openharmony/native/QtCore/JsDataStore.ts
new file mode 100644
index 0000000000..92e154cc93
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsDataStore.ts
@@ -0,0 +1,176 @@
+import common from '@ohos.app.ability.common';
+import window from '@ohos.window';
+import bundleManager from '@ohos.bundle.bundleManager';
+import resourceManager from '@ohos.resourceManager';
+import HashMap from '@ohos.util.HashMap';
+import { JsQtModule } from './JsQtModule';
+import deviceInfo from '@ohos.deviceInfo';
+import inputDevice from '@ohos.multimodalInput.inputDevice';
+import QtJsObjectLoader from './JsObjectLoader';
+import { UIContext } from '@kit.ArkUI';
+import JsLogger from './JsLogger';
+
+interface ApplicationDirs {
+  tempDir: string,
+  filesDir: string,
+  cacheDir: string,
+  databaseDir: string,
+  bundleCodeDir: string,
+  preferencesDir: string,
+  distributedFilesDir: string,
+  qmlDir: string
+}
+
+class JsDataStore {
+  private uicontext: UIContext | null = null;
+  private context: common.UIAbilityContext = null;
+  private windowStage: window.WindowStage;
+  private elementName: bundleManager.ElementName = null;
+  private jsModules: JsQtModule[] = [];
+  private applicationDirs: ApplicationDirs;
+  private qtMajorVersion: number = 0;
+  private qtNativeModules: HashMap<string, any> = new HashMap();
+  private jsObjectLoader: QtJsObjectLoader = new QtJsObjectLoader;
+
+  constructor() {
+  }
+
+  getUiContext(): UIContext | null {
+    return this.uicontext;
+  }
+
+  setUiContext(uicontext: UIContext) {
+    if (null == this.uicontext) {
+      this.uicontext = uicontext;
+    }
+  }
+
+  setContext(context: common.UIAbilityContext) {
+    this.context = context;
+    let appContext = this.context.getApplicationContext();
+    let dirs: ApplicationDirs = {
+      tempDir: appContext.tempDir,
+      filesDir: appContext.filesDir,
+      cacheDir: appContext.cacheDir,
+      databaseDir: appContext.databaseDir,
+      bundleCodeDir: appContext.bundleCodeDir,
+      preferencesDir: appContext.preferencesDir,
+      distributedFilesDir: appContext.distributedFilesDir,
+      qmlDir: appContext.cacheDir + "/Qt/qml"
+    };
+    this.applicationDirs = dirs;
+  }
+
+  getContext(): common.UIAbilityContext {
+    return this.context;
+  }
+
+  getApplicationDirs(): ApplicationDirs {
+    return this.applicationDirs;
+  }
+
+  setElementName(en: bundleManager.ElementName) {
+    this.elementName = en;
+  }
+
+  getElementName(): bundleManager.ElementName {
+    return this.elementName;
+  }
+
+
+  setWindowStage(windowStage: window.WindowStage) {
+    this.windowStage = windowStage;
+  }
+
+  getWindowStage(): window.WindowStage {
+    return this.windowStage;
+  }
+
+  getResourceManager(): resourceManager.ResourceManager {
+    return this.context.resourceManager;
+  }
+
+  addJsModule(module: JsQtModule) {
+    this.jsModules.push(module);
+  }
+
+  getJsModules(): JsQtModule[] {
+    return this.jsModules;
+  }
+
+  getJsObjectLoader(): QtJsObjectLoader {
+    return this.jsObjectLoader;
+  }
+
+  getQtMajorVersion(): number {
+    return this.qtMajorVersion;
+  }
+
+  setQtMajorVersion(version: number) {
+    this.qtMajorVersion = version;
+  }
+
+  addQtNativeModule(name: string, module: any) {
+    this.qtNativeModules.set(name, module);
+  }
+
+  getQtNativeModule(name: string): any {
+    return this.qtNativeModules.get(name);
+  }
+
+  deviceType(): string {
+    // 现目前在pc、pad上模拟成手机端
+    // return 'default';
+    return deviceInfo.deviceType;
+  }
+
+  windowTitleHeight(): number {
+    // Todo read from system
+    return deviceInfo.deviceType == "default" ? 0 : 93;
+  }
+
+  windowBorderWidth(): number {
+    // Todo read from system
+    return deviceInfo.deviceType == "default" ? 0 : 4;
+  }
+
+  statusBarHeight(): number {
+    // Todo read from system
+    return deviceInfo.deviceType == "default" ? 0 : 73;
+  }
+
+  navigationBarHeight(): number {
+    // Todo read from system
+    return deviceInfo.deviceType == "default" ? 0 : 150;
+  }
+
+  displayVersion(): string {
+    return deviceInfo.displayVersion;
+  }
+
+  defaultShowIsMaximized(): boolean {
+    return deviceInfo.deviceType == "default" || deviceInfo.deviceType == "tablet";
+  }
+
+  isDefaultDevice(): boolean {
+    return 'default' == deviceInfo.deviceType;
+  }
+
+  async isTouchPad(): Promise<boolean> {
+    try {
+      let devices = await inputDevice.getDeviceList();
+      for (let i = 0; i < devices.length; ++i) {
+        let deviceInfo = inputDevice.getDeviceInfoSync(devices[i]);
+        if (deviceInfo.sources.includes('touchpad')) {
+          return true;
+        }
+      }
+      return false;
+    } catch (err) {
+      JsLogger.error('Failed to call getDeviceInfoSync. Cause: %{public}s', JSON.stringify(err));
+      return false;
+    }
+  }
+}
+
+export default new JsDataStore;
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsDialog.ts b/src/openharmony/native/QtCore/JsDialog.ts
new file mode 100644
index 0000000000..830c89a6a8
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsDialog.ts
@@ -0,0 +1,179 @@
+import JsLogger from './JsLogger'
+import picker from '@ohos.file.picker'
+import JsDataStore from './JsDataStore'
+import { BusinessError } from '@ohos.base'
+import promptAction from '@ohos.promptAction'
+
+export class JsDialog {
+  constructor() {
+  }
+
+  private getSelectMaxSelectNumber(fileMode: number): number {
+    switch (fileMode) {
+      case 3:
+        return 500;
+      case 1:
+      default:
+        break;
+    }
+    return 1;
+  }
+
+  private getSelectMode(type: number): picker.DocumentSelectMode {
+    switch (type) {
+      case 0:
+      case 1:
+      case 3:
+        break;
+      case 2:
+        return picker.DocumentSelectMode.MIXED;
+      case 4:
+        return picker.DocumentSelectMode.FOLDER;
+      default:
+        break;
+    }
+    return picker.DocumentSelectMode.FILE;
+  }
+
+  messageBox(handler: number, title: string, text: string, buttons: Array<string>): boolean {
+    JsLogger.info("show message box %{public}s %{public}s %{public}d", title, text, buttons.length)
+    let opt: promptAction.ShowDialogOptions = {
+      title: title,
+      message: text,
+      buttons: [{
+        text: "OK",
+        color: "#000000"
+      }]
+    };
+
+    if (buttons != null && buttons.length > 0) {
+      let first: promptAction.Button = {
+        text: buttons[0],
+        color: '#000000',
+      }
+      opt.buttons[0] = first;
+      for (let i = 1; i < buttons.length; i++) {
+        let button: promptAction.Button = {
+          text: buttons[i],
+          color: '#000000',
+        }
+        opt.buttons.push(button)
+      }
+    }
+
+    let mainWindow = JsDataStore.getWindowStage().getMainWindowSync();
+    mainWindow.getUIContext().getPromptAction().showDialog(opt, (err, data) => {
+      if (err) {
+        JsLogger.error("show dialog error: %{public}s", JSON.stringify(err));
+      }
+      if (buttons.length > 0) {
+        let index = err ? -1 : data.index;
+        JsDataStore.getQtNativeModule("QPA").dialogResult(handler, index);
+      }
+    });
+    return true;
+  }
+
+  isVideo(filter: string): boolean {
+    return filter.includes("mp4") || filter.includes("MPEG")
+      || filter.includes("MPG") || filter.includes("DAT")
+      || filter.includes("MOV") || filter.includes("FLV");
+  }
+
+  isAudio(filter: string): boolean {
+    return filter.includes("mp3") || filter.includes("wma") || filter.includes("ogg") || filter.includes("flac")
+      || filter.includes("wv");
+  }
+
+  isImage(filter: string): boolean {
+    return filter.includes("png") || filter.includes("jpeg")
+      || filter.includes("jpg") || filter.includes("bmp")
+  }
+
+  async openFileDialog(handler: number, filter: Array<string>, type: number, dir: string): Promise<boolean> {
+    // let config = {
+    //   action: 'ohos.want.action.OPEN_FILE',
+    //   parameters: {
+    //     startMode: 'choose',
+    //     fileSuffixFilters:"*"
+    //   }
+    // }
+    //
+    // let context = JsDataStore.getContext();
+    //
+    // context.startAbilityForResult(config).then((result) => {
+    //   // 获取到文档文件的uri
+    //   let select_item_list = result.want.parameters.select_item_list;
+    //   JsLogger.info("select file: %{public}s", select_item_list.toString());
+    //   // 有的系统是file://xxx/xxx/xx/xx
+    //   JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, [select_item_list.toString()]);
+    // }).catch((error) => {
+    //   JsLogger.error("open file dialog result %{public}s", JSON.stringify(error));
+    //   JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, []);
+    // });
+    // return true;
+    if (filter.length >= 100 || 0 == filter.length) {
+      filter = ['.*'];
+    }
+    try {
+      let documentPicker = new picker.DocumentViewPicker();
+      let DocumentSelectOptions = new picker.DocumentSelectOptions();
+      DocumentSelectOptions.fileSuffixFilters = filter;
+      DocumentSelectOptions.selectMode = this.getSelectMode(type);
+      DocumentSelectOptions.maxSelectNumber = this.getSelectMaxSelectNumber(type);
+      DocumentSelectOptions.defaultFilePathUri = 'file://docs' + dir;
+      documentPicker.select(DocumentSelectOptions).then((DocumentSelectResult: Array<string>) => {
+        JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, DocumentSelectResult)
+        JsLogger.info('DocumentViewPicker.select successfully, DocumentSelectResult uri: ' +
+        JSON.stringify(DocumentSelectResult));
+      }).catch((err: BusinessError) => {
+        JsLogger.error('DocumentViewPicker.select failed with err: ' + JSON.stringify(err));
+      });
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, []);
+      JsLogger.error('DocumentViewPicker failed with err: ' + JSON.stringify(err));
+    }
+    return true;
+  }
+
+  async saveFileDialog(handler: number, fileName: string, filter: Array<string>): Promise<boolean> {
+    // let config = {
+    //   action: 'ohos.want.action.CREATE_FILE',
+    //   parameters: {
+    //     startMode: 'save',
+    //     key_pick_file_name: [fileName],
+    //     saveFile: fileName,
+    //   }
+    // }
+    //
+    // try {
+    //   let context = JsDataStore.getContext()
+    //   let result = await context.startAbilityForResult(config);
+    //   JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, [result.want?.parameters?.pick_path_return.toString()]);
+    // } catch (error) {
+    //   JsLogger.info("startAbilityForResult Promise.Reject is called, error.code = %{public}s", error.code)
+    //   JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, []);
+    // }
+    // return true;
+
+    try {
+      let DocumentSaveOptions = new picker.DocumentSaveOptions();
+      DocumentSaveOptions.fileSuffixChoices = filter;
+      DocumentSaveOptions.defaultFilePathUri = fileName;
+      let documentPicker = new picker.DocumentViewPicker();
+      documentPicker.save(DocumentSaveOptions).then((DocumentSaveResult: Array<string>) => {
+        JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, DocumentSaveResult);
+        console.info('DocumentViewPicker.save successfully, DocumentSaveResult uri: ' +
+        JSON.stringify(DocumentSaveResult));
+      }).catch((err: BusinessError) => {
+        JsLogger.error('DocumentViewPicker.save failed with err: ' + JSON.stringify(err));
+      });
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      JsDataStore.getQtNativeModule("QPA").selectedFilesResult(handler, []);
+      JsLogger.error('DocumentViewPicker failed with err: ' + JSON.stringify(err));
+    }
+    return true;
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsEmbeddedWindow.ets b/src/openharmony/native/QtCore/JsEmbeddedWindow.ets
new file mode 100644
index 0000000000..a124d8c561
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsEmbeddedWindow.ets
@@ -0,0 +1,92 @@
+import JsWindow from './JsWindow'
+import { ViewNodeController, NodeParams, XComponentModel, NodeType, addChildNode, removeChildNode, raiseNode, lowerNode } from 'adapter_ts'
+import JsLogger from './JsLogger';
+import window from '@ohos.window';
+
+export default class JsEmbeddedWindow extends JsWindow {
+
+  private jsWindowParent : JsWindow | undefined = undefined;
+
+  constructor(name: string, jsWindowParent: JsWindow, xComponentNodeController: ViewNodeController) {
+    super(name, xComponentNodeController)
+    this.jsWindowParent = jsWindowParent;
+  }
+
+  async setGeometry(x: number, y: number, w: number, h: number): Promise<boolean> {
+    JsLogger.info('set embedded window geometry: %{public}s %{public}d %{public}d %{public}d %{public}d', this.name, x, y, w, h)
+    this.rect = {left: x, top: y, width: w, height: h};
+    // await this.xComponentController?.setGeometry(x, y, w, h);
+    let params = this.xComponentController?.getParams();
+    if (params != undefined) {
+      params.position_x = x;
+      params.position_y = y;
+      params.width = w;
+      params.height = h;
+      this.jsWindowParent?.getXComponentController()?.update();
+    }
+    return true;
+  }
+
+  getGeometry() : window.Rect | undefined {
+    return this.rect;
+  }
+
+
+  async destroyWindow() : Promise<boolean> {
+    if (this.xComponentController == undefined)
+      return false;
+    let parent: ViewNodeController | null = this.xComponentController.getParent();
+    if (parent) {
+      removeChildNode(parent);
+    }
+    return true;
+  }
+
+  async setVisible(visible: boolean): Promise<boolean> {
+    if (this.xComponentController == undefined)
+      return false;
+    if (visible) {
+      this.xComponentController.getParams().visibility = Visibility.Visible;
+    } else {
+      this.xComponentController.getParams().visibility = Visibility.Hidden;
+    }
+    return false;
+  }
+
+  async hideWindow() : Promise<void>  {
+    await this.setVisible(false);
+  }
+
+  raise(): boolean {
+    if (this.xComponentController == undefined)
+      return false;
+    raiseNode(this.xComponentController);
+    return true;
+  }
+
+  lower(): boolean {
+    if (this.xComponentController == undefined)
+      return false;
+    lowerNode(this.xComponentController);
+    return true;
+  }
+
+  getUIContext(): UIContext | undefined {
+    return this.jsWindowParent?.getUIContext();
+  }
+
+  createSubWindow(name: string): JsWindow | undefined{
+    JsLogger.info("create embedded window for %{public}s", name);
+    let curModel = new XComponentModel(name, XComponentType.SURFACE, "plugins_platforms_qopenharmony");
+    let param = new NodeParams(0, 0, '50%', '50%', NodeType.XComponent, curModel);
+    param.visibility = Visibility.Visible;
+    param.border_width = 0;
+    let childXComponent: ViewNodeController = addChildNode(this.xComponentController as ViewNodeController, param);
+    let window = new JsEmbeddedWindow(name, this, childXComponent);
+    return window;
+  }
+
+  isVisible(): boolean {
+    return this.xComponentController?.getParams().visibility == Visibility.Visible;
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsFile.ts b/src/openharmony/native/QtCore/JsFile.ts
new file mode 100644
index 0000000000..f6d3f710fa
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsFile.ts
@@ -0,0 +1,143 @@
+import fs from '@ohos.file.fs';
+import JSLogger from './JsLogger'
+
+export class JsFile {
+  private uri: string = '';
+  private file: fs.File = null;
+  private valid: boolean = false;
+  private offset: number = 0;
+  private opened: boolean = false;
+
+  constructor(uriString: string) {
+    this.setFile(uriString)
+  }
+
+  setFile(uri: string): boolean {
+    let u = uri.replace("datashare://", "file:");
+    this.uri = u;
+    return true;
+  }
+
+  open(mode: number): boolean {
+    try {
+      JSLogger.info("open file: %{public}s %{public}d", this.uri, mode)
+      this.file = fs.openSync(this.uri, mode);
+      this.valid = true;
+      this.opened = true;
+    } catch (error) {
+      JSLogger.error("file open: %{public}s", JSON.stringify(error));
+      this.valid = false;
+    } finally {
+      return this.valid;
+    }
+  }
+
+  isExists(): boolean {
+    return fs.accessSync(this.uri);
+  }
+
+  isFile(): boolean {
+    try {
+      return fs.lstatSync(this.uri).isFile();
+    } catch (e) {
+      JSLogger.warn("fs.lstatSync failed:" + JSON.stringify(e));
+    }
+  }
+
+  isLink(): boolean {
+    try {
+      return fs.lstatSync(this.uri).isSymbolicLink();
+    } catch (e) {
+      JSLogger.warn("fs.lstatSync failed:" + JSON.stringify(e));
+    }
+  }
+
+  isDirectory(): boolean {
+    let p = this.uri.replace("file:/", "");
+    try {
+      return fs.lstatSync(p).isDirectory();
+    } catch (e) {
+      JSLogger.warn("fs.lstatSync failed:" + JSON.stringify(e));
+    }
+  }
+
+  write(buffer: ArrayBuffer): number {
+    try {
+      return fs.writeSync(this.file.fd, buffer);
+    } catch (error) {
+      JSLogger.error("file write: %{public}s", JSON.stringify(error));
+      return -1;
+    }
+  }
+
+  seek(offset: number): boolean {
+    this.offset = offset;
+    return true;
+  }
+
+  pos(): number {
+    return this.offset;
+  }
+
+  size(): number {
+    if (false == this.opened) {
+      this.open(fs.OpenMode.READ_ONLY)
+    }
+
+    return fs.statSync(this.file.fd).size;
+  }
+
+  flush(): boolean {
+    return true;
+  }
+
+  read(length: number): ArrayBuffer {
+    try {
+      let buf = new ArrayBuffer(length);
+      let options = { "offset": this.offset, "length": length }
+      let result = fs.readSync(this.file.fd, buf, options);
+      if (0 != result) {
+        this.offset = Math.min(this.offset + result, this.size());
+        return buf;
+      } else {
+        return null;
+      }
+
+    } catch (error) {
+      JSLogger.error("file read error: %{public}s", JSON.stringify(error));
+      return null;
+    }
+  }
+
+  close(): boolean {
+    if (this.valid) {
+      try {
+        fs.closeSync(this.file);
+        this.opened = false;
+      } catch (error) {
+        JSLogger.error("file close %{public}s", JSON.stringify(error));
+      } finally {
+        this.valid = false;
+        return true;
+      }
+    } else {
+      return true;
+    }
+  }
+
+  rename(oldPath: string, newPath: string): boolean {
+    if (this.opened) {
+      this.close();
+    }
+
+    let ok = false;
+    try {
+      fs.renameSync(oldPath, newPath);
+      ok = true;
+    } catch (error) {
+      ok = false;
+      JSLogger.error("file rename %{public}s", JSON.stringify(error));
+    }
+    return ok;
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsIndependentWindow.ets b/src/openharmony/native/QtCore/JsIndependentWindow.ets
new file mode 100644
index 0000000000..9649912462
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsIndependentWindow.ets
@@ -0,0 +1,251 @@
+import window from '@ohos.window'
+import JsLogger from './JsLogger'
+import JsDataStore from './JsDataStore'
+import JsWindow from './JsWindow';
+import { Margins } from './JsWindow';
+import { ViewNodeController, NodeParams, XComponentModel, NodeType, addChildNode } from 'adapter_ts'
+import JsEmbeddedWindow from './JsEmbeddedWindow'
+import display from '@ohos.display';
+
+export default class JsIndependentWindow extends JsWindow {
+  private jsWindow: window.Window | undefined = undefined;
+  private fullScreen: boolean = false;
+  private maximized: boolean = false;
+  private hasFrame: boolean = true;
+
+  constructor(name: string, jsWindow: window.Window) {
+    super(name)
+    this.jsWindow = jsWindow;
+  }
+
+  async startListener(): Promise<boolean> {
+    this.jsWindow?.on("windowSizeChange", (size) => {
+      let p = this.jsWindow?.getWindowProperties();
+      if (p == undefined)
+        return;
+      let d = display.getDefaultDisplaySync();
+      this.fullScreen = (p.drawableRect.width == d.width && p.drawableRect.height == d.height)
+      if (p.windowRect.left != this.rect.left || p.windowRect.top != this.rect.top) {
+        // 此次只有当坐标发生改变之后才传递到Qt中
+        JsLogger.info("%{public}s window size changed %{public}s", this.name, JSON.stringify(p));
+        JsDataStore.getQtNativeModule("QPA")?.handleGeometryChange(this.name, p.windowRect);
+      }
+    });
+    this.jsWindow?.on("windowEvent", (type) => {
+      JsDataStore.getQtNativeModule("QPA").handleWindowEvent(this.name, type);
+      if (type == window.WindowEventType.WINDOW_DESTROYED) {
+        this.jsWindow = undefined
+      }
+    })
+    if (!JsDataStore.isDefaultDevice()){
+      this.jsWindow?.on("windowStatusChange", (type) => {
+        if (type == window.WindowStatusType.FULL_SCREEN && this.hasFrame)
+          this.maximized = true;
+        if (type == window.WindowStatusType.FLOATING)
+          this.maximized = false;
+        JsDataStore.getQtNativeModule("QPA").handleWindowStatusEvent(this.name, type);
+      })
+    }
+    return true;
+  }
+
+  handleWindowStatusEvent(type: window.WindowStatusType): void {
+
+  }
+
+  isFullScreen(): boolean {
+    // let p = this.jsWindow?.getWindowProperties();
+    // return p == undefined ? false : p.isLayoutFullScreen;
+    return this.fullScreen;
+  }
+
+  getGeometry(): window.Rect | undefined {
+    let p = this.jsWindow?.getWindowProperties();
+    return p?.windowRect;
+  }
+
+  getMargins() : Margins {
+    if (JsDataStore.isDefaultDevice() || JsDataStore.defaultShowIsMaximized()) {
+      return {left: 0, top: 0, right: 0, bottom: 0 };
+    }
+    let m : Margins = {left: 6, top: 47, right: 6, bottom: 6 };
+    if (this.jsWindow == undefined)
+      return m;
+    // let top = vp2px(this.jsWindow.getWindowDecorHeight());
+    // m.top = top;
+    // let p = this.jsWindow.getWindowProperties();
+    // m.left = p.drawableRect.left;
+    // m.top = p.drawableRect.top;
+    // // m.right = p.windowRect.width - p.drawableRect.width - m.left;
+    // // m.bottom = p.windowRect.height - p.drawableRect.height - m.top;
+    // m.right = m.left;
+    // m.bottom = m.left;
+    if (this.maximized) {
+      m.left = 0;
+      m.right = 0;
+      m.bottom = 0;
+    }
+    if (!this.hasFrame || this.fullScreen) {
+      m.left = 0;
+      m.right = 0;
+      m.bottom = 0;
+      m.top = 0;
+    }
+    // console.log("hhhhhhhhhhhhhhhhhhhhhhhhh", this.jsWindow.isWindowShowing(), JSON.stringify(p));
+    return m;
+  }
+
+  async setGeometry(x: number, y: number, w: number, h: number): Promise<boolean> {
+    JsLogger.info('set window geometry: %{public}s %{public}d %{public}d %{public}d %{public}d', this.name, x, y, w, h)
+    try {
+      if (this.jsWindow != undefined) {
+        await this.jsWindow.moveWindowTo(x, y);
+        await this.jsWindow.resize(w, h);
+        this.rect = {
+          'width': w, 'height': h, 'left': x, 'top': y
+        }
+      }
+      return true;
+    } catch (exception) {
+      JsLogger.error('Failed to call setGeometry for the Window %{public}s. Cause: %{public}s', this.name, JSON.stringify(exception));
+      return false;
+    }
+  }
+
+  async destroyWindow(): Promise<boolean> {
+    try {
+      await this.jsWindow?.destroyWindow();
+      return true;
+    } catch (exception) {
+      JsLogger.error('Failed to call destroyWindow for the Window %{public}s. Cause: %{public}s', this.name, JSON.stringify(exception));
+      return false;
+    }
+  }
+
+  async setVisible(visible: boolean): Promise<boolean> {
+    JsLogger.info("set window visible: %{public}s %{public}s", this.name, visible);
+    try {
+      if (this.jsWindow != undefined) {
+        if (visible) {
+          await this.jsWindow.showWindow();
+          // await this.jsWindow.moveWindowTo(this.rect.left, this.rect.top);
+          // await this.jsWindow.resize(this.rect.width, this.rect.height);
+        } else {
+          await this.hideWindow();
+        }
+      }
+      return true;
+    } catch (exception) {
+      JsLogger.error('Failed to call showWindow for the Window. Cause: %{public}s', JSON.stringify(exception));
+      return false;
+    }
+  }
+
+  raise(): boolean {
+    return true;
+  }
+
+  lower(): boolean {
+    return true;
+  }
+
+  async hideWindow(): Promise<void> {
+    /* TODO OpenHarmony 没有隐藏接口 */
+    if (JsDataStore.isDefaultDevice()) {
+      let d = display.getDefaultDisplaySync();
+      await this.jsWindow?.moveWindowTo(d.width + 50, d.height + 50);
+    } else {
+      await this.jsWindow?.minimize();
+    }
+  }
+
+  async load(): Promise<void> {
+    let store = new LocalStorage();
+    store.setOrCreate("idName", this.name);
+    await this.jsWindow?.loadContent('pages/Index', store);
+  }
+
+  public getName(): string {
+    return this.name;
+  }
+
+  getUIContext(): UIContext | undefined {
+    return this.jsWindow?.getUIContext();
+  }
+
+  createSubWindow(name: string): JsWindow | undefined {
+    JsLogger.info("create embedded window for %{public}s", name);
+    let curModel = new XComponentModel(name, XComponentType.SURFACE, "plugins_platforms_qopenharmony");
+    let param = new NodeParams(0, 0, '100%', '100%', NodeType.XComponent, curModel);
+    param.visibility = Visibility.Visible;
+    param.border_width = 0;
+    let childXComponent: ViewNodeController = addChildNode(this.xComponentController as ViewNodeController, param);
+    let window = new JsEmbeddedWindow(name, this, childXComponent);
+    return window;
+  }
+
+  getWindowId(): number | undefined {
+    return this.jsWindow?.getWindowProperties().id;
+  }
+
+  isVisible(): boolean {
+    if (this.jsWindow == undefined)
+      return false;
+    return this.jsWindow.isWindowShowing();
+  }
+
+  async showMaximized(): Promise<boolean> {
+    if (this.jsWindow == undefined)
+      return false;
+    if (JsDataStore.defaultShowIsMaximized()) {
+      let d = display.getDefaultDisplaySync();
+      await this.setGeometry(0, 0, d.width, d.height);
+    } else {
+      await this.jsWindow.setWindowLayoutFullScreen(false);
+      await this.jsWindow.setWindowSystemBarEnable([]);
+    }
+    this.fullScreen = false;
+    this.maximized = true;
+    return true;
+  }
+
+  async showFullScreen(): Promise<boolean> {
+    if (this.jsWindow == undefined)
+      return false;
+    await this.jsWindow.setWindowLayoutFullScreen(true);
+    await this.jsWindow.setWindowSystemBarEnable([]);
+    this.fullScreen = true;
+    this.maximized = false;
+    return true;
+  }
+
+  async showMinimized(): Promise<boolean> {
+    if (this.jsWindow == undefined)
+      return false;
+    await this.jsWindow.minimize();
+    this.fullScreen = false;
+    this.maximized = false;
+    return true;
+  }
+
+  async showNormal(): Promise<boolean> {
+    if (this.jsWindow == undefined)
+      return false;
+    await this.jsWindow.showWindow();
+    this.fullScreen = false;
+    this.maximized = false;
+    return true;
+  }
+
+  setHasFrame(hasFrame: boolean): void {
+    this.hasFrame = hasFrame;
+  }
+
+  setWindowLimits(limits: window.WindowLimits): boolean {
+    if (this.jsWindow == undefined)
+      return true;
+    this.jsWindow.setWindowLimits(limits);
+    return true;
+  }
+
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsInputMethod.ts b/src/openharmony/native/QtCore/JsInputMethod.ts
new file mode 100644
index 0000000000..47a9327d56
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsInputMethod.ts
@@ -0,0 +1,287 @@
+import JsDataStore from './JsDataStore'
+import { BusinessError } from '@ohos.base';
+import inputMethod from '@ohos.inputMethod';
+import inputMethodEngine from '@ohos.inputMethodEngine';
+
+export class JsInputMethod {
+  private handler: number = 0;
+  private visable: boolean = false; /* 记录输入法visible状态 */
+  private attached: boolean = false;
+  private inputMethodController: inputMethod.InputMethodController = inputMethod.getController();
+
+  public constructor() {
+  }
+
+  private subscribe() {
+    try {
+      this.inputMethodController.on('insertText', (text: string) => {
+        console.info('Succeeded in getting callback1 data: ' + JSON.stringify(text));
+        JsDataStore.getQtNativeModule("QPA").insertText(this.handler, text);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe insertText: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('sendFunctionKey', (functionKey: inputMethod.FunctionKey) => {
+        JsDataStore.getQtNativeModule("QPA").sendEnterKey(this.handler);
+        console.warn(`Succeeded in subscribing sendFunctionKey, functionKey.enterKeyType: ${functionKey.enterKeyType}`);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe sendFunctionKey: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('sendKeyboardStatus', (keyboardStatus: inputMethod.KeyboardStatus) => {
+        console.info(`Succeeded in subscribing sendKeyboardStatus, keyboardStatus: ${keyboardStatus}`);
+        switch (keyboardStatus) {
+          case inputMethod.KeyboardStatus.HIDE:
+            this.visable = false;
+            this.detach();
+            break;
+          case inputMethod.KeyboardStatus.SHOW:
+            this.visable = true;
+            break;
+          default:
+            break;
+        }
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe sendKeyboardStatus: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('deleteLeft', (length: number) => {
+        console.log(`Succeeded in subscribing deleteLeft, length: ${length}`);
+        JsDataStore.getQtNativeModule("QPA").deleteLeft(this.handler, length);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe deleteLeft: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('deleteRight', (length: number) => {
+        console.log(`Succeeded in subscribing deleteRight, length: ${length}`);
+        JsDataStore.getQtNativeModule("QPA").deleteRight(this.handler, length);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe deleteRight: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('moveCursor', (direction: inputMethod.Direction) => {
+        console.log(`Succeeded in subscribing moveCursor, direction: ${direction}`);
+        JsDataStore.getQtNativeModule("QPA").moveCursor(this.handler, direction);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe moveCursor: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('handleExtendAction', (action: inputMethod.ExtendAction) => {
+        console.log(`Succeeded in subscribing handleExtendAction, action: ${action}`);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe handleExtendAction: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('selectByRange', (range: inputMethod.Range) => {
+        console.log(`Succeeded in subscribing selectByRange: start: ${range.start} , end: ${range.end}`);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe selectByRange: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('selectByMovement', (movement: inputMethod.Movement) => {
+        console.log('Succeeded in subscribing selectByMovement: direction: ' + movement.direction);
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe selectByMovement: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('getLeftTextOfCursor', (length: number) => {
+        console.info(`Succeeded in subscribing getLeftTextOfCursor, length: ${length}`);
+        let text: string = "";
+        return text;
+      });
+    } catch (err) {
+      console.error(`Failed to unsubscribing getLeftTextOfCursor. err: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('getRightTextOfCursor', (length: number) => {
+        console.info(`Succeeded in subscribing getRightTextOfCursor, length: ${length}`);
+        let text: string = "";
+        return text;
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe getRightTextOfCursor. err: ${JSON.stringify(err)}`);
+    }
+
+    try {
+      this.inputMethodController.on('getTextIndexAtCursor', () => {
+        console.info(`Succeeded in subscribing getTextIndexAtCursor.`);
+        let index: number = 0;
+        return index;
+      });
+    } catch (err) {
+      console.error(`Failed to subscribe getTextIndexAtCursor. err: ${JSON.stringify(err)}`);
+    }
+  }
+
+  private unsubscribe() {
+    this.inputMethodController.off('moveCursor');
+    this.inputMethodController.off('insertText');
+    this.inputMethodController.off('deleteLeft');
+    this.inputMethodController.off('deleteRight');
+    this.inputMethodController.off('selectByRange');
+    this.inputMethodController.off('sendFunctionKey');
+    this.inputMethodController.off('selectByMovement');
+    this.inputMethodController.off('sendKeyboardStatus');
+    this.inputMethodController.off('handleExtendAction');
+    this.inputMethodController.off('getLeftTextOfCursor');
+    this.inputMethodController.off('getRightTextOfCursor');
+    this.inputMethodController.off('getTextIndexAtCursor');
+  }
+
+  isInputPanelVisible(): boolean {
+    return this.visable;
+  }
+
+  isAttached() {
+    return this.attached;
+  }
+
+  async attach(handler: number, inputType: number, enterType: number): Promise<boolean> {
+    if (this.attached) {
+      return true;
+    }
+
+    if (0 == handler) {
+      console.error("handle number is error");
+      return false;
+    }
+
+    this.handler = handler;
+    try {
+      let textConfig: inputMethod.TextConfig = {
+        inputAttribute: {
+          textInputType: inputType,
+          enterKeyType: enterType
+        }
+      };
+      await this.inputMethodController.attach(true, textConfig).then(() => {
+        this.subscribe();
+        this.attached = true;
+        console.log('Succeeded in attaching inputMethod.');
+      }).catch((err) => {
+        this.attached = false;
+        console.error(`Failed to attach: ${JSON.stringify(err)}`);
+      })
+    } catch (err) {
+      this.attached = false;
+      console.error(`Failed to attach: ${JSON.stringify(err)}`);
+    }
+    return this.attached;
+  }
+
+  async detach(): Promise<boolean> {
+    this.unsubscribe();
+    await this.inputMethodController.detach().then(() => {
+      this.attached = false;
+      console.log('Succeeded in detaching inputMethod.');
+    }).catch((err) => {
+      this.attached = true;
+      console.error(`Failed to detach: ${JSON.stringify(err)}`);
+    });
+    return !this.attached;
+  }
+
+  showTextInput() {
+    this.inputMethodController.showTextInput().then(() => {
+      console.log('Succeeded in showing text input.');
+    }).catch((err) => {
+      console.error(`Failed to showTextInput: ${JSON.stringify(err)}`);
+    });
+  }
+
+  hideTextInput() {
+    this.inputMethodController.hideTextInput().then(() => {
+      console.log('Succeeded in hiding inputMethod.');
+    }).catch((err) => {
+      console.error(`Failed to hideTextInput: ${JSON.stringify(err)}`);
+    });
+  }
+
+  setCallingWindow(windowId: number) {
+    try {
+      this.inputMethodController.setCallingWindow(windowId).then(() => {
+        console.log('Succeeded in setting callingWindow.');
+      }).catch((err) => {
+        console.error(`Failed to setCallingWindow: ${JSON.stringify(err)}`);
+      })
+    } catch (err) {
+      console.error(`Failed to setCallingWindow: ${JSON.stringify(err)}`);
+    }
+  }
+
+  updateCursor(left: number, top: number, width: number, height: number) {
+    try {
+      let cursorInfo: inputMethod.CursorInfo = { left: left, top: top, width: width, height: height };
+      this.inputMethodController.updateCursor(cursorInfo).then(() => {
+        console.log('Succeeded in updating cursorInfo.');
+      }).catch((err) => {
+        console.error(`Failed to updateCursor: ${JSON.stringify(err)}`);
+      })
+    } catch (err) {
+      console.error(`Failed to updateCursor: ${JSON.stringify(err)}`);
+    }
+  }
+
+  changeSelection(text: string, start: number, end: number) {
+    try {
+      this.inputMethodController.changeSelection(text, start, end).then(() => {
+        console.log('Succeeded in changing selection.');
+      }).catch((err) => {
+        console.error(`Failed to changeSelection: ${JSON.stringify(err)}`);
+      })
+    } catch (err) {
+      console.error(`Failed to changeSelection: ${JSON.stringify(err)}`);
+    }
+  }
+
+  stopInputSession() {
+    try {
+      this.inputMethodController.stopInputSession().then((result: boolean) => {
+        if (result) {
+          console.log('Succeeded in stopping inputSession.');
+        } else {
+          console.error('Failed to stopInputSession.');
+        }
+      }).catch((err) => {
+        console.error(`Failed to stopInputSession: ${JSON.stringify(err)}`);
+      })
+    } catch (err) {
+      console.error(`Failed to stopInputSession: ${JSON.stringify(err)}`);
+    }
+  }
+
+  showSoftKeyboard() {
+    this.inputMethodController.showSoftKeyboard().then(() => {
+      console.log('Succeeded in showing softKeyboard.');
+    }).catch((err: BusinessError) => {
+      console.error(`Failed to show softKeyboard: ${JSON.stringify(err)}`);
+    });
+  }
+
+  hideSoftKeyboard() {
+    this.inputMethodController.hideSoftKeyboard().then(() => {
+      console.log('Succeeded in hiding softKeyboard.');
+    }).catch((err: BusinessError) => {
+      console.error(`Failed to hide softKeyboard: ${JSON.stringify(err)}`);
+    });
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsLocale.ets b/src/openharmony/native/QtCore/JsLocale.ets
new file mode 100644
index 0000000000..681c589323
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsLocale.ets
@@ -0,0 +1,69 @@
+import I18n from '@ohos.i18n';
+import JsLogger from './JsLogger';
+import { BusinessError } from '@ohos.base';
+
+export class JsLocale {
+  constructor() {
+  }
+
+  /* 获取系统支持的语言列表 */
+  getSystemLanguages(): Array<string> {
+    let systemLanguages: Array<string> = new Array<string>();
+    try {
+      systemLanguages = I18n.System.getSystemLanguages();
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      JsLogger.error(`call System.getSystemLanguages failed, error code: ${err.code}, message: ${err.message}.`);
+    }
+    return systemLanguages;
+  }
+
+  /* 获取系统语言 */
+  getSystemLanguage(): string {
+    let systemLanguage: string = '';
+    try {
+      systemLanguage = I18n.System.getSystemLanguage();
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      console.error(`call System.getSystemLanguage failed, error code: ${err.code}, message: ${err.message}.`);
+    }
+    return systemLanguage;
+  }
+
+  /* 获取系统地区 */
+  getSystemRegion(): string {
+    let systemRegion: string = '';
+    try {
+      systemRegion = I18n.System.getSystemRegion(); // 获取系统当前地区设置
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      console.error(`call System.getSystemRegion failed, error code: ${err.code}, message: ${err.message}.`);
+    }
+    return systemRegion;
+  }
+
+  /* 获取系统区域 */
+  getSystemLocale(): string {
+    let systemLocale: string = '';
+    try {
+      systemLocale = I18n.System.getSystemLocale(); // 获取系统当前Locale
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      console.error(`call System.getSystemLocale failed, error code: ${err.code}, message: ${err.message}.`);
+    }
+    return systemLocale;
+  }
+
+  /* 获取系统偏好语言列表中的第一个偏好语言 */
+  getFirstPreferredLanguage(): string {
+    let firstPreferredLanguage: string = '';
+    try {
+      firstPreferredLanguage = I18n.System.getFirstPreferredLanguage(); // 获取系统当前偏好语言列表中的第一个偏好语言
+    } catch (error) {
+      let err: BusinessError = error as BusinessError;
+      console.error(`call System.getFirstPreferredLanguage failed, error code: ${err.code}, message: ${err.message}.`);
+    }
+    return firstPreferredLanguage;
+  }
+}
+
diff --git a/src/openharmony/native/QtCore/JsLogger.ts b/src/openharmony/native/QtCore/JsLogger.ts
new file mode 100644
index 0000000000..328a60c965
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsLogger.ts
@@ -0,0 +1,38 @@
+import hilog from '@ohos.hilog';
+
+export class JsLogger {
+  private domain: number;
+  private tag: string;
+
+  constructor(tag: string) {
+    this.tag = tag;
+    this.domain = 0xFF00;
+  }
+
+  debug(format: string, ...args: any[]): void {
+    hilog.debug(this.domain, this.tag, format, args);
+  }
+
+  info(format: string, ...args: any[]): void {
+    hilog.info(this.domain, this.tag, format, args);
+  }
+
+  warn(format: string, ...args: any[]): void {
+    hilog.warn(this.domain, this.tag, format, args);
+  }
+
+  error(format: string, ...args: any[]): void {
+    hilog.error(this.domain, this.tag, format, args);
+  }
+
+  fatal(format: string, ...args: any[]): void {
+    hilog.fatal(this.domain, this.tag, format, args);
+  }
+
+  isLoggable(level: number): void {
+    hilog.isLoggable(this.domain, this.tag, level);
+  }
+}
+
+export default new JsLogger('QtForHarmony');
+
diff --git a/src/openharmony/native/QtCore/JsNodeParam.ets b/src/openharmony/native/QtCore/JsNodeParam.ets
new file mode 100644
index 0000000000..8947462ec4
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsNodeParam.ets
@@ -0,0 +1,28 @@
+import { JsXComponentNodeController } from './JsXCompoentNodeController'
+
+export enum NodeType {
+    XComponent,         // xcomponent
+    UIExtension,        // uiextension not support now
+    Container           // notused
+}
+
+export class JsNodeParam {
+    public width: Length = '50%';
+    public height: Length = '50%';
+    public x: Length = '20%';             // X-coordinate of the offset relative to the upper left corner of the parent component
+    public y: Length = '20%';             // Y-coordinate of the offset relative to the upper left corner of the parent component
+    public type: NodeType = NodeType.XComponent; // Component type used in a node.
+    public visibility: Visibility = Visibility.Hidden;
+    public id: string;
+    public children: Array<JsXComponentNodeController> = [];
+
+    constructor(id: string, visibility?: Visibility, x?: Length, y?: Length, w?: Length, h?: Length, type?: NodeType) {
+        this.id = id;
+        if (type != undefined) this.type = type;
+        if (w != undefined) this.width = w;
+        if (h != undefined) this.height = h;
+        if (x != undefined) this.x = x;
+        if (y != undefined) this.y = y;
+        if (visibility != undefined) this.visibility = visibility;
+    }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsObjectLoader.ts b/src/openharmony/native/QtCore/JsObjectLoader.ts
new file mode 100644
index 0000000000..3a900b07ae
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsObjectLoader.ts
@@ -0,0 +1,52 @@
+import JsDataStore from './JsDataStore'
+import { JsQtModule } from './JsQtModule'
+import HashMap from '@ohos.util.HashMap';
+
+export default class QtJsObjectLoader {
+
+  jsObjects: HashMap<string, Object> = new HashMap();
+
+  constructor() {
+
+  }
+
+  createObject<Args extends Object[]>(type: string, name: string, ...args: Args): Object {
+    let modules = JsDataStore.getJsModules();
+    let module: JsQtModule = null;
+    for (let i = 0; i < modules.length; ++i) {
+      if (modules[i].hasJsObjectType(type)) {
+        module = modules[i];
+        break;
+      }
+    }
+
+    if (module == null) {
+      return null;
+    }
+
+    let obj = module.createJsObject(type, name, ...args);
+    this.addJsObject(name, obj);
+    return obj;
+  }
+
+  hasJsObject(name: string) : boolean {
+    return this.jsObjects.hasKey(name);
+  }
+
+  addJsObject(name: string, obj: Object) : void {
+    this.jsObjects.set(name, obj);
+  }
+
+  getJsObject(name: string): Object {
+    if (this.jsObjects.hasKey(name))
+      return this.jsObjects.get(name);
+    return undefined;
+  }
+
+  deleteJsObject(name: string): boolean {
+    if (!this.jsObjects.hasKey(name))
+      return false;
+    this.jsObjects.remove(name);
+    return true;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsPasteBoard.ts b/src/openharmony/native/QtCore/JsPasteBoard.ts
new file mode 100644
index 0000000000..5399ab139a
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsPasteBoard.ts
@@ -0,0 +1,226 @@
+import pasteboard from '@ohos.pasteboard';
+import JsDataStore from './JsDataStore'
+import image from '@ohos.multimedia.image';
+import JsLogger from './JsLogger'
+
+interface OpenHarmonyPixMap {
+    w: number;
+    h: number;
+    buffer?: ArrayBuffer;
+}
+
+export class JsPasteBoard {
+
+    constructor() {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        systemPasteboard.on('update', () => {
+            JsDataStore.getQtNativeModule("QPA").pasteChanged();
+        });
+    }
+
+    async hasData() : Promise<boolean> {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        let result = await systemPasteboard.hasData()
+        return result;
+    }
+
+    async hasType(type: string): Promise<boolean> {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        let data = await systemPasteboard.getData();
+        let result = data.hasType(type);
+        JsLogger.info("clipboard has type %{public}s: %{public}s", type, result);
+        return result;
+    }
+
+    async hasClipboardText() : Promise<boolean> {
+        let result = await this.hasData();
+        if (result) {
+            return await this.hasType(pasteboard.MIMETYPE_TEXT_PLAIN);
+        }
+        return false;
+    }
+
+    async hasClipboardHtml() : Promise<boolean> {
+        let result = await this.hasData();
+        if (result) {
+            return await this.hasType(pasteboard.MIMETYPE_TEXT_HTML);
+        }
+        return false;
+    }
+
+    async hasClipboardUri() : Promise<boolean> {
+        let result = await this.hasData();
+        if (result) {
+            return await this.hasType(pasteboard.MIMETYPE_TEXT_URI);
+        }
+        return false;
+    }
+
+    async hasClipboardPixelMap():  Promise<boolean> {
+        let result = await this.hasData();
+        if (result) {
+            return await this.hasType(pasteboard.MIMETYPE_PIXELMAP);
+        }
+        return false;
+    }
+
+    async clipboardText() : Promise<string> {
+        try {
+            let systemPasteboard = pasteboard.getSystemPasteboard();
+            let pasteData = await systemPasteboard.getData();
+            return pasteData.getPrimaryText();
+        } catch (e) {
+            JsLogger.error("get clipboard text failed: %{public}s", JSON.stringify(e));
+            return "";
+        }
+    }
+
+    async clipboardHtml() : Promise<string> {
+        try {
+            let systemPasteboard = pasteboard.getSystemPasteboard();
+            let pasteData = await systemPasteboard.getData();
+            return pasteData.getPrimaryHtml();
+        } catch (e) {
+            JsLogger.error("get clipboard text failed: %{public}s", JSON.stringify(e));
+            return "";
+        }
+    }
+
+    async clipboardUri() : Promise<string[]> {
+        try {
+            let systemPasteboard = pasteboard.getSystemPasteboard();
+            let pasteData = await systemPasteboard.getData();
+            let result: string[] = []
+            for (let i = 0; i < pasteData.getRecordCount(); ++i) {
+                let r = pasteData.getRecord(i);
+                if (r.mimeType == pasteboard.MIMETYPE_TEXT_URI)
+                    result.push(r.uri);
+            }
+            return result;
+        } catch (e) {
+            JsLogger.error("get clipboard text failed: %{public}s", JSON.stringify(e));
+            return [];
+        }
+    }
+
+    async clipboardPixelMap(): Promise<OpenHarmonyPixMap> {
+        let result: OpenHarmonyPixMap = { w: 0, h: 0 }
+        try {
+            let systemPasteboard = pasteboard.getSystemPasteboard();
+            let pasteData = await systemPasteboard.getData();
+            let map: image.PixelMap = pasteData.getPrimaryPixelMap();
+            if (map == undefined)
+                return result;
+            let length: number = map.getPixelBytesNumber();
+            if (length == 0)
+                return result;
+            let info: image.ImageInfo = await map.getImageInfo();
+            result.w = info.size.width;
+            result.h = info.size.height;
+            let buffer: ArrayBuffer = new ArrayBuffer(length);
+            await map.readPixelsToBuffer(buffer);
+            result.buffer = buffer;
+        } catch (e) {
+            JsLogger.error("get clipboard text failed: %{public}s", JSON.stringify(e));
+        }
+        return result;
+    }
+    
+    async setClipboardText(text: string) : Promise<boolean> {
+        JsLogger.info('set clipboard text %{public}s', text);
+        try {
+            let has = await this.hasData();
+            if (has) {
+                let pasteData = pasteboard.createRecord(pasteboard.MIMETYPE_TEXT_PLAIN, text);
+                this.updatePasteData(pasteData);
+            } else {
+                let pasteData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text);
+                await this.setPasteData(pasteData);
+            }
+            return true;
+        } catch (e) {
+            JsLogger.info('set clipboard text failed', JSON.stringify(e));
+            return false;
+        }
+    }
+
+    async setClipboardHtml(html: string): Promise<boolean> {
+        JsLogger.info('set clipboard html %{public}s', html);
+        try {
+            let has = await this.hasData();
+            if (has) {
+                let pasteData = pasteboard.createRecord(pasteboard.MIMETYPE_TEXT_HTML, html);
+                this.updatePasteData(pasteData);
+            } else {
+                var pasteData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_HTML, html);
+                await this.setPasteData(pasteData);
+            }
+            return true;
+        } catch (e) {
+            JsLogger.info('set clipboard html failed', JSON.stringify(e));
+            return false;
+        }
+    }
+
+    async setClipboardUri(uri: string): Promise<boolean> {
+        JsLogger.info('set clipboard uri %{public}s', uri);
+        try {
+            let has = await this.hasData();
+            if (has) {
+                let pasteData = pasteboard.createRecord(pasteboard.MIMETYPE_TEXT_URI, uri);
+                this.updatePasteData(pasteData);
+            } else {
+                var pasteData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_URI, uri);
+                await this.setPasteData(pasteData);
+            }
+            return true;
+        } catch (e) {
+            JsLogger.info('set clipboard uri failed', JSON.stringify(e));
+            return false;
+        }
+    }
+    
+    async setClipboardPixelMap(buffer: ArrayBuffer, width: number, height: number): Promise<boolean> {
+        JsLogger.info('set clipboard pixmap %{public}d %{public}d %{public}d', buffer.byteLength, width, height);
+        try {
+            let opt: image.InitializationOptions = {
+                size: { height: height, width: width },
+                pixelFormat: image.PixelMapFormat.RGBA_8888,
+                editable: false,
+                alphaType: image.AlphaType.UNPREMUL
+            };
+
+            let has = await this.hasData();
+            let pixelMap: image.PixelMap = await image.createPixelMap(buffer, opt);
+            if (has) {
+                let pasteData = pasteboard.createRecord(pasteboard.MIMETYPE_PIXELMAP, pixelMap);
+                this.updatePasteData(pasteData);
+            } else {
+                var pasteData = pasteboard.createData(pasteboard.MIMETYPE_PIXELMAP, pixelMap);
+                await this.setPasteData(pasteData);
+            }
+            return true;
+        } catch (e) {
+            JsLogger.info('set clipboard pixmap failed', JSON.stringify(e));
+            return false;
+        }
+  }
+
+    async setPasteData(data: pasteboard.PasteData): Promise<void> {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        await systemPasteboard.setData(data);
+    }
+
+    updatePasteData(r: pasteboard.PasteDataRecord) : void {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        let pastedData = systemPasteboard.getDataSync();
+        pastedData.addRecord(r);
+        systemPasteboard.setData(pastedData);
+    }
+
+    async clearData(): Promise<boolean> {
+        let systemPasteboard = pasteboard.getSystemPasteboard();
+        await systemPasteboard.clearData();
+        return true;
+    }
+}
diff --git a/src/openharmony/native/QtCore/JsQtCore.ets b/src/openharmony/native/QtCore/JsQtCore.ets
new file mode 100644
index 0000000000..00cee25d78
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsQtCore.ets
@@ -0,0 +1,41 @@
+import { JsQtModule } from './JsQtModule'
+import JsDataStore from './JsDataStore'
+import JsLogger from './JsLogger';
+import JsQtPlatform from './JsQtPlatform'
+
+interface QtCore {
+  default: Object;
+}
+
+function createJsObject<Args extends Object[]>(type: string, name: string, ...args: Args) {
+  if (JsDataStore.getJsObjectLoader().hasJsObject(name))
+    return JsDataStore.getJsObjectLoader().getJsObject(name)
+  return JsDataStore.getJsObjectLoader().createObject(type, name, args);
+}
+
+export class JsQtCore extends JsQtModule {
+
+  public constructor() {
+    super();
+  }
+  async loadQtCore() : Promise<void> {
+    JsQtPlatform.load();
+    let qtMajorVersion: number = JsDataStore.getQtNativeModule("QPA").qtMajorVersion();
+    // let name = "libQt" + qtMajorVersion + "Core.so";  import(name)加载失败
+    let qtCore: QtCore | undefined = undefined;
+    if (qtMajorVersion == 5)
+      qtCore = await import("libQt5Core.so");
+    else if (qtMajorVersion == 6)
+      qtCore = await import("libQt6Core.so");
+    if (qtCore == undefined) {
+      JsLogger.fatal("Cannot load QtCore module");
+      return;
+    }
+    JsDataStore.setQtMajorVersion(qtMajorVersion);
+    JsDataStore.addQtNativeModule("QtCore", qtCore.default);
+    JsDataStore.getQtNativeModule("QtCore").initJsObjectLoader(createJsObject, (name: string)=>{
+      return JsDataStore.getJsObjectLoader().deleteJsObject(name);
+    });
+  }
+}
+export default new JsQtCore;
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsQtModule.ts b/src/openharmony/native/QtCore/JsQtModule.ts
new file mode 100644
index 0000000000..2fb540cb9e
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsQtModule.ts
@@ -0,0 +1,36 @@
+import JsDataStore  from './JsDataStore'
+import { HashMap } from '@kit.ArkTS';
+
+export class ObjectBuilder<Args extends Object[]> {
+  builder: (...args: Args) => Object;
+  constructor(builder: (...args: Args) => Object) {
+    this.builder = builder;
+  }
+}
+
+
+export class JsQtModule {
+  moduleJsObjects: HashMap<string, Object> = new HashMap();
+
+  constructor() {
+    JsDataStore.addJsModule(this);
+  }
+
+  hasJsObjectType(type: string): boolean {
+    if (this.moduleJsObjects == undefined)
+      return false;
+    return this.moduleJsObjects.hasKey(type);
+  }
+
+  createJsObjectImpl(type: string, ...args: any[]): Object | undefined {
+    if (this.moduleJsObjects == undefined)
+      return undefined;
+    let c = this.moduleJsObjects.get(type);
+    return (c as ObjectBuilder<Object[]>)?.builder(...args);
+  }
+
+  createJsObject(type: string, name: string, ...args: any[]): Object {
+    let obj = this.createJsObjectImpl(type, ...args);
+    return obj;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsQtPlatform.ets b/src/openharmony/native/QtCore/JsQtPlatform.ets
new file mode 100644
index 0000000000..f9bcc8b727
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsQtPlatform.ets
@@ -0,0 +1,52 @@
+import { JsFile } from './JsFile'
+import { JsDialog } from './JsDialog'
+import { JsCursor } from './JsCursor'
+import { JsLocale } from './JsLocale'
+import JsDataStore from './JsDataStore';
+import { JsPasteBoard } from './JsPasteBoard'
+import { JsInputMethod } from './JsInputMethod'
+import { JsWindowManager } from './JsWindowManager'
+import { JsStandardPaths } from './JsStandardPaths'
+import { JsServices } from './JsServices'
+import qpa from 'libplugins_platforms_qopenharmony.so'
+import { JsQtModule, ObjectBuilder } from './JsQtModule'
+
+class JsQtPlatform extends JsQtModule {
+  public constructor() {
+    super();
+    this.moduleJsObjects.set("JsDialog", new ObjectBuilder<[]>(() => {
+      return new JsDialog();
+    }));
+    this.moduleJsObjects.set("JsPasteBoard", new ObjectBuilder<[]>(() => {
+      return new JsPasteBoard();
+    }));
+    this.moduleJsObjects.set("JsWindowManager", new ObjectBuilder<[]>(() => {
+      return new JsWindowManager();
+    }));
+    this.moduleJsObjects.set("JsFile", new ObjectBuilder<[Object]>((uri: Object) => {
+      return new JsFile(uri.toString());
+    }));
+    this.moduleJsObjects.set("JsServices", new ObjectBuilder<[Object]>(() =>{
+      return new JsServices();
+    }));
+    this.moduleJsObjects.set("JsStandardPaths", new ObjectBuilder<[]>(() => {
+      return new JsStandardPaths();
+    }));
+    this.moduleJsObjects.set("JsInputMethod", new ObjectBuilder<[]>(() => {
+      return new JsInputMethod();
+    }));
+    this.moduleJsObjects.set("JsCursor", new ObjectBuilder<[]>(() => {
+      return new JsCursor();
+    }));
+    this.moduleJsObjects.set("JsLocale", new ObjectBuilder<[]>(() => {
+      return new JsLocale();
+    }));
+    JsDataStore.addQtNativeModule("QPA", qpa);
+  }
+
+  load(): void {
+
+  }
+}
+
+export default new JsQtPlatform;
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsServices.ts b/src/openharmony/native/QtCore/JsServices.ts
new file mode 100644
index 0000000000..04723b542b
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsServices.ts
@@ -0,0 +1,26 @@
+import JSLogger from './JsLogger'
+import common from '@ohos.app.ability.common';
+import Want from '@ohos.app.ability.Want';
+import { BusinessError } from '@ohos.base';
+import JsDataStore from './JsDataStore';
+
+
+export class JsServices {
+  constructor() {}
+
+  async openUrl(inUri: string): Promise<boolean> {
+    let wantInfo: Want = {
+      action: 'ohos.want.action.viewData',
+      entities: ['entity.system.browsable'],
+      uri: inUri
+    }
+    let context: common.UIAbilityContext = JsDataStore.getContext();
+    await context.startAbility(wantInfo).then(() => {
+      JSLogger.info("open url：%{public}s success!!!!", inUri)
+    }).catch((err: BusinessError) => {
+      JSLogger.error("open url：%{public}s error!!!!", inUri)
+      return false;
+    })
+    return true;
+  }
+}
\ No newline at end of file
diff --git a/src/openharmony/native/QtCore/JsStandardPaths.ts b/src/openharmony/native/QtCore/JsStandardPaths.ts
new file mode 100644
index 0000000000..33a20962b0
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsStandardPaths.ts
@@ -0,0 +1,34 @@
+import JsDataStore from './JsDataStore'
+import environment from '@ohos.file.environment';
+
+export class JsStandardPaths {
+
+  path(type: string) {
+    if (type == "DIRECTORY_DOWNLOADS") {
+      return environment.getUserDownloadDir();
+    } else if (type == "DIRECTORY_DOCUMENTS") {
+      return environment.getUserDocumentDir();
+    } else if (type == "DIRECTORY_DESKTOP") {
+      return environment.getUserDesktopDir();
+    } else if (type == "DIRECTORY_CACHE") {
+      let dirs = JsDataStore.getApplicationDirs();
+      return dirs.cacheDir;
+    } else if (type == "DIRECTORY_TEMP") {
+      let dirs = JsDataStore.getApplicationDirs();
+      return dirs.tempDir;
+    } else if (type == "DIRECTORY_BUNDLE") {
+      let dirs = JsDataStore.getApplicationDirs();
+      return dirs.bundleCodeDir;
+    } else if (type == "DIRECTORY_FILES") {
+      let dirs = JsDataStore.getApplicationDirs();
+      return dirs.filesDir;
+    } else if (type == "DIRECTORY_MUSIC") {
+
+    } else if (type == "DIRECTORY_MOVIES") {
+
+    } else if (type == "DIRECTORY_PICTURES") {
+
+    }
+    return "";
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsWindow.ets b/src/openharmony/native/QtCore/JsWindow.ets
new file mode 100644
index 0000000000..90cd9b4c66
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsWindow.ets
@@ -0,0 +1,99 @@
+import window from '@ohos.window'
+import { ViewNodeController } from 'adapter_ts'
+
+export interface Margins {
+    bottom : number;
+    left : number;
+    right : number;
+    top : number;
+}
+
+export default class JsWindow {
+    name: string;
+    rect: window.Rect = {left: 0, top: 0, width: 200, height: 200};
+    id: number = 0;
+    xComponentController?: ViewNodeController;
+
+    constructor(name: string, xComponentController?: ViewNodeController) {
+        this.name = name;
+        if (xComponentController != undefined)
+            this.xComponentController = xComponentController;
+    }
+
+    setXComponentController(xComponentController: ViewNodeController): void {
+        this.xComponentController = xComponentController;
+    }
+
+    getXComponentController() : ViewNodeController | undefined {
+        return this.xComponentController;
+    }
+
+    async setGeometry(x: number, y: number, w: number, h: number): Promise<boolean> {
+        return false;
+    }
+
+    async destroyWindow() : Promise<boolean> {
+        return false;
+    }
+
+    async setVisible(visible: boolean): Promise<boolean> {
+        return false;
+    }
+
+    async hideWindow() : Promise<void>  {
+
+    }
+
+    createSubWindow(name: string): JsWindow | undefined{
+        return undefined;
+    }
+
+    getMargins() : Margins {
+        let m : Margins = {left: 0, top: 0, right: 0, bottom: 0 };
+        return m;
+    }
+
+    getUIContext() : UIContext | undefined {
+        return undefined
+    }
+
+    public getName(): string {
+        return this.name;
+    }
+
+    getId(): number {
+        return this.id;
+    }
+
+    setId(id: number): void {
+        this.id = id;
+    }
+
+    raise(): boolean {
+        return true;
+    }
+
+    lower(): boolean {
+        return true;
+    }
+
+    isVisible(): boolean {
+        return false;
+    }
+
+    async showFullScreen(): Promise<boolean> {
+        return false;
+    }
+
+    async showMaximized(): Promise<boolean> {
+        return false;
+    }
+
+    async showMinimized(): Promise<boolean> {
+        return false;
+    }
+
+    async showNormal(): Promise<boolean> {
+        return false;
+    }
+}
diff --git a/src/openharmony/native/QtCore/JsWindowManager.ets b/src/openharmony/native/QtCore/JsWindowManager.ets
new file mode 100644
index 0000000000..7a9cd9e06c
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsWindowManager.ets
@@ -0,0 +1,80 @@
+import window from '@ohos.window'
+import HashMap from '@ohos.util.HashMap'
+import JsDataStore from './JsDataStore'
+import JsLogger from './JsLogger'
+import JsWindow from './JsWindow'
+import JsIndependentWindow from './JsIndependentWindow'
+
+
+export class JsWindowManager {
+  private windows: HashMap<string, JsWindow> = new HashMap;
+
+  constructor() {
+
+  }
+
+  getWindow(name: string): JsWindow | undefined {
+    if (this.windows.hasKey(name))
+      return this.windows.get(name);
+    return undefined;
+  }
+
+  async addWindow(name: string, window: JsWindow): Promise<void> {
+    if (this.windows.hasKey(name))
+      return;
+    this.windows.set(name, window)
+    JsDataStore.getJsObjectLoader().addJsObject(name, window);
+    let id = this.windows.length;
+    window.setId(id);
+  }
+
+  removeWindow(name: string) {
+    this.windows.remove(name);
+    JsDataStore.getJsObjectLoader().deleteJsObject(name);
+  }
+
+  async createWindow(name: string, title: string, isTopLevel: boolean, hasFocus: boolean, hasFrame: boolean, parentWindowName?: string): Promise<boolean> {
+    JsLogger.info("create %{public}s window, window title is: %{public}s, window is top window %{public}s, window has frame: %{public}s, parent window is %{public}s", name, title, isTopLevel, hasFrame, parentWindowName);
+    try {
+      if (this.windows.hasKey(name))
+        return false;
+      let windowStage = JsDataStore.getWindowStage();
+      if (isTopLevel) {
+        let windowClass: window.Window | null = null;
+        if (JsDataStore.isDefaultDevice()) {
+          windowClass = await windowStage.createSubWindow(name);
+        } else {
+          windowClass = await windowStage.createSubWindowWithOptions(name, { title: title, decorEnabled: hasFrame });
+        }
+        let window = new JsIndependentWindow(name, windowClass);
+        this.addWindow(name, window);
+        await window.load();
+        await windowClass.setWindowFocusable(hasFocus);
+      }
+      if (!isTopLevel && parentWindowName != undefined) {
+        if (parentWindowName != undefined && parentWindowName.length > 0) {
+          let parentWindow = this.windows.get(parentWindowName);
+          if (parentWindow != undefined) {
+            let window = parentWindow.createSubWindow(name);
+            if (window != undefined) {
+              this.addWindow(name, window);
+            }
+          }
+        }
+      }
+      return true;
+    } catch (e) {
+      JsLogger.error("create window failed %{public}s", JSON.stringify(e));
+      return false;
+    }
+  }
+
+  async destroyWindow(name: string): Promise<boolean> {
+    if (!this.windows.hasKey(name))
+      return false;
+    let window = this.windows.remove(name);
+    // let result = window.destroyWindow();
+    JsDataStore.getJsObjectLoader().deleteJsObject(name);
+    return true;
+  }
+}
diff --git a/src/openharmony/native/QtCore/JsXCompoentNodeController.ets b/src/openharmony/native/QtCore/JsXCompoentNodeController.ets
new file mode 100644
index 0000000000..04fc391fb0
--- /dev/null
+++ b/src/openharmony/native/QtCore/JsXCompoentNodeController.ets
@@ -0,0 +1,115 @@
+import { FrameNode, BuilderNode, NodeController, Size } from '@ohos.arkui.node';
+import { UIContext } from '@ohos.arkui.UIContext';
+import { JsNodeParam, NodeType } from './JsNodeParam'
+import JsWindow  from './JsWindow'
+
+@Builder
+function XComponentBuilder(param: JsNodeParam) {
+  Stack({ alignContent: Alignment.TopStart }) {
+    if (param?.type == NodeType.XComponent) {
+      // XComponent
+      XComponent({
+        id: param?.id,
+        type: XComponentType.SURFACE,
+        libraryname: "plugins_platforms_qopenharmony"
+      }).focusable(true)
+        .focusOnTouch(true)
+    } else if (param?.type == NodeType.UIExtension) {
+    // @todo UIExtension is not support now
+    }
+      ForEach(param.children, (item: JsXComponentNodeController) => {
+          NodeContainer(item)
+              .zIndex(0)
+      }, (_item: JsXComponentNodeController, index: number) => index.toString())
+}.width(Number.isNaN(Number(param.width.toString())) ? param.width : Number(param.width.toString()))
+    .height(Number.isNaN(Number(param.height.toString())) ? param.height : Number(param.height.toString()))
+    .visibility(param.visibility)
+    .position({
+        x: (Number.isNaN(Number(param.x.toString())) ? param.x : Number(param.x.toString())),
+        y: (Number.isNaN(Number(param.y.toString())) ? param.y : Number(param.y.toString()))
+    }).borderWidth(1).borderColor(Color.Red);
+}
+
+export class JsXComponentNodeController extends NodeController {
+    private builderNode: BuilderNode<JsNodeParam[]> | null = null;
+    private wrapBuilder = new WrappedBuilder<[JsNodeParam]>(XComponentBuilder);
+    private param: JsNodeParam = new JsNodeParam("");
+    private parentNodeController: JsXComponentNodeController | undefined = undefined;
+    public widthReal: number = 0;
+    public heightReal: number = 0;
+    public window?: JsWindow
+
+    public getCurNode(): BuilderNode<JsNodeParam[]> | null {
+        return this.builderNode;
+    }
+
+    public getParent() {
+        return this.parentNodeController;
+    }
+
+    public setParent(parentNodeController: JsXComponentNodeController) {
+        this.parentNodeController = parentNodeController;
+        this.parentNodeController.addChild(this)
+    }
+
+    public addChild(childNodeController: JsXComponentNodeController) {
+        this.param.children.push(childNodeController);
+    }
+
+    public getParam(): JsNodeParam {
+        return this.param;
+    }
+
+    public setParams(param: JsNodeParam) {
+        this.param = param;
+        this.update();
+    }
+
+    constructor(window?: JsWindow, param?: JsNodeParam) {
+        super();
+        if (window != undefined)
+            this.window = window;
+        if (param != undefined) {
+            this.param = param as JsNodeParam;
+        }
+        if (this.builderNode == null && this.window != undefined) {
+            this.builderNode = new BuilderNode(this.window.getUIContext() as UIContext);
+            this.builderNode.build(this.wrapBuilder, this.param as JsNodeParam);
+        }
+    }
+
+    makeNode(uiContext: UIContext): FrameNode | null {
+        // Check whether the builderNode is initialized and then determine whether to run the build command.
+        if (this.builderNode != null) {
+            this.builderNode.build(this.wrapBuilder, this.param);
+            return this.builderNode.getFrameNode();
+        }
+        return null;
+    }
+
+    aboutToResize(size: Size) {
+        this.widthReal = size.width;
+        this.heightReal = size.height;
+    }
+
+    delete() {
+        for (let i = 0; i < this.param.children.length; i++) {
+            this.param.children[i].delete();
+        }
+        this.builderNode?.build(this.wrapBuilder, new JsNodeParam(""))
+        this.builderNode = null;
+    }
+
+    update() {
+        if (this.builderNode != null) {
+            this.builderNode.update(this.param);
+        }
+    }
+    async setGeometry(x: number, y: number, w: number, h: number): Promise<boolean> {
+        this.param.x = x;
+        this.param.y = y;
+        this.param.width = w;
+        this.param.height = h;
+        return true;
+    }
+}
diff --git a/src/openharmony/native/QtGui/JsQtGui.ets b/src/openharmony/native/QtGui/JsQtGui.ets
new file mode 100644
index 0000000000..640cbe35eb
--- /dev/null
+++ b/src/openharmony/native/QtGui/JsQtGui.ets
@@ -0,0 +1,38 @@
+import JsLogger from '../QtCore/JsLogger';
+import JsDataStore from '../QtCore/JsDataStore'
+import { JsQtModule } from '../QtCore/JsQtModule'
+
+import {
+  addChildNode,
+  reParentNode
+} from 'adapter_ts';
+
+
+interface QtGui {
+  default: Object;
+}
+
+export class JsQtGui extends JsQtModule {
+  public constructor() {
+    super();
+  }
+
+  async loadQtGui(): Promise<void> {
+    let qtMajorVersion: number = JsDataStore.getQtNativeModule("QPA").qtMajorVersion();
+    let qtGui: QtGui | undefined = undefined;
+    if (qtMajorVersion == 5) {
+      qtGui = await import("libQt5Gui.so");
+    } else if (qtMajorVersion == 6) {
+      qtGui = await import("libQt6Gui.so");
+    }
+    if (qtGui == undefined) {
+      JsLogger.fatal("Cannot load QtGui module");
+      return;
+    }
+    JsDataStore.addQtNativeModule("QtGui", qtGui.default);
+    JsDataStore.getQtNativeModule("QtGui").initFunc("AddChildNode", addChildNode);
+    JsDataStore.getQtNativeModule("QtGui").initFunc("ReParentNode", reParentNode);
+  }
+}
+
+export default new JsQtGui;
\ No newline at end of file
diff --git a/src/openharmony/openharmony.pro b/src/openharmony/openharmony.pro
new file mode 100644
index 0000000000..01944a32fd
--- /dev/null
+++ b/src/openharmony/openharmony.pro
@@ -0,0 +1,15 @@
+TEMPLATE = aux
+CONFIG -= qt
+
+templates.files += $$files($$PWD/entryability/*.ts, true)
+templates.files += $$files($$PWD/entryability/*.ets, true)
+templates.files += $$files($$PWD/native/*.ts, true)
+templates.files += $$files($$PWD/native/*.ets, true)
+templates.files += $$files($$PWD/pages/*.ts, true)
+templates.files += $$files($$PWD/pages/*.ets, true)
+templates.path = $$[QT_INSTALL_PREFIX]/openharmony/qtbase
+templates.base = $$PWD
+
+INSTALLS += templates
+
+OTHER_FILES += $$templates.files
diff --git a/src/openharmony/pages/Index.ets b/src/openharmony/pages/Index.ets
new file mode 100644
index 0000000000..2cb84a3ac3
--- /dev/null
+++ b/src/openharmony/pages/Index.ets
@@ -0,0 +1,51 @@
+import JsDataStore from '../native/QtCore/JsDataStore'
+import { JsWindowManager } from '../native/QtCore/JsWindowManager'
+import { NodeParams, ViewNodeController, addRootNode, NodeType, XComponentModel } from 'adapter_ts'
+
+let storage = LocalStorage.getShared()
+
+function createRootController(param: NodeParams): ViewNodeController | undefined {
+  let windowManager = JsDataStore.getJsObjectLoader().getJsObject("JsWindowManager") as JsWindowManager;
+  let window = windowManager?.getWindow(param.node_xcomponent.id);
+  if (window != undefined) {
+    param.visibility = Visibility.Visible;
+    param.border_width = 0;
+    let uicontext: UIContext | undefined = window.getUIContext();
+    JsDataStore.setUiContext(uicontext);
+    let rootNodeController = addRootNode(window.getId(), uicontext as UIContext, param);
+    window.setXComponentController(rootNodeController);
+    return rootNodeController;
+  }
+  return undefined;
+}
+
+@Entry(storage)
+@Component
+struct Index {
+  @LocalStorageProp("idName") windowId: string = "";
+  private model: XComponentModel =
+    new XComponentModel(this.windowId, XComponentType.SURFACE, "plugins_platforms_qopenharmony");
+  private param: NodeParams = new NodeParams(0, 0, '100%', '100%', NodeType.XComponent, this.model);
+  @State rootXComponentController: ViewNodeController | undefined = createRootController(this.param)
+
+  build() {
+    Stack() {
+      NodeContainer(this.rootXComponentController)
+    }
+  }
+}
+
+// @Entry(storage)
+// @Component
+// struct Index {
+//     @LocalStorageProp("idName") windowId: string = "";
+//
+//   build() {
+//     Row() {
+//       XComponent({id: this.windowId, type: 'surface', libraryname: 'plugins_platforms_qopenharmony' }).width("100%").height("100%")
+//         .onLoad(()=>{
+//
+//         })
+//     }
+//   }
+// }
\ No newline at end of file
diff --git a/src/plugins/platforms/openharmony/openharmony.json b/src/plugins/platforms/openharmony/openharmony.json
new file mode 100644
index 0000000000..886625295c
--- /dev/null
+++ b/src/plugins/platforms/openharmony/openharmony.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "openharmony" ]
+}
diff --git a/src/plugins/platforms/openharmony/openharmony.pro b/src/plugins/platforms/openharmony/openharmony.pro
new file mode 100644
index 0000000000..ff9badfecd
--- /dev/null
+++ b/src/plugins/platforms/openharmony/openharmony.pro
@@ -0,0 +1,76 @@
+TARGET = qopenharmony
+
+LIBS += -lEGL -lace_napi.z -lace_ndk.z -lrawfile.z -lnative_window
+contains(DEFINES, OH_URI): LIBS += -lohfileuri
+
+QT += \
+    core-private gui-private egl_support-private \
+    eventdispatcher_support-private fontdatabase_support-private
+
+qtConfig(vulkan){
+    QT += vulkan_support-private
+
+    HEADERS += $$PWD/qopenharmonyplatformvulkaninstance.h
+
+    SOURCES += $$PWD/qopenharmonyplatformvulkaninstance.cpp
+}
+
+OTHER_FILES += $$PWD/openharmony.json
+
+HEADERS += $$PWD/qopenharmonyplatformintegration.h \
+    $$PWD/qopenharmonyplatformwindow.h \
+    $$PWD/qopenharmonyplatformopenglwindow.h \
+    $$PWD/qopenharmonyplatformforeignwindow.h \
+    $$PWD/qopenharmonyplatformscreen.h \
+    $$PWD/qopenharmonyplatformbackingstore.h \
+    $$PWD/qopenharmonylog.h \
+    $$PWD/qopenharmonyxcomponent.h \
+    $$PWD/qopenharmonyjswindowmanager.h \
+    $$PWD/qopenharmonyplatformopenglcontext.h \
+    $$PWD/qopenharmonyeventdispatcher.h \
+    $$PWD/qopenharmonyplatformoffscreensurface.h \
+    $$PWD/qopenharmonymain.h \
+    $$PWD/qopenharmonyeglcore.h \
+    $$PWD/qopenharmonyplatformfontdatabase.h \
+    $$PWD/qopenharmonyplatforminputcontext.h \
+    $$PWD/qopenharmonyplatformtheme.h \
+    $$PWD/qopenharmonyplatformdialoghelpers.h \
+    $$PWD/qopenharmonydrag.h \
+    $$PWD/qopenharmonyfileenginehandler.h \
+    $$PWD/qopenharmonyjswindow.h \
+    $$PWD/qopenharmonyplatformservices.h \
+    $$PWD/qopenharmonyplatformcursor.h
+
+SOURCES += $$PWD/qopenharmonyplatformplugin.cpp \
+    $$PWD/qopenharmonyplatformwindow.cpp \
+    $$PWD/qopenharmonyplatformintegration.cpp \
+    $$PWD/qopenharmonyplatformopenglwindow.cpp \
+    $$PWD/qopenharmonyplatformforeignwindow.cpp \
+    $$PWD/qopenharmonyplatformscreen.cpp \
+    $$PWD/qopenharmonyplatformbackingstore.cpp \
+    $$PWD/qopenharmonyplatformopenglcontext.cpp \
+    $$PWD/qopenharmonyplatformoffscreensurface.cpp \
+    $$PWD/qopenharmonymain.cpp \
+    $$PWD/qopenharmonyxcomponent.cpp \
+    $$PWD/qopenharmonyjswindowmanager.cpp \
+    $$PWD/qopenharmonyeventdispatcher.cpp \
+    $$PWD/qopenharmonyeglcore.cpp \
+    $$PWD/qopenharmonyplatformfontdatabase.cpp \
+    $$PWD/qopenharmonyplatforminputcontext.cpp \
+    $$PWD/qopenharmonyplatformtheme.cpp \
+    $$PWD/qopenharmonyplatformdialoghelpers.cpp \
+    $$PWD/qopenharmonyplatformclipboard.cpp \
+    $$PWD/qopenharmonydrag.cpp \
+    $$PWD/qopenharmonyfileenginehandler.cpp \
+    $$PWD/qopenharmonyjswindow.cpp  \
+    $$PWD/qopenharmonyplatformservices.cpp \
+    $$PWD/qopenharmonyplatformcursor.cpp
+
+
+PLUGIN_TYPE = platforms
+
+PLUGIN_CLASS_NAME = QOpenHarmonyPlatformIntegrationPlugin
+!equals(TARGET, $$QT_DEFAULT_QPA_PLUGIN): PLUGIN_EXTENDS = -
+
+load(qt_plugin)
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonydrag.cpp b/src/plugins/platforms/openharmony/qopenharmonydrag.cpp
new file mode 100644
index 0000000000..e2f803ddc9
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonydrag.cpp
@@ -0,0 +1,134 @@
+#include <QtCore/QLoggingCategory>
+#include <private/qhighdpiscaling_p.h>
+
+#include "qguiapplication.h"
+#include "qopenharmonydrag.h"
+#include "qpa/qplatformscreen.h"
+#include "qpa/qplatformwindow.h"
+#include "private/qguiapplication_p.h"
+#include "qpa/qwindowsysteminterface.h"
+
+QT_BEGIN_NAMESPACE
+
+Q_LOGGING_CATEGORY(ohDnd, "qt.openharmony.dnd")
+
+static QWindow* topLevelAt(const QPoint &pos)
+{
+    QWindowList list = QGuiApplication::topLevelWindows();
+    for (int i = list.count()-1; i >= 0; --i) {
+        QWindow *w = list.at(i);
+        if (w->isVisible() && w->handle() && w->geometry().contains(pos)/* && !qobject_cast<QShapedPixmapWindow*>(w)*/)
+            return w;
+    }
+    return 0;
+}
+
+QOpenHarmonyDrag::QOpenHarmonyDrag() = default;
+QOpenHarmonyDrag::~QOpenHarmonyDrag()
+{
+
+}
+
+void QOpenHarmonyDrag::startDrag()
+{
+    qInfo() << "<----------------------:::QOpenHarmonyDrag::startDrag()";
+    setExecutedDropAction(Qt::IgnoreAction);
+
+    QBasicDrag::startDrag();
+    // Here we can be fairly sure that QGuiApplication::mouseButtons/keyboardModifiers() will
+    // contain sensible values as startDrag() normally is called from mouse event handlers
+    // by QDrag::exec(). A better API would be if we could pass something like "input device
+    // pointer" to QDrag::exec(). My guess is that something like that might be required for
+    // QTBUG-52430.
+    m_sourceWindow = topLevelAt(QCursor::pos());
+    m_windowUnderCursor = m_sourceWindow;
+    if (m_sourceWindow) {
+        auto nativePixelPos = QHighDpi::toNativePixels(QCursor::pos(), m_sourceWindow);
+        move(nativePixelPos, QGuiApplication::mouseButtons(), QGuiApplication::keyboardModifiers());
+    } else {
+        setCanDrop(false);
+        updateCursor(Qt::IgnoreAction);
+    }
+}
+
+static void sendDragLeave(QWindow *window)
+{
+    QWindowSystemInterface::handleDrag(window, nullptr, QPoint(), Qt::IgnoreAction, 0, 0);
+}
+
+void QOpenHarmonyDrag::cancel()
+{
+    QBasicDrag::cancel();
+    if (drag() && m_sourceWindow) {
+        sendDragLeave(m_sourceWindow);
+        m_sourceWindow = nullptr;
+    }
+}
+
+static inline QPoint fromNativeGlobalPixels(const QPoint &point)
+{
+#ifndef QT_NO_HIGHDPISCALING
+    QPoint res = point;
+    if (QHighDpiScaling::isActive()) {
+        for (const QScreen *s : qAsConst(QGuiApplicationPrivate::screen_list)) {
+            if (s->handle()->geometry().contains(point)) {
+                res = QHighDpi::fromNativePixels(point, s);
+                break;
+            }
+        }
+    }
+    return res;
+#else
+    return point;
+#endif
+}
+
+void QOpenHarmonyDrag::move(const QPoint &nativeGlobalPos, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)
+{
+    QPoint globalPos = fromNativeGlobalPixels(nativeGlobalPos);
+    moveShapedPixmapWindow(globalPos);
+    QWindow *window = topLevelAt(globalPos);
+
+    if (!window || window != m_windowUnderCursor) {
+        if (m_windowUnderCursor)
+            sendDragLeave(m_windowUnderCursor);
+        m_windowUnderCursor = window;
+        if (!window) {
+            // QSimpleDrag supports only in-process dnd, we can't drop anywhere else.
+            setCanDrop(false);
+            updateCursor(Qt::IgnoreAction);
+            return;
+        }
+    }
+
+    const QPoint pos = nativeGlobalPos - window->handle()->geometry().topLeft();
+    const QPlatformDragQtResponse qt_response = QWindowSystemInterface::handleDrag(
+            window, drag()->mimeData(), pos, drag()->supportedActions(),
+            buttons, modifiers);
+
+    setCanDrop(qt_response.isAccepted());
+    updateCursor(qt_response.acceptedAction());
+}
+
+void QOpenHarmonyDrag::drop(const QPoint &nativeGlobalPos, Qt::MouseButtons buttons,
+                            Qt::KeyboardModifiers modifiers)
+{
+    QPoint globalPos = fromNativeGlobalPixels(nativeGlobalPos);
+
+    QBasicDrag::drop(nativeGlobalPos, buttons, modifiers);
+    QWindow *window = topLevelAt(globalPos);
+    if (!window)
+        return;
+
+    const QPoint pos = nativeGlobalPos - window->handle()->geometry().topLeft();
+    const QPlatformDropQtResponse response = QWindowSystemInterface::handleDrop(
+            window, drag()->mimeData(), pos, drag()->supportedActions(),
+            buttons, modifiers);
+    if (response.isAccepted()) {
+        setExecutedDropAction(response.acceptedAction());
+    } else {
+        setExecutedDropAction(Qt::IgnoreAction);
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonydrag.h b/src/plugins/platforms/openharmony/qopenharmonydrag.h
new file mode 100644
index 0000000000..f29ee6fccb
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonydrag.h
@@ -0,0 +1,25 @@
+#ifndef QOPENHARMONYDRAG_H
+#define QOPENHARMONYDRAG_H
+
+#include <QtGui/qdrag.h>
+#include <QtGui/qpixmap.h>
+#include <private/qsimpledrag_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyDrag : public QBasicDrag
+{
+public:
+    QOpenHarmonyDrag();
+    virtual ~QOpenHarmonyDrag();
+
+protected:
+    virtual void startDrag() override;
+    virtual void cancel() override;
+    virtual void move(const QPoint &globalPos, Qt::MouseButtons b, Qt::KeyboardModifiers mods) override;
+    virtual void drop(const QPoint &globalPos, Qt::MouseButtons b, Qt::KeyboardModifiers mods) override;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYDRAG_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeglcore.cpp b/src/plugins/platforms/openharmony/qopenharmonyeglcore.cpp
new file mode 100644
index 0000000000..b59241bfbb
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeglcore.cpp
@@ -0,0 +1,90 @@
+#include <EGL/egl.h>
+#include <GLES3/gl3.h>
+
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonylog.h"
+#include <QtGlobal>
+
+EGLDisplay QOpenHarmonyEGLCore::m_eglDisplay = EGL_NO_DISPLAY;
+EGLConfig QOpenHarmonyEGLCore::m_eglConfig = nullptr;
+
+QOpenHarmonyEGLCore::QOpenHarmonyEGLCore()
+{
+
+}
+
+QOpenHarmonyEGLCore::~QOpenHarmonyEGLCore()
+{
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+}
+
+void QOpenHarmonyEGLCore::init()
+{
+    m_eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (Q_UNLIKELY(m_eglDisplay == EGL_NO_DISPLAY)) {
+        LOGE("Could not open egl display, error code: %{public}d", eglGetError());
+        return;
+    }
+
+    EGLint major, minor;
+    if (Q_UNLIKELY(!eglInitialize(m_eglDisplay, &major, &minor))) {
+        m_eglDisplay = EGL_NO_DISPLAY;
+        LOGE("Could not initialize egl display, error code: %{public}d", eglGetError());
+    }
+
+    if (Q_UNLIKELY(!eglBindAPI(EGL_OPENGL_ES_API))) {
+        LOGE("Could not bind GL_ES API, error code: %{public}d", eglGetError());
+        return;
+    }
+
+    m_eglConfig = initConfig();
+    if (m_eglConfig == nullptr) {
+        LOGE("init config error");
+        return;
+    }
+}
+
+EGLConfig QOpenHarmonyEGLCore::initConfig(int version) {
+    int attribList[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RED_SIZE, 8,
+        EGL_GREEN_SIZE, 8,
+        EGL_BLUE_SIZE, 8,
+        EGL_ALPHA_SIZE, 8,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_NONE
+    };
+    EGLConfig configs = NULL;
+    int configsNum;
+    eglChooseConfig(m_eglDisplay, attribList, &configs, 1, &configsNum);
+    return configs;
+}
+
+EGLSurface QOpenHarmonyEGLCore::eglSurface(EGLNativeWindowType window)
+{
+    if (m_eglSurface == EGL_NO_SURFACE) {
+        LOGI("QOpenHarmonyEGLCore::init window = %{public}lu.", window);
+
+        m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, window, NULL);
+        if (m_eglSurface == EGL_NO_SURFACE) {
+            LOGE("EGLCore::eglCreateWindowSurface eglSurface is null, error code:%{public}d", eglGetError());
+        }
+    }
+    return m_eglSurface;
+}
+
+EGLConfig QOpenHarmonyEGLCore::eglConfig()
+{
+    return m_eglConfig;
+}
+
+void QOpenHarmonyEGLCore::clear()
+{
+    if (m_eglDisplay != EGL_NO_DISPLAY)
+        eglTerminate(m_eglDisplay);
+}
+
+EGLDisplay QOpenHarmonyEGLCore::eglDisplay()
+{
+    return m_eglDisplay;
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeglcore.h b/src/plugins/platforms/openharmony/qopenharmonyeglcore.h
new file mode 100644
index 0000000000..f8c6e5fe00
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeglcore.h
@@ -0,0 +1,32 @@
+#ifndef QOPENHARMONYEGLCORE_H
+#define QOPENHARMONYEGLCORE_H
+
+#include <GLES3/gl3.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+class QOpenHarmonyEGLCore
+{
+public:
+    QOpenHarmonyEGLCore();
+    ~QOpenHarmonyEGLCore();
+
+public:
+    static void init();
+
+    static EGLDisplay eglDisplay();
+
+    static EGLConfig eglConfig();
+
+    static void clear();
+
+    EGLSurface eglSurface(EGLNativeWindowType window);
+
+private:
+    static EGLConfig initConfig(int version = 3);
+    static EGLDisplay m_eglDisplay;
+    static EGLConfig m_eglConfig;
+    EGLSurface m_eglSurface = nullptr;
+};
+
+#endif // QOPENHARMONYEGLCORE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.cpp b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.cpp
new file mode 100644
index 0000000000..b289ce7664
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.cpp
@@ -0,0 +1,128 @@
+#include "qopenharmonylog.h"
+#include "qopenharmonyeventdispatcher.h"
+
+QOpenHarmonyEventDispatcher::QOpenHarmonyEventDispatcher(QObject *parent) :
+    QUnixEventDispatcherQPA(parent)
+{
+    QOpenHarmonyEventDispatcherStopper::instance()->addEventDispatcher(this);
+}
+
+QOpenHarmonyEventDispatcher::~QOpenHarmonyEventDispatcher()
+{
+    QOpenHarmonyEventDispatcherStopper::instance()->removeEventDispatcher(this);
+}
+
+enum States {Running = 0, StopRequest = 1, Stopping = 2};
+
+void QOpenHarmonyEventDispatcher::start()
+{
+    int prevState = m_stopRequest.fetchAndStoreAcquire(Running);
+    if (prevState == Stopping) {
+        m_semaphore.release();
+        wakeUp();
+    } else if (prevState == Running) {
+        LOGW("Error: start without corresponding stop");
+    }
+    //else if prevState == StopRequest, no action needed
+}
+
+void QOpenHarmonyEventDispatcher::stop()
+{
+    if (m_stopRequest.testAndSetAcquire(Running, StopRequest))
+        wakeUp();
+    else
+        LOGW("Error: start/stop out of sync");
+}
+
+void QOpenHarmonyEventDispatcher::goingToStop(bool stop)
+{
+    m_goingToStop.store(stop ? 1 : 0);
+    if (!stop)
+        wakeUp();
+}
+
+class OpenHarmonyDeadlockProtector
+{
+public:
+    OpenHarmonyDeadlockProtector()
+        : m_acquired(0)
+    {
+    }
+
+    ~OpenHarmonyDeadlockProtector() {
+        if (m_acquired)
+            s_blocked.storeRelease(0);
+    }
+
+    bool acquire() {
+        m_acquired = s_blocked.testAndSetAcquire(0, 1);
+        return m_acquired;
+    }
+
+private:
+    static QAtomicInt s_blocked;
+    int m_acquired;
+};
+
+QAtomicInt OpenHarmonyDeadlockProtector::s_blocked(0);
+
+bool QOpenHarmonyEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags)
+{
+    if (m_goingToStop.load())
+        flags |= QEventLoop::ExcludeSocketNotifiers | QEventLoop::X11ExcludeTimers;
+
+    {
+        OpenHarmonyDeadlockProtector protector;
+        if (protector.acquire() && m_stopRequest.testAndSetAcquire(StopRequest, Stopping)) {
+            m_semaphore.acquire();
+            wakeUp();
+        }
+    }
+
+    return QUnixEventDispatcherQPA::processEvents(flags);
+}
+
+QOpenHarmonyEventDispatcherStopper *QOpenHarmonyEventDispatcherStopper::instance()
+{
+    static QOpenHarmonyEventDispatcherStopper openharmonyEventDispatcherStopper;
+    return &openharmonyEventDispatcherStopper;
+}
+
+void QOpenHarmonyEventDispatcherStopper::startAll()
+{
+    QMutexLocker lock(&m_mutex);
+    if (!m_started.testAndSetOrdered(0, 1))
+        return;
+
+    for (QOpenHarmonyEventDispatcher *d : qAsConst(m_dispatchers))
+        d->start();
+}
+
+void QOpenHarmonyEventDispatcherStopper::stopAll()
+{
+    QMutexLocker lock(&m_mutex);
+    if (!m_started.testAndSetOrdered(1, 0))
+        return;
+
+    for (QOpenHarmonyEventDispatcher *d : qAsConst(m_dispatchers))
+        d->stop();
+}
+
+void QOpenHarmonyEventDispatcherStopper::addEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher)
+{
+    QMutexLocker lock(&m_mutex);
+    m_dispatchers.push_back(dispatcher);
+}
+
+void QOpenHarmonyEventDispatcherStopper::removeEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher)
+{
+    QMutexLocker lock(&m_mutex);
+    m_dispatchers.erase(std::find(m_dispatchers.begin(), m_dispatchers.end(), dispatcher));
+}
+
+void QOpenHarmonyEventDispatcherStopper::goingToStop(bool stop)
+{
+    QMutexLocker lock(&m_mutex);
+    for (QOpenHarmonyEventDispatcher *d : qAsConst(m_dispatchers))
+        d->goingToStop(stop);
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.h b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.h
new file mode 100644
index 0000000000..51fe72e96e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyeventdispatcher.h
@@ -0,0 +1,46 @@
+#ifndef QOPENHARMONYEVENTDISPATCHER_H
+#define QOPENHARMONYEVENTDISPATCHER_H
+
+#include <QtCore/QMutex>
+#include <QtCore/QSemaphore>
+#include <QtEventDispatcherSupport/private/qunixeventdispatcher_qpa_p.h>
+
+class QOpenHarmonyEventDispatcher : public QUnixEventDispatcherQPA
+{
+    Q_OBJECT
+public:
+    explicit QOpenHarmonyEventDispatcher(QObject *parent = 0);
+    ~QOpenHarmonyEventDispatcher();
+    void start();
+    void stop();
+
+    void goingToStop(bool stop);
+
+protected:
+    bool processEvents(QEventLoop::ProcessEventsFlags flags) override;
+
+private:
+    QAtomicInt m_stopRequest;
+    QAtomicInt m_goingToStop;
+    QSemaphore m_semaphore;
+};
+
+class QOpenHarmonyEventDispatcherStopper
+{
+public:
+    static QOpenHarmonyEventDispatcherStopper *instance();
+    static bool stopped() {return !instance()->m_started.load(); }
+    void startAll();
+    void stopAll();
+    void addEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher);
+    void removeEventDispatcher(QOpenHarmonyEventDispatcher *dispatcher);
+    void goingToStop(bool stop);
+
+private:
+    QMutex m_mutex;
+    QAtomicInt m_started = 1;
+    QVector<QOpenHarmonyEventDispatcher *> m_dispatchers;
+};
+
+
+#endif // QOPENHARMONYEVENTDISPATCHER_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.cpp b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.cpp
new file mode 100644
index 0000000000..fb470150b6
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.cpp
@@ -0,0 +1,480 @@
+#include <QString>
+#include <QByteArray>
+#include <QSharedPointer>
+#include <rawfile/raw_dir.h>
+#include <rawfile/raw_file.h>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsObjectLoader>
+#include <rawfile/raw_file_manager.h>
+
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyfileenginehandler.h"
+
+QT_BEGIN_NAMESPACE
+
+typedef QVector<QString> FilesList;
+
+struct OpenHarmonyRawDir
+{
+    OpenHarmonyRawDir(RawDir* rd)
+    {
+        if (rd) {
+            const char *fileName;
+            int count = OH_ResourceManager_GetRawFileCount(rd);
+            for (int i = 0; i < count; ++i) {
+                const char *fileName = OH_ResourceManager_GetRawFileName(rd, i);
+                m_items.push_back(QString::fromUtf8(fileName));
+            }
+            OH_ResourceManager_CloseRawDir(rd);
+        }
+    }
+    FilesList m_items;
+};
+
+
+class OpenHarmonyAbstractFileEngineIterator: public QAbstractFileEngineIterator
+{
+public:
+    OpenHarmonyAbstractFileEngineIterator(QDir::Filters filters,
+                                      const QStringList &nameFilters,
+                                      QSharedPointer<OpenHarmonyRawDir> rd,
+                                      const QString &path)
+        : QAbstractFileEngineIterator(filters, nameFilters)
+    {
+        m_items = rd->m_items;
+        m_index = -1;
+        m_path = path;
+    }
+
+    QFileInfo currentFileInfo() const override
+    {
+        return QFileInfo(currentFilePath());
+    }
+
+    QString currentFileName() const override
+    {
+        if (m_index < 0 || m_index >= m_items.size())
+            return QString();
+        QString fileName = m_items[m_index];
+        if (fileName.endsWith(QLatin1Char('/')))
+            fileName.chop(1);
+        return fileName;
+    }
+
+    virtual QString currentFilePath() const
+    {
+        return m_path + currentFileName();
+    }
+
+    bool hasNext() const override
+    {
+        return m_items.size() && (m_index < m_items.size() - 1);
+    }
+
+    QString next() override
+    {
+        if (!hasNext())
+            return QString();
+        m_index++;
+        return currentFileName();
+    }
+
+private:
+    QString     m_path;
+    FilesList   m_items;
+    int         m_index;
+};
+
+
+class QOpenHarmonyRawfileEngine: public QAbstractFileEngine
+{
+public:
+   explicit QOpenHarmonyRawfileEngine(RawFile *file, const QString &fileName)
+        : m_file(file)
+        , m_fileName(fileName)
+    {
+
+    }
+
+    explicit QOpenHarmonyRawfileEngine(QSharedPointer<OpenHarmonyRawDir> ohrd, const QString &fileName)
+    {
+        m_file = 0;
+        m_dir = ohrd;
+        m_fileName =  fileName;
+        if (!m_fileName.endsWith(QLatin1Char('/')))
+            m_fileName += QLatin1Char('/');
+    }
+
+    bool open(QIODevice::OpenMode openMode) override
+    {
+        return m_file != 0 && (openMode & QIODevice::WriteOnly) == 0;
+    }
+
+    bool close() override
+    {
+        if (m_file) {
+            OH_ResourceManager_CloseRawFile(m_file);
+            m_file = 0;
+            return true;
+        }
+        return false;
+    }
+
+    qint64 size() const override
+    {
+        if (m_file)
+            return OH_ResourceManager_GetRawFileSize(m_file);
+        return -1;
+    }
+
+    qint64 pos() const override
+    {
+        if (m_file)
+            return OH_ResourceManager_GetRawFileOffset(m_file);
+        return -1;
+    }
+
+    bool seek(qint64 pos) override
+    {
+        if (m_file)
+            return pos == OH_ResourceManager_SeekRawFile(m_file, pos, 0);
+        return false;
+    }
+
+    qint64 read(char *data, qint64 maxlen) override
+    {
+        if (m_file)
+            return OH_ResourceManager_ReadRawFile(m_file, data, maxlen);
+        return -1;
+    }
+
+    bool isSequential() const override
+    {
+        return false;
+    }
+
+    bool caseSensitive() const override
+    {
+        return true;
+    }
+
+    bool isRelativePath() const override
+    {
+        return false;
+    }
+
+    FileFlags fileFlags(FileFlags type = FileInfoAll) const override
+    {
+        FileFlags flags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm|ExistsFlag);
+        if (m_file)
+            flags |= FileType;
+        if (!m_dir.isNull())
+            flags |= DirectoryType;
+
+        return type & flags;
+    }
+
+    QString fileName(FileName file = DefaultName) const override
+    {
+        int pos;
+        switch (file) {
+        case DefaultName:
+        case AbsoluteName:
+        case CanonicalName:
+                return m_fileName;
+        case BaseName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.mid(pos);
+            else
+                return m_fileName;
+        case PathName:
+        case AbsolutePathName:
+        case CanonicalPathName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.left(pos);
+            else
+                return m_fileName;
+        default:
+            return QString();
+        }
+    }
+
+    void setFileName(const QString &file) override
+    {
+        if (file == m_fileName)
+            return;
+
+        m_fileName = file;
+        close();
+    }
+
+    Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames) override
+    {
+        if (!m_dir.isNull())
+            return new OpenHarmonyAbstractFileEngineIterator(filters, filterNames, m_dir, m_fileName);
+        return 0;
+    }
+private:
+    RawFile *m_file;
+    QString m_fileName;
+    QSharedPointer<OpenHarmonyRawDir> m_dir;
+};
+
+
+class QOpenHarmonyFileEngine: public QAbstractFileEngine
+{
+public:
+    explicit QOpenHarmonyFileEngine(const QString &fileName)
+    {
+        m_fileName = fileName;
+        static int index = 0;
+        m_fileHandler = QString("fileHandler%1").arg(index++);
+        m_jsFile = qJsObjectLoader->create("JsFile", m_fileHandler, QVariantList() << m_fileName);
+    }
+
+    ~QOpenHarmonyFileEngine()
+    {
+        close();
+        if (!m_jsFile.isNull()) {
+            qJsObjectLoader->remove(m_jsFile->uniqueName());
+        }
+    }
+
+    bool checkJsFile() const
+    {
+        if (m_jsFile.isNull() || !m_jsFile->isValid()) {
+            LOGE("dlclose failed: %{public}s", "js file object is invalid");
+            return false;
+        }
+        return true;
+    }
+
+    bool exists() const {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("isExists");
+    }
+
+    bool open(QIODevice::OpenMode openMode) override
+    {
+        if (!checkJsFile())
+            return false;
+
+//        const READ_ONLY = 0o0; // Read only Permission
+//        const WRITE_ONLY = 0o1; // Write only Permission
+//        const READ_WRITE = 0o2; // Write and Read Permission
+//        const CREATE = 0o100; // If not exist, create file
+//        const TRUNC = 0o1000; // File truncate len 0
+//        const APPEND = 0o2000; // File append write
+//        const NONBLOCK = 0o4000; // File open in nonblocking mode
+//        const DIR = 0o200000; // File is Dir
+//        const NOFOLLOW = 0o400000; // File is not symbolic link
+//        const SYNC = 0o4010000; // SYNC IO
+
+        int mode = 0;
+        if (openMode & QIODevice::ReadOnly) {
+
+        }
+        if (openMode & QIODevice::WriteOnly) {
+            mode |= 1;
+        }
+        if (openMode & QIODevice::Append) {
+            mode |= 02000;
+        }
+
+        if (openMode & QIODevice::Truncate) {
+            mode |= 01000;
+        }
+
+        return m_jsFile->call<bool>("open", mode);
+    }
+
+    bool flush()
+    {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("flush");
+    }
+
+    bool close() override
+    {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("close");
+    }
+
+    qint64 size() const override
+    {
+        if (!checkJsFile())
+            return -1;
+        return m_jsFile->call<qint64>("size");
+    }
+
+    qint64 pos() const override
+    {
+        if (!checkJsFile())
+            return -1;
+        return m_jsFile->call<qint64>("pos");
+    }
+
+    bool seek(qint64 pos) override
+    {
+        if (!checkJsFile())
+            return false;
+        return m_jsFile->call<bool>("seek", pos);
+    }
+
+    qint64 read(char *data, qint64 maxlen) override
+    {
+        if (!checkJsFile())
+            return -1;
+
+        QByteArray result = m_jsFile->call<QByteArray>("read", maxlen);
+        qint64 l = result.length();
+        memcpy(data, result.constData(), qMin(l, maxlen));
+        return l;
+    }
+
+    bool isSequential() const override
+    {
+        return false;
+    }
+
+    bool caseSensitive() const override
+    {
+        return true;
+    }
+
+    bool isRelativePath() const override
+    {
+        return false;
+    }
+
+    FileFlags fileFlags(FileFlags type = FileInfoAll) const override
+    {
+        FileFlags flags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm);
+        if (exists()) {
+           flags |= ExistsFlag;
+           if (m_jsFile->call<bool>("isFile")) {
+               flags |= FileType;
+           } else if (m_jsFile->call<bool>("isDirectory")) {
+               flags |= DirectoryType;
+           } else if (m_jsFile->call<bool>("isLink")) {
+               flags |= LinkType;
+           }
+        }
+        return type & flags;
+    }
+
+    QString fileName(FileName file = DefaultName) const override
+    {
+        int pos;
+        switch (file) {
+        case DefaultName:
+        case AbsoluteName:
+        case CanonicalName:
+                return m_fileName;
+        case BaseName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.mid(pos);
+            else
+                return m_fileName;
+        case PathName:
+        case AbsolutePathName:
+        case CanonicalPathName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.left(pos);
+            else
+                return m_fileName;
+        default:
+            return QString();
+        }
+    }
+
+    void setFileName(const QString &file) override
+    {
+        if (file == m_fileName)
+            return;
+
+        m_fileName = file;
+
+
+        close();
+    }
+
+    qint64 write(const char *data, qint64 len) override
+    {
+        if (!checkJsFile())
+            return -1;
+        QByteArray dataArrary = QByteArray(data, len);
+        qint64 result = m_jsFile->call<qint64>("write", dataArrary);
+        return result;
+    }
+
+private:
+    QString m_fileName;
+    QString m_fileHandler;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsFile;
+};
+
+
+QOpenHarmonyFileEngineHandler::QOpenHarmonyFileEngineHandler()
+    : m_rawDirCache(5)
+    , m_hasPrepopulatedCache(false)
+    , m_hasTriedPrepopulatingCache(false)
+{
+
+}
+
+QAbstractFileEngine *QOpenHarmonyFileEngineHandler::create(const QString &fileName) const
+{
+    if (fileName.isEmpty())
+        return 0;
+
+//    static QLatin1String datasharePrefix("datashare:");
+    static QLatin1String rawfilePrefix("rawfile:/");
+
+    if (/*!fileName.startsWith(datasharePrefix) && */!fileName.startsWith(rawfilePrefix))
+        return 0;
+
+//    if (fileName.startsWith(datasharePrefix))
+//        return new QOpenHarmonyFileEngine(fileName);
+
+    if (fileName.startsWith(rawfilePrefix)) {
+        QString _fileName = fileName;
+        _fileName.replace("rawfile:/", "");
+        QByteArray byteArray = _fileName.toLatin1();
+        RawFile *file = OH_ResourceManager_OpenRawFile(QtOpenHarmony::resourceManager(), byteArray.constData());
+        if (file != nullptr) {
+            return new QOpenHarmonyRawfileEngine(file, fileName);
+        }
+        return 0;
+
+        //Todo OH_ResourceManager_OpenRawDir传入不存在的目录返回值不为空，无法判断
+
+//        m_rawfileCacheMutext.lock();
+//        QSharedPointer<OpenHarmonyRawDir> *ohrd = m_rawDirCache.object(_fileName.toLatin1());
+//        m_rawfileCacheMutext.unlock();
+
+//        if (!ohrd) {
+//            if (!m_hasPrepopulatedCache) {
+//                RawDir *rd = OH_ResourceManager_OpenRawDir(QtOpenHarmony::resourceManager(), byteArray.constData());
+//                if (rd) {
+//                    ohrd = new QSharedPointer<OpenHarmonyRawDir>(new OpenHarmonyRawDir(rd));
+//                    m_rawfileCacheMutext.lock();
+//                    m_rawDirCache.insert(_fileName.toLatin1(), ohrd);
+//                    m_rawfileCacheMutext.unlock();
+//                    return 0;
+//                    return new QOpenHarmonyRawfileEngine(*ohrd, fileName);
+//                }
+//                return 0;
+//            }
+//        } else {
+//            return new QOpenHarmonyRawfileEngine(*ohrd, fileName);
+//        }
+    }
+    return 0;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.h b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.h
new file mode 100644
index 0000000000..b81d93de63
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyfileenginehandler.h
@@ -0,0 +1,28 @@
+#ifndef QOPENHARMONYFILEENGINEHANDLER_H
+#define QOPENHARMONYFILEENGINEHANDLER_H
+
+#include <QtCore/private/qabstractfileengine_p.h>
+#include <QString>
+#include <QCache>
+#include <QMutex>
+#include <QSharedPointer>
+
+QT_BEGIN_NAMESPACE
+struct OpenHarmonyRawDir;
+
+class Q_CORE_EXPORT QOpenHarmonyFileEngineHandler : public QAbstractFileEngineHandler
+{
+public:
+    QOpenHarmonyFileEngineHandler();
+    virtual QAbstractFileEngine *create(const QString &fileName) const override;
+private:
+
+    mutable QCache<QByteArray, QSharedPointer<OpenHarmonyRawDir>> m_rawDirCache;
+    mutable QMutex m_rawfileCacheMutext;
+    mutable bool m_hasPrepopulatedCache;
+    mutable bool m_hasTriedPrepopulatingCache;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYFILEENGINEHANDLER_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyjswindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyjswindow.cpp
new file mode 100644
index 0000000000..84787bd26a
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyjswindow.cpp
@@ -0,0 +1,383 @@
+#include <QMargins>
+#include <QThreadPool>
+#include <QElapsedTimer>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsObjectLoader>
+#include <qpa/qwindowsysteminterface.h>
+#include <ace/xcomponent/native_interface_xcomponent.h>
+
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyjswindow.h"
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyplatformwindow.h"
+
+QT_BEGIN_NAMESPACE
+Q_DECLARE_METATYPE(QMargins)
+
+static QVariant jsMargins2QMargins(napi_value value)
+{
+    int64_t left = qJs::getInt64(qJs::objectPropertyValue(value, "left"));
+    int64_t top = qJs::getInt64(qJs::objectPropertyValue(value, "top"));
+    int64_t right = qJs::getInt64(qJs::objectPropertyValue(value, "right"));
+    int64_t bottom = qJs::getInt64(qJs::objectPropertyValue(value, "bottom"));
+    return QVariant::fromValue(QMargins(left, top, right, bottom));
+}
+
+struct WindowLimits {
+    int maxWidth;
+    int maxHeight;
+    int minWidth;
+    int minHeight;
+};
+
+Q_DECLARE_METATYPE(WindowLimits)
+
+static napi_value WindowLimits2JsWindowLimits(const WindowLimits &limits)
+{
+    napi_value result = qJs::createObject();
+    if (result == nullptr)
+        return nullptr;
+    qJs::setProperty(result, "maxWidth", limits.maxWidth);
+    qJs::setProperty(result, "maxHeight", limits.maxHeight);
+    qJs::setProperty(result, "minWidth", limits.minWidth);
+    qJs::setProperty(result, "minHeight", limits.minHeight);
+    return result;
+}
+
+struct InitHelper
+{
+    InitHelper() {
+        qRegisterMetaType<QMargins>();
+        qRegisterMetaType<WindowLimits>();
+
+        std::function<QVariant(napi_value)> sj2qt = jsMargins2QMargins;
+        qJs::registerQVariantCreator<QMargins>(sj2qt);
+        std::function<napi_value(const WindowLimits &)> windowLimitsCreatorFunc = WindowLimits2JsWindowLimits;
+        qJs::registerCreator(windowLimitsCreatorFunc);
+    }
+};
+
+InitHelper *QOpenHarmonyJsWindow::m_helper = new InitHelper;
+
+QOpenHarmonyJsWindow::QOpenHarmonyJsWindow(QOpenHarmonyJsWindow *parent)
+    : m_window(nullptr)
+    , m_parent(parent)
+    , m_component(nullptr)
+{
+
+}
+
+QOpenHarmonyJsWindow::~QOpenHarmonyJsWindow()
+{    
+    if (m_xComponentController != nullptr) {
+        napi_ref c = m_xComponentController;
+        qJs::runOnJsThread([c]{
+            napi_delete_reference(qJs::env(), c);
+        });
+    }
+
+    if (m_component != nullptr) {
+        m_component->setWindow(nullptr);
+        delete m_component;
+        m_component = nullptr;
+    }
+}
+
+void QOpenHarmonyJsWindow::setQtWindow(QOpenHarmonyPlatformWindow *window)
+{
+    if (window == nullptr)
+        return;
+    m_window = window;
+}
+
+QWindow *QOpenHarmonyJsWindow::qtWindow() const
+{
+    if (m_window == nullptr)
+        return nullptr;
+    return m_window->window();
+}
+
+void QOpenHarmonyJsWindow::setName(const QString &name)
+{
+    m_name = name;
+}
+
+QString QOpenHarmonyJsWindow::name() const
+{
+    return m_name;
+}
+
+QRect QOpenHarmonyJsWindow::qtGeometry() const
+{
+    if (m_window == nullptr)
+        return QRect();
+    return m_window->geometry();
+}
+
+void QOpenHarmonyJsWindow::setComponent(QOpenHarmonyXComponent *component)
+{
+    if (component == nullptr)
+        return;
+    m_component = component;
+    handleRepaintEvent();
+}
+
+void QOpenHarmonyJsWindow::setNativeWindow(OHNativeWindow *nativeWindow)
+{
+    m_nativeWindow = nativeWindow;
+}
+
+OHNativeWindow *QOpenHarmonyJsWindow::nativeWindow() const
+{
+    return m_nativeWindow;
+}
+
+OH_NativeXComponent *QOpenHarmonyJsWindow::component() const
+{
+    if (m_component == nullptr)
+        return nullptr;
+    return m_component->nativeComponent();
+}
+
+EGLSurface QOpenHarmonyJsWindow::eglSurface()
+{
+    if (m_component == nullptr)
+        return nullptr;
+    return m_component->eglSurface(reinterpret_cast<EGLNativeWindowType>(m_nativeWindow));
+}
+
+void QOpenHarmonyJsWindow::paint(const QImage &image, const QRegion &region, const QPoint &offset)
+{
+    if (m_component == nullptr) {
+        m_image = image;
+        m_region = region;
+        m_offset = offset;
+        return;
+    }
+    m_component->paint(image, region, offset);
+}
+
+QMargins QOpenHarmonyJsWindow::frameMargins() const
+{
+    if (m_jsWindow.isNull())
+        return QMargins();
+    if (m_window->hasFrame()) {
+        return m_frameMargins;
+    }
+    return QMargins();
+}
+
+/*!
+ * \note 不要在js线程调用该方法
+ */
+QMargins QOpenHarmonyJsWindow::readFrameMarginsFromTs() const
+{
+    return m_jsWindow->call<QMargins>("getMargins");
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyJsWindow::parent() const
+{
+    return m_parent;
+}
+
+void QOpenHarmonyJsWindow::setParent(QOpenHarmonyJsWindow *parent)
+{
+    m_parent = parent;
+}
+
+void QOpenHarmonyJsWindow::setWindowEvent(int event)
+{
+    if (m_window == nullptr)
+        return;
+    QMetaObject::invokeMethod(m_window->helper(), "handleWindowEvent", Q_ARG(int, event));
+}
+
+void QOpenHarmonyJsWindow::handleWindowStatusEvent(int event)
+{
+    if (m_window == nullptr)
+        return;
+    QMetaObject::invokeMethod(m_window->helper(), "handleWindowStatusEvent", Q_ARG(int, event));
+}
+
+void QOpenHarmonyJsWindow::handleRepaintEvent()
+{
+    if (m_window == nullptr)
+        return;
+    QMetaObject::invokeMethod(m_window->helper(), "handleRepaintEvent");
+}
+
+void QOpenHarmonyJsWindow::startListener()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    m_jsWindow->call<bool>("startListener");
+}
+
+QRect QOpenHarmonyJsWindow::jsGeometry()
+{
+    if (m_jsWindow.isNull())
+        return QRect();
+    QRect jsRect = QRect();
+    do {
+        jsRect = m_jsWindow->call<QRect>("getGeometry");  /* FIXME 鸿蒙接口获取绘制矩形大小错误,临时方法-多次获取并校验 */
+    } while (!jsRect.isValid());
+
+    QRect rect = jsRect;
+    m_frameMargins = readFrameMarginsFromTs();
+    if (parent() == nullptr && !isJsFullScreen()) {
+        if (m_window->hasFrame())
+            rect = jsRect - m_frameMargins;
+    }
+    m_rect = rect;
+
+    qDebug() << "jsRect: " << jsRect << "frameMargins" << m_frameMargins << "qtRect" << rect;
+    return rect;
+}
+
+QPoint QOpenHarmonyJsWindow::mapToGlobal(const QPoint &pos) const
+{
+    return m_window->mapToGlobal(pos);
+}
+
+void QOpenHarmonyJsWindow::setGeometry(const QRect &rect)
+{
+    if (m_rect == rect)
+        return;
+    m_rect = rect;
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    QRect jsRect = rect;
+    if (m_window->hasFrame())
+        jsRect = jsRect + readFrameMarginsFromTs();
+    m_jsWindow->call<bool>("setGeometry", jsRect.x(), jsRect.y(), jsRect.width(), jsRect.height());
+}
+
+void QOpenHarmonyJsWindow::handlePosChange(const QPoint &pos)
+{
+    handleSurfaceChanged();
+}
+
+void QOpenHarmonyJsWindow::handleSurfaceChanged()
+{
+    if (m_window != nullptr) {
+        QMetaObject::invokeMethod(m_window->helper(), "handleGeometryChange");
+    }
+}
+
+void QOpenHarmonyJsWindow::setVisible(bool visible)
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    m_jsWindow->call<bool>("setVisible", visible);
+}
+
+bool QOpenHarmonyJsWindow::isVisible() const
+{
+    if (m_jsWindow.isNull())
+        return false;
+    return m_jsWindow->call<bool>("isVisible");
+}
+
+bool QOpenHarmonyJsWindow::isBusy() const
+{
+    return m_isBusy;
+}
+
+void QOpenHarmonyJsWindow::setBusy(bool busy)
+{
+    m_isBusy = busy;
+}
+
+WId QOpenHarmonyJsWindow::id()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    if (m_xComponentController == nullptr)
+        m_xComponentController = m_jsWindow->callReturnRef("getXComponentController");
+
+    WId ret = reinterpret_cast<WId>(m_xComponentController);
+    return ret;
+}
+
+void QOpenHarmonyJsWindow::setWindowLimits(const QSize &minimumSize, const QSize &maximumSize)
+{
+    if (m_jsWindow.isNull())
+        return;
+    WindowLimits limits;
+    limits.maxWidth = maximumSize.width();
+    limits.maxHeight = maximumSize.height();
+    limits.minWidth = minimumSize.width();
+    limits.minHeight = minimumSize.height();
+    if (m_window->hasFrame()) {
+        QMargins m = readFrameMarginsFromTs();
+        int woff = m.left() + m.right();
+        int hoff = m.top() + m.bottom();
+        limits.maxWidth += woff;
+        limits.minWidth += woff;
+        limits.maxHeight += hoff;
+        limits.minHeight += hoff;
+    }
+    m_jsWindow->call<bool>("setWindowLimits", limits);
+}
+
+bool QOpenHarmonyJsWindow::isJsFullScreen()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    return m_jsWindow->call<bool>("isFullScreen");
+}
+
+void QOpenHarmonyJsWindow::repaint()
+{
+    if (!m_image.isNull()) {
+        m_component->paint(m_image, m_region, m_offset);
+        m_image = QImage();
+        m_region = QRegion();
+        m_offset = QPoint();
+    }
+}
+
+bool QOpenHarmonyJsWindow::raise()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    return m_jsWindow->call<bool>("raise");
+}
+
+bool QOpenHarmonyJsWindow::lower()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    return m_jsWindow->call<bool>("lower");
+}
+
+void QOpenHarmonyJsWindow::showFullScreen()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    m_jsWindow->call<bool>("showFullScreen");
+}
+
+void QOpenHarmonyJsWindow::showMaximized()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    m_jsWindow->call<bool>("showMaximized");
+}
+
+void QOpenHarmonyJsWindow::showMinimized()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    m_jsWindow->call<bool>("showMinimized");
+}
+
+void QOpenHarmonyJsWindow::showNormal()
+{
+    if (m_jsWindow.isNull())
+        m_jsWindow = qJsObjectLoader->create("JsWindow", m_name);
+    m_jsWindow->call<bool>("showNormal");
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyjswindow.h b/src/plugins/platforms/openharmony/qopenharmonyjswindow.h
new file mode 100644
index 0000000000..d8e96c55ff
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyjswindow.h
@@ -0,0 +1,112 @@
+#ifndef QOPENHARMONYJSWINDOW_H
+#define QOPENHARMONYJSWINDOW_H
+
+struct OH_NativeXComponent;
+#include <EGL/egl.h>
+#include <QSharedPointer>
+#include <QMargins>
+#include <QRect>
+#include <QRegion>
+#include <QImage>
+#include <QtGui/qwindowdefs.h>
+#include <napi/native_api.h>
+#include <native_window/external_window.h>
+
+class QImage;
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyJsObject;
+class QOpenHarmonyXComponent;
+class QOpenHarmonyPlatformWindow;
+class InitHelper;
+
+class QOpenHarmonyJsWindow
+{
+public:
+    explicit QOpenHarmonyJsWindow(QOpenHarmonyJsWindow *parent = nullptr);
+    ~QOpenHarmonyJsWindow();
+
+    void setQtWindow(QOpenHarmonyPlatformWindow *window);
+
+    QWindow *qtWindow() const;
+
+    void setName(const QString &name);
+    QString name() const;
+
+    void setVisible(bool visible);
+    bool isVisible() const;
+
+    void setGeometry(const QRect &rect);
+
+    void handlePosChange(const QPoint &pos);
+
+    void handleSurfaceChanged();
+
+    QRect qtGeometry() const;
+
+    void setComponent(QOpenHarmonyXComponent *component);
+
+    void setNativeWindow(OHNativeWindow *nativeWindow);
+
+    OHNativeWindow *nativeWindow() const;
+
+    bool isBusy() const;
+    void setBusy(bool busy);
+
+    OH_NativeXComponent *component() const;
+
+    EGLSurface eglSurface();
+
+    void paint(const QImage &image, const QRegion &region, const QPoint &offset);
+
+    void repaint();
+    QMargins frameMargins() const;
+
+    QMargins readFrameMarginsFromTs() const;
+
+    QOpenHarmonyJsWindow *parent() const;
+    void setParent(QOpenHarmonyJsWindow *parent);
+
+    void setWindowEvent(int event);
+    void handleWindowStatusEvent(int event);
+    void handleRepaintEvent();
+
+    void startListener();
+
+    QRect jsGeometry();
+
+    QPoint mapToGlobal(const QPoint &pos) const;
+
+    WId id();
+    void setWindowLimits(const QSize &minimumSize, const QSize &maximumSize);
+
+    bool raise();
+    bool lower();
+
+    void showFullScreen();
+    void showMaximized();
+    void showMinimized();
+    void showNormal();
+
+private:
+    bool isJsFullScreen();
+private:
+    QOpenHarmonyPlatformWindow *m_window;
+    QOpenHarmonyJsWindow *m_parent;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsWindow;
+    QOpenHarmonyXComponent *m_component;
+    QString m_name;
+    OHNativeWindow *m_nativeWindow = nullptr;
+    bool m_isBusy = false;
+    QRect m_rect;
+    napi_ref m_xComponentController = nullptr;
+    friend class InitHelper;
+    static InitHelper *m_helper;
+    QImage m_image;
+    QRegion m_region;
+    QPoint m_offset;
+    QMargins m_frameMargins;
+};
+Q_DECLARE_METATYPE(QOpenHarmonyJsWindow)
+QT_END_NAMESPACE
+#endif // QOPENHARMONYJSWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyjswindowmanager.cpp b/src/plugins/platforms/openharmony/qopenharmonyjswindowmanager.cpp
new file mode 100644
index 0000000000..8e98e27653
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyjswindowmanager.cpp
@@ -0,0 +1,319 @@
+#include "qopenharmonyjswindowmanager.h"
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyjsenvironment.h"
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyjswindow.h"
+#include "qopenharmonyplatformopenglwindow.h"
+
+#include <ace/xcomponent/native_interface_xcomponent.h>
+
+#include <QTimer>
+#include <QThread>
+#include <QMutexLocker>
+#include <QElapsedTimer>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+
+
+Q_GLOBAL_STATIC(QOpenHarmonyJsWindowManager, manager)
+
+QOpenHarmonyJsWindowManager::QOpenHarmonyJsWindowManager()
+{
+
+}
+
+QOpenHarmonyJsWindowManager::~QOpenHarmonyJsWindowManager()
+{
+    qDeleteAll(m_windows);
+}
+
+static QString windowName()
+{
+    static int index = 1;
+    QString name = QString("openharmony_window_%1").arg(index++);
+    return name;
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyJsWindowManager::createWindow(QOpenHarmonyPlatformWindow *platformWindow)
+{
+    if (platformWindow == nullptr)
+        return nullptr;
+
+    QMutexLocker locker(&m_mutex);
+    QString name = platformWindow->windowName();
+    // 查找window是否已经创建，如果已经创建直接返回
+    QOpenHarmonyJsWindow *jsWindow = window(name);
+    if (jsWindow != nullptr) {
+        setWindow(jsWindow, platformWindow);
+        return jsWindow;
+    }
+
+    // 查找是否有可用的窗口，如果有返回可用的窗口
+    jsWindow = availableWindow();
+    if (jsWindow != nullptr) {
+        setWindow(jsWindow, platformWindow);
+        return jsWindow;
+    }
+
+    // 如果没有，通知js端创建窗口，并等待窗口完成创建
+    name = windowName();
+    LOGW("create open harmony platfrom window for %{public}s", name.toLocal8Bit().constData());
+    checkJsWindowManager();
+    if (m_jsWindowManager.isNull()) {
+        LOGE("get openharmony window manager failed");
+        return nullptr;
+    }
+
+    bool result = m_jsWindowManager->call<bool>("createWindow", name, platformWindow->windowTitle(), platformWindow->isTopLevelWindow(), platformWindow->hasFocus(), platformWindow->hasFrame(), platformWindow->parentWindowName());
+    if (!result) {
+        LOGE("create open harmony platfrom window failed");
+        return nullptr;
+    }
+
+    jsWindow = window(name);
+    if (jsWindow == nullptr) {
+        jsWindow = new QOpenHarmonyJsWindow();
+        jsWindow->setName(name);
+        m_windows << jsWindow;
+    }
+    if (jsWindow != nullptr) {
+        setWindow(jsWindow, platformWindow);
+        return jsWindow;
+    }
+    return jsWindow;
+}
+
+void QOpenHarmonyJsWindowManager::destoryWindow(QOpenHarmonyJsWindow *window)
+{
+    if (QtOpenHarmony::isJsExited())
+        return;
+    if (window == nullptr || !m_windows.contains(window))
+        return;
+    {
+        QMutexLocker locker(&m_windowsMutex);
+        m_windows.removeOne(window);
+    }
+    checkJsWindowManager();
+    bool result = m_jsWindowManager->call<bool>("destroyWindow", window->name());
+    if (!result) {
+        LOGE("destory open harmony platfrom window failed");
+    }
+    window->setBusy(false);
+    delete window;
+}
+
+
+QOpenHarmonyJsWindowManager *QOpenHarmonyJsWindowManager::instance()
+{
+    return manager();
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyJsWindowManager::window(OH_NativeXComponent *component) const
+{
+    return find([component](QOpenHarmonyJsWindow *w){
+        return w->component() == component;
+    });
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyJsWindowManager::window(const QString &name) const
+{
+    return find([name](QOpenHarmonyJsWindow *w){
+        return w->name() == name;
+    });
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyJsWindowManager::availableWindow() const
+{
+    return find([](QOpenHarmonyJsWindow *w){
+        return !w->isBusy();
+    });
+}
+
+bool QOpenHarmonyJsWindowManager::hasWindow(QOpenHarmonyJsWindow *window) const
+{
+    return m_windows.contains(window);
+}
+
+void QOpenHarmonyJsWindowManager::setWindowXComponent(OH_NativeXComponent *component)
+{
+    QMutexLocker locker(&m_mutex);
+    QOpenHarmonyXComponent *xc = new QOpenHarmonyXComponent(component);
+    QString name = xc->name();
+    QOpenHarmonyJsWindow *jsWindow = window(name);
+    if (jsWindow == nullptr) {
+        jsWindow = new QOpenHarmonyJsWindow();
+        m_windows << jsWindow;
+    }
+    xc->setWindow(jsWindow);
+    jsWindow->setComponent(xc);
+    jsWindow->setName(name);
+}
+
+void QOpenHarmonyJsWindowManager::checkJsWindowManager()
+{
+    if (m_jsWindowManager.isNull())
+        m_jsWindowManager = qJsObjectLoader->create("JsWindowManager");
+}
+
+void QOpenHarmonyJsWindowManager::setWindow(QOpenHarmonyJsWindow *jsWindow, QOpenHarmonyPlatformWindow *platformWindow)
+{
+    jsWindow->setQtWindow(platformWindow);
+    jsWindow->setBusy(true);
+    QOpenHarmonyPlatformOpenGLWindow *parent = dynamic_cast<QOpenHarmonyPlatformOpenGLWindow *>(platformWindow->parent());
+    if (parent != nullptr) {
+        jsWindow->setParent(parent->jsWindow());
+    }
+    platformWindow->setWindowName(jsWindow->name());
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyJsWindowManager::find(std::function<bool (QOpenHarmonyJsWindow *)> function) const
+{
+    QMutexLocker locker(const_cast<QMutex *>(&m_windowsMutex));
+    auto it = std::find_if(m_windows.constBegin(), m_windows.constEnd(), function);
+    return it == m_windows.constEnd() ? nullptr : *it;
+}
+
+bool QOpenHarmonyJsWindowManager::wait(int timeout)
+{
+    QElapsedTimer start;
+    start.start();
+    while (!m_jsWindowCreated.loadAcquire()) {
+        QThread::sleep(0);
+        if (start.elapsed() > timeout)
+            return false;
+    }
+    return true;
+}
+
+static napi_value handleJsGeometryChange(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    QString name = qJs::getString(args[0]);
+    QRect rect = qJs::getRect(args[1]);
+    qJsWindowManager->handleGeometryChange(name, rect);
+    return nullptr;
+}
+
+static napi_value handleJsPosChange(napi_env env, napi_callback_info info)
+{
+    size_t argc = 3;
+    napi_value args[3];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 3) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    QString name = qJs::getString(args[0]);
+    int x = qJs::getInt32(args[1]);
+    int y = qJs::getInt32(args[2]);
+    qJsWindowManager->handlePosChange(name, QPoint(x, y));
+    return nullptr;
+}
+
+static napi_value handleJsWindowEvent(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    QString name = qJs::getString(args[0]);
+    int event = qJs::getInt32(args[1]);
+
+    qJsWindowManager->handleWindowEvent(name, event);
+    return nullptr;
+}
+
+static napi_value handleJsWindowStatusEvent(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    QString name = qJs::getString(args[0]);
+    int event = qJs::getInt32(args[1]);
+
+    qJsWindowManager->handleWindowStatusEvent(name, event);
+    return nullptr;
+}
+
+void QOpenHarmonyJsWindowManager::init(napi_env env, napi_value exports)
+{
+    static bool inited = false;
+    if (!inited) {
+        inited = true;
+        napi_property_descriptor desc[] ={
+            DECLARE_NAPI_FUNCTION("handleGeometryChange", handleJsGeometryChange),
+            DECLARE_NAPI_FUNCTION("handleWindowEvent", handleJsWindowEvent),
+            DECLARE_NAPI_FUNCTION("handlePosChange", handleJsPosChange),
+            DECLARE_NAPI_FUNCTION("handleWindowStatusEvent", handleJsWindowStatusEvent),
+        };
+        napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);
+    }
+    napi_value exportInstance = nullptr;
+    OH_NativeXComponent *nativeXComponent = nullptr;
+
+    NAPI_CALL_RETURN_VOID_NO_THROW(env, napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance));
+    NAPI_CALL_RETURN_VOID_NO_THROW(env, napi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent)));
+
+    qJsWindowManager->setWindowXComponent(nativeXComponent);
+}
+
+void QOpenHarmonyJsWindowManager::handleGeometryChange(const QString &name, const QRect &rect)
+{
+    QOpenHarmonyJsWindow *w = window(name);
+    if (w == nullptr)
+        return;
+//    w->handleGeometryChange(rect);
+    w->handleSurfaceChanged();
+}
+
+void QOpenHarmonyJsWindowManager::handlePosChange(const QString &name, const QPoint &pos)
+{
+    QOpenHarmonyJsWindow *w = window(name);
+    if (w == nullptr)
+        return;
+    w->handlePosChange(pos);
+}
+
+void QOpenHarmonyJsWindowManager::handleWindowEvent(const QString &name, int event)
+{
+    QOpenHarmonyJsWindow *w = window(name);
+    if (w == nullptr)
+        return;
+    w->setWindowEvent(event);
+}
+
+void QOpenHarmonyJsWindowManager::handleWindowStatusEvent(const QString &name, int event)
+{
+    QOpenHarmonyJsWindow *w = window(name);
+    if (w == nullptr)
+        return;
+    w->handleWindowStatusEvent(event);
+}
+
+void QOpenHarmonyJsWindowManager::windowCreated()
+{
+    m_jsWindowCreated.storeRelease(true);
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyjswindowmanager.h b/src/plugins/platforms/openharmony/qopenharmonyjswindowmanager.h
new file mode 100644
index 0000000000..8cc43869d9
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyjswindowmanager.h
@@ -0,0 +1,62 @@
+#ifndef QOPENHARMONYJSWINDOWMANAGER_H
+#define QOPENHARMONYJSWINDOWMANAGER_H
+
+#include <QList>
+#include <QHash>
+#include <QSharedPointer>
+#include <QMutex>
+#include <QWaitCondition>
+#include <napi/native_api.h>
+
+class QOpenHarmonyPlatformWindow;
+class QOpenHarmonyJsWindow;
+class QOpenHarmonyJsObject;
+struct OH_NativeXComponent;
+class QOpenHarmonyXComponent;
+
+#define qJsWindowManager QOpenHarmonyJsWindowManager::instance()
+
+class QOpenHarmonyJsWindowManager
+{
+public:
+    QOpenHarmonyJsWindowManager();
+    virtual ~QOpenHarmonyJsWindowManager();
+
+    static QOpenHarmonyJsWindowManager *instance();
+
+    QOpenHarmonyJsWindow *createWindow(QOpenHarmonyPlatformWindow *platformWindow = nullptr);
+
+    void destoryWindow(QOpenHarmonyJsWindow *window);
+
+    QOpenHarmonyJsWindow *window(OH_NativeXComponent *component) const;
+
+    QOpenHarmonyJsWindow *window(const QString &name) const;
+
+    QOpenHarmonyJsWindow *availableWindow() const;
+
+    bool hasWindow(QOpenHarmonyJsWindow *window) const;
+
+    static void init(napi_env env, napi_value exports);
+
+    void handleGeometryChange(const QString &name, const QRect &rect);
+    void handlePosChange(const QString &name, const QPoint &pos);
+
+    void handleWindowEvent(const QString &name, int event);
+    void handleWindowStatusEvent(const QString &name, int event);
+    void windowCreated();
+    void checkJsWindowManager();
+private slots:
+    void setWindowXComponent(OH_NativeXComponent *component);
+    void setWindow(QOpenHarmonyJsWindow *jsWindow, QOpenHarmonyPlatformWindow *platformWindow);
+private:
+    QOpenHarmonyJsWindow *find(std::function<bool(QOpenHarmonyJsWindow *)> function) const;
+    bool wait(int timeout = 2000);
+private:
+    QList<QOpenHarmonyJsWindow *> m_windows;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsWindowManager;
+    QBasicAtomicInt m_jsWindowCreated;
+    QMutex m_mutex;
+    QMutex m_windowsMutex;
+};
+
+#endif // QOPENHARMONYJSWINDOWMANAGER_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonylog.h b/src/plugins/platforms/openharmony/qopenharmonylog.h
new file mode 100644
index 0000000000..1a88d88b24
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonylog.h
@@ -0,0 +1,106 @@
+#ifndef QOPENHARMONYDEFINES_H
+#define QOPENHARMONYDEFINES_H
+#include <hilog/log.h>
+
+#define NAPI_RETVAL_NOTHING
+
+#define GET_AND_THROW_LAST_ERROR(env)                                                                   \
+    do {                                                                                                \
+        const napi_extended_error_info* errorInfo = nullptr;                                            \
+        napi_get_last_error_info((env), &errorInfo);                                                    \
+        bool isPending = false;                                                                         \
+        napi_is_exception_pending((env), &isPending);                                                   \
+        if (!isPending && errorInfo != nullptr) {                                                       \
+            const char* errorMessage =                                                                  \
+                errorInfo->error_message != nullptr ? errorInfo->error_message : "empty error message"; \
+            napi_throw_error((env), nullptr, errorMessage);                                             \
+        }                                                                                               \
+    } while (0)
+
+#define NAPI_ASSERT_BASE(env, assertion, message, retVal)                                    \
+    do {                                                                                     \
+        if (!(assertion)) {                                                                  \
+            napi_throw_error((env), nullptr, "assertion (" #assertion ") failed: " message); \
+            return retVal;                                                                   \
+        }                                                                                    \
+    } while (0)
+
+#define NAPI_ASSERT(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, nullptr)
+
+#define NAPI_ASSERT_RETURN_VOID(env, assertion, message) NAPI_ASSERT_BASE(env, assertion, message, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_BASE(env, theCall, retVal) \
+    do {                                     \
+        if ((theCall) != napi_ok) {          \
+            GET_AND_THROW_LAST_ERROR((env)); \
+            return retVal;                   \
+        }                                    \
+    } while (0)
+
+#define NAPI_CALL_BASE_NO_THROW(env, theCall, retVal) \
+    do {                                     \
+        if ((theCall) != napi_ok) {          \
+            return retVal;                   \
+        }                                    \
+    } while (0)
+
+#define NAPI_CALL(env, theCall) NAPI_CALL_BASE(env, theCall, nullptr)
+
+#define NAPI_CALL_RETURN_VOID(env, theCall) NAPI_CALL_BASE(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define NAPI_CALL_RETURN_VOID_NO_THROW(env, theCall) NAPI_CALL_BASE_NO_THROW(env, theCall, NAPI_RETVAL_NOTHING)
+
+#define DECLARE_NAPI_PROPERTY(name, val)                                       \
+    {                                                                          \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_STATIC_PROPERTY(name, val)                               \
+    {                                                                         \
+        (name), nullptr, nullptr, nullptr, nullptr, val, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION_WITH_DATA(name, func, data)                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, data    \
+    }
+
+#define DECLARE_NAPI_STATIC_FUNCTION(name, func)                                 \
+    {                                                                            \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_static, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER(name, getter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, (getter), nullptr, nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_SETTER(name, setter)                                           \
+    {                                                                               \
+        (name), nullptr, nullptr, nullptr, (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_GETTER_SETTER(name, getter, setter)                             \
+    {                                                                                \
+        (name), nullptr, nullptr, (getter), (setter), nullptr, napi_default, nullptr \
+    }
+
+#define DECLARE_NAPI_FUNCTION(name, func)                                         \
+    {                                                                             \
+        (name), nullptr, (func), nullptr, nullptr, nullptr, napi_default, nullptr \
+    }
+
+
+#define QPA_LOG_DOMAIN 0xff00
+#define QPA_LOG_TAG "QpaForOpenHarmony"
+#define LOGI(...) ((void)OH_LOG_Print(LOG_APP, LOG_INFO, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGD(...) ((void)OH_LOG_Print(LOG_APP, LOG_DEBUG, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGW(...) ((void)OH_LOG_Print(LOG_APP, LOG_WARN, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+#define LOGE(...) ((void)OH_LOG_Print(LOG_APP, LOG_ERROR, QPA_LOG_DOMAIN, QPA_LOG_TAG, __VA_ARGS__))
+
+#endif // QOPENHARMONYDEFINES_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonymain.cpp b/src/plugins/platforms/openharmony/qopenharmonymain.cpp
new file mode 100644
index 0000000000..18becb238f
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonymain.cpp
@@ -0,0 +1,552 @@
+#include <memory>
+#include <dlfcn.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <napi/native_api.h>
+#include <rawfile/raw_file_manager.h>
+
+#include <QDir>
+#include <QHash>
+#include <QString>
+#include <QByteArray>
+#include <QJsonObject>
+#include <QJsonDocument>
+#include <QByteArray>
+#include <QString>
+#include <QStringList>
+#include <QGuiApplication>
+#include <QtCore/private/qopenharmonyhelpers_p.h>
+#include <QOpenHarmonyJsEnvironment>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsObjectLoader>
+
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyfileenginehandler.h"
+#include "qopenharmonyjswindowmanager.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonyplatformdialoghelpers.h"
+#include "qopenharmonyplatformclipboard.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyeventdispatcher.h"
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonyplatformfontdatabase.h"
+
+extern "C" typedef int (*Main)(int, char **); //use the standard main method to start the application
+static Main m_main = nullptr;
+static void *m_mainLibraryHnd = nullptr;
+pthread_t m_qtAppThread = 0;
+static sem_t m_exitSemaphore, m_terminateSemaphore;
+static double m_scaledDensity = 0;
+static double m_density = 1.5;
+static int m_screenWidthPixels  = 0;
+static int m_screenHeightPixels = 0;
+static int m_desktopWidthPixels  = 0;
+static int m_desktopHeightPixels = 0;
+static int m_avoidLeftWidth = 0;
+static int m_avoidTopHeight = 0;
+static NativeResourceManager *m_resourceManager = nullptr;
+static QOpenHarmonyPlatformIntegration *m_platformIntegration = nullptr;
+static QOpenHarmonyFileEngineHandler *m_openHarmonyFileEngineHandler = nullptr;
+static QString m_deviceType = "default";
+static QString m_displayVersion = "";
+static QList<QByteArray> m_applicationParams;
+static bool m_jsAppExited = false;
+static bool m_isTouchPad = false;
+static bool m_defaultShowIsMaximized = false;
+static napi_threadsafe_function g_threadsafe_quit_js_function = nullptr;
+
+static void callQuitJs(napi_env env, napi_value js_cb, void* context, void* data) {
+    Q_UNUSED(env);
+    Q_UNUSED(context);
+    napi_value undefined = nullptr;
+    napi_get_undefined(qJs::env(), &undefined);
+    qJs::callFunction(undefined, js_cb);
+}
+
+static void *startMainMethod(void *arg)
+{
+    QVarLengthArray<const char *> params(m_applicationParams.size());
+
+    for (int i = 0; i < m_applicationParams.size(); i++)
+        params[i] = static_cast<const char *>(m_applicationParams[i].constData());
+
+    int ret = m_main(m_applicationParams.length(), const_cast<char **>(params.data()));
+
+    if (m_mainLibraryHnd) {
+        int res = dlclose(m_mainLibraryHnd);
+        if (res < 0)
+            LOGE("dlclose failed: %{public}s", dlerror());
+    }
+    if (!m_jsAppExited) {
+        napi_acquire_threadsafe_function(g_threadsafe_quit_js_function);
+        napi_call_threadsafe_function(g_threadsafe_quit_js_function, nullptr, napi_tsfn_blocking);
+    }
+    sem_post(&m_terminateSemaphore);
+    sem_wait(&m_exitSemaphore);
+    sem_destroy(&m_exitSemaphore);
+    exit(ret);
+    return 0;
+}
+
+static napi_value startQtApplication(napi_env env, napi_callback_info info)
+{
+    napi_status status;
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return qJs::createBool(false);
+    }
+
+    QString bundleStr = qJs::getObjectPropertyValue<QString>(args[0], "bundleCodeDir");
+    QByteArray bundle = bundleStr.toLatin1();
+    if (bundle.isEmpty()) {
+        LOGE("args is vaild");
+        return qJs::createBool(false);
+    }
+
+#if defined(Q_PROCESSOR_ARM_64)
+    QByteArray libDir = bundle + "/libs/arm64";
+#elif defined(Q_PROCESSOR_ARM_32)
+    QByteArray libDir = bundle + "/libs/arm";
+#endif
+
+    QByteArrayList qmls = {bundle + "/entry/resources/rawfile"};
+    QString cacheQmlStr = qJs::getObjectPropertyValue<QString>(args[0], "qmlDir");
+    if (!cacheQmlStr.isEmpty())
+        qmls << cacheQmlStr.toLatin1();
+
+    QString cacheDir = qJs::getObjectPropertyValue<QString>(args[0], "cacheDir");
+    if (::setenv("QT_HARMONY_CACHE_DIR", cacheDir.toLatin1().constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_HARMONY_CACHE_DIR");
+    }
+
+    if (::setenv("QT_HARMONY_QML_CACHE_DIR", cacheQmlStr.toLatin1().constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_HARMONY_QML_CACHE_DIR");
+    }
+
+    if (::setenv("QT_QPA_PLATFORM_PLUGIN_PATH", libDir.constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_QPA_PLATFORM_PLUGIN_PATH");
+    }
+
+    if (::setenv("QML_DISABLE_DISK_CACHE", "1", 1) != 0) {
+        LOGE("Can't set environment for QML_DISABLE_DISK_CACHE");
+    }
+
+    if (::setenv("QT_PLUGIN_PATH", libDir.constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_PLUGIN_PATH");
+    }
+    QString tempDir = qJs::getObjectPropertyValue<QString>(args[0], "tempDir");
+    qputenv("TMPDIR", tempDir.toLatin1());
+
+    QByteArrayList boundPath = { libDir };
+    QByteArray boundImport = boundPath.join(":");
+    LOGI("harmony boundImport import path: %{public}s", boundImport.data());
+    if (::setenv("QT_HARMONY_BUNDLED_LIBS_PATH", boundImport.constData(), 1) != 0) {
+        LOGE("Can't set environment for QT_HARMONY_BUNDLED_LIBS_PATH");
+    }
+
+    QByteArray qmlImportPath = qmls.join(":");
+    LOGI("qml import path: %{public}s", qmlImportPath.data());
+    if (::setenv("QML2_IMPORT_PATH", qmlImportPath.constData(), 1) != 0) {
+        LOGE("Can't set environment for QML2_IMPORT_PATH");
+    }
+#if 0
+   if (::setenv("QT_DEBUG_PLUGINS", "1", 1) != 0) {
+       LOGE("Can't set environment for QT_DEBUG_PLUGINS");
+   }
+#endif
+    m_mainLibraryHnd = nullptr;
+
+    QByteArray params = qJs::getString(args[1]).toLatin1();
+    m_applicationParams = params.split('\t');
+    if (m_applicationParams.empty()) {
+        LOGE("no qt application specified");
+        return qJs::createBool(false);
+    }
+    QByteArray fileName = m_applicationParams.first();
+    LOGI("load qt application %{public}s", fileName.constData());
+
+    //look for main()
+    // Obtain a handle to the main library (the library that contains the main() function).
+    m_mainLibraryHnd = dlopen(fileName.constData(), 0);
+    if (Q_UNLIKELY(!m_mainLibraryHnd)) {
+        QString error = QString("dlopen failed: %1").arg(dlerror());
+        LOGI("load qt application %{public}s failed%{public}s", fileName.constData(), dlerror());
+        napi_throw_type_error(env, NULL, error.toUtf8().constData());
+        return nullptr;
+    }
+    m_main = (Main)dlsym(m_mainLibraryHnd, "main");
+    if (Q_UNLIKELY(!m_main)) {
+        QString error = QString("dlsym failed: %1, Could not find main method.").arg(dlerror());
+        qJs::throwError(error.toUtf8().constData());
+        return qJs::createBool(false);
+    }
+    if (sem_init(&m_exitSemaphore, 0, 0) == -1)
+        return qJs::createBool(false);
+
+    if (sem_init(&m_terminateSemaphore, 0, 0) == -1)
+        return qJs::createBool(false);
+
+    /* NOTE 事件全部以异步的方式传递 */
+//    QWindowSystemInterface::setSynchronousWindowSystemEvents(false);
+    m_openHarmonyFileEngineHandler = new QOpenHarmonyFileEngineHandler;
+    m_applicationParams[0] = libDir + "/" + fileName;
+    pthread_create(&m_qtAppThread, nullptr, startMainMethod, nullptr);
+    return qJs::createBool(true);
+}
+
+static napi_value setJsQuitFunction(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
+
+    if (argc != 1) {
+        return qJs::createBool(false);
+    }
+
+    napi_value quitJs = args[0];
+    napi_value name_quitJs;
+    napi_create_string_utf8(env, "JsObjectLoader", NAPI_AUTO_LENGTH, &name_quitJs);
+    napi_create_threadsafe_function(qJs::env(), quitJs, nullptr, name_quitJs, 0, 1, nullptr,
+                                                          nullptr, nullptr, callQuitJs, &g_threadsafe_quit_js_function);
+    if (g_threadsafe_quit_js_function != nullptr)
+        return qJs::createBool(true);
+    return qJs::createBool(false);
+}
+
+static napi_value setResourceManager(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_resourceManager = OH_ResourceManager_InitNativeResourceManager(env, args[0]);
+    return nullptr;
+}
+
+static napi_value setDeviceType(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_deviceType = qJs::getString(args[0]);
+    return nullptr;
+}
+
+static napi_value setDisplayVersion(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_displayVersion = qJs::getString(args[0]);
+    return nullptr;
+}
+
+static napi_value setTouchPad(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_isTouchPad = qJs::getBool(args[0]);
+    return nullptr;
+}
+
+static napi_value setDefaultShowIsMaximized(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+    m_defaultShowIsMaximized = qJs::getBool(args[0]);
+    return nullptr;
+}
+
+
+
+static napi_value setDisplayMetrics(napi_env env, napi_callback_info info)
+{
+    size_t argc = 10;
+    napi_value args[10];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 10) {
+        qJs::throwError("Wrong number of arguments");
+        return nullptr;
+    }
+
+    double value[10] = {0};
+    for (size_t i = 0; i < argc; ++i) {
+        value[i] = qJs::getDouble(args[i]);
+    }
+
+    m_screenWidthPixels = static_cast<int>(value[0]);
+    m_screenHeightPixels = static_cast<int>(value[1]);
+
+    m_density = value[2];
+    m_scaledDensity = value[3];
+
+    // openharmony old api, xdpi and ydpi is 0
+    double xdpi = value[4];
+    double ydpi = value[5];
+
+    m_avoidLeftWidth = static_cast<int>(value[6]);
+    m_avoidTopHeight = static_cast<int>(value[7]);
+
+    m_desktopWidthPixels = static_cast<int>(value[8]);
+    m_desktopHeightPixels = static_cast<int>(value[9]);
+
+    m_screenWidthPixels = qMax(m_screenWidthPixels, m_desktopWidthPixels);
+    m_screenHeightPixels = qMax(m_screenHeightPixels, m_desktopHeightPixels);
+
+    if (m_platformIntegration == nullptr) {
+        QOpenHarmonyPlatformIntegration::setDefaultDisplayMetrics(m_avoidLeftWidth, m_avoidTopHeight, m_desktopWidthPixels,
+                                                              m_desktopHeightPixels,
+                                                              qRound(double(m_screenWidthPixels)  / xdpi * 25.4),
+                                                              qRound(double(m_screenHeightPixels) / ydpi * 25.4),
+                                                              m_screenWidthPixels,
+                                                              m_screenHeightPixels);
+    } else {
+        m_platformIntegration->setDisplayMetrics(qRound(double(m_screenWidthPixels)  / xdpi * 25.4),
+                                                        qRound(double(m_screenHeightPixels) / ydpi * 25.4));
+        m_platformIntegration->setScreenSize(m_screenWidthPixels, m_screenHeightPixels);
+        m_platformIntegration->setDesktopSize(m_avoidLeftWidth, m_avoidTopHeight, m_desktopWidthPixels, m_desktopHeightPixels);
+    }
+    return nullptr;
+}
+
+static napi_value updateApplicationState(napi_env env, napi_callback_info info)
+{
+    if (!m_main || !m_platformIntegration) {
+        return nullptr;
+    }
+
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 1) {
+        qJs::throwError("Wrong number of arguments in updateApplicationState");
+        return nullptr;
+    }
+
+    Qt::ApplicationState qtState = Qt::ApplicationSuspended;
+
+//    Openharmony doc
+//    SHOWN = 1,
+//    ACTIVE,
+//    INACTIVE,
+//    HIDDEN
+
+    int32_t state = qJs::getInt32(args[0]);
+    switch (state) {
+    case 1:
+        qtState = Qt::ApplicationActive;
+        break;
+    case 2:
+        qtState = Qt::ApplicationActive;
+        break;
+    case 3:
+        qtState = Qt::ApplicationInactive;
+        break;
+    case 4:
+        qtState = Qt::ApplicationSuspended;
+    }
+
+    if (qtState == Qt::ApplicationActive)
+        QtHarmonyPrivate::handleResume();
+    else if (state == Qt::ApplicationInactive)
+        QtHarmonyPrivate::handlePause();
+
+    if (qtState <= Qt::ApplicationInactive) {
+        // NOTE: sometimes we will receive two consecutive suspended notifications,
+        // In the second suspended notification, QWindowSystemInterface::flushWindowSystemEvents()
+        // will deadlock since the dispatcher has been stopped in the first suspended notification.
+        // To avoid the deadlock we simply return if we found the event dispatcher has been stopped.
+        if (QOpenHarmonyEventDispatcherStopper::instance()->stopped())
+            return nullptr;
+
+        // Don't send timers and sockets events anymore if we are going to hide all windows
+        QOpenHarmonyEventDispatcherStopper::instance()->goingToStop(true);
+        QWindowSystemInterface::handleApplicationStateChanged(qtState);
+        if (state == Qt::ApplicationSuspended)
+            QOpenHarmonyEventDispatcherStopper::instance()->stopAll();
+    } else {
+        QOpenHarmonyEventDispatcherStopper::instance()->startAll();
+        QWindowSystemInterface::handleApplicationStateChanged(qtState);
+        QOpenHarmonyEventDispatcherStopper::instance()->goingToStop(false);
+    }
+    return nullptr;
+}
+
+static napi_value quitQtApplication(napi_env env, napi_callback_info info)
+{
+    if (m_openHarmonyFileEngineHandler != nullptr) {
+        delete m_openHarmonyFileEngineHandler;
+        m_openHarmonyFileEngineHandler = nullptr;
+    }
+    LOGI("quit qt application");
+    m_jsAppExited = true;
+    OH_ResourceManager_ReleaseNativeResourceManager(m_resourceManager);
+    qJs::quit();
+    qApp->quit();
+    return nullptr;
+}
+
+static napi_value qtMajorVersion(napi_env env, napi_callback_info info)
+{
+    return qJs::createInt32(QT_VERSION_MAJOR);
+}
+
+/*
+ * function for module exports
+ */
+EXTERN_C_START
+static napi_value Init(napi_env env, napi_value exports)
+{
+    static bool inited = false;
+    QOpenHarmonyJsWindowManager::init(env, exports);
+    if (!inited) {
+        napi_property_descriptor desc[] ={
+            DECLARE_NAPI_FUNCTION("startQtApplication", startQtApplication),
+            DECLARE_NAPI_FUNCTION("setDisplayMetrics", setDisplayMetrics),
+            DECLARE_NAPI_FUNCTION("updateApplicationState", updateApplicationState),
+            DECLARE_NAPI_FUNCTION("setResourceManager", setResourceManager),
+            DECLARE_NAPI_FUNCTION("quitQtApplication", quitQtApplication),
+            DECLARE_NAPI_FUNCTION("qtMajorVersion", qtMajorVersion),
+            DECLARE_NAPI_FUNCTION("setDeviceType", setDeviceType),
+            DECLARE_NAPI_FUNCTION("setDisplayVersion", setDisplayVersion),
+            DECLARE_NAPI_FUNCTION("setJsQuitFunction", setJsQuitFunction),
+            DECLARE_NAPI_FUNCTION("setTouchPad", setTouchPad),
+            DECLARE_NAPI_FUNCTION("setDefaultShowIsMaximized", setDefaultShowIsMaximized)
+        };
+        NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+        QOpenHarmonyPlatformInputContext::init(env, exports);
+        QOpenHarmonyPlatformFontDatabase::init(env, exports);
+//        QOpenHarmonyPlatformMessageDialogHelper::init(env, exports);
+        QOpenHarmonyPlatformFileDialogHelper::init(env, exports);
+
+#ifndef QT_NO_CLIPBOARD
+        QOpenHarmonyPlatformClipboard::init(env, exports);
+#endif
+        qJs::init(env);
+        inited = true;
+    }
+    return exports;
+}
+EXTERN_C_END
+
+/*
+ * Napi Module define
+ */
+static napi_module openharmonyPluginModule = {
+    .nm_version = 1,
+    .nm_flags = 0,
+    .nm_filename = nullptr,
+    .nm_register_func = Init,
+    .nm_modname = "plugins_platforms_qopenharmony",
+    .nm_priv = ((void*)0),
+    .reserved = { 0 },
+};
+/*
+ * Module register function
+ */
+extern "C" __attribute__((constructor)) void RegisterModule(void)
+{
+    napi_module_register(&openharmonyPluginModule);
+}
+
+double QtOpenHarmony::scaledDensity()
+{
+    return m_scaledDensity;
+}
+
+double QtOpenHarmony::pixelDensity()
+{
+    return m_density;
+}
+
+void QtOpenHarmony::setOpenHarmonyPlatformIntegration(QOpenHarmonyPlatformIntegration *integration)
+{
+    m_platformIntegration = integration;
+}
+
+void QtOpenHarmony::updateDisplayMetrics(int w, int h)
+{
+    m_screenWidthPixels = w;
+    m_screenHeightPixels = h;
+    if (m_platformIntegration != nullptr)
+        m_platformIntegration->setScreenSize(w, h);
+}
+
+NativeResourceManager *QtOpenHarmony::resourceManager()
+{
+    return m_resourceManager;
+}
+
+bool QtOpenHarmony::isPhone()
+{
+    return m_deviceType == "default";
+}
+
+QOpenHarmonyPlatformIntegration *QtOpenHarmony::openharmonyPlatformIntegration()
+{
+    return m_platformIntegration;
+}
+
+QMargins QtOpenHarmony::frameMargins()
+{
+    if (isPhone())
+        return QMargins();
+    // Todo read from js
+    return QMargins(6, 48, 6, 6);
+}
+
+#include <QRegExp>
+QString QtOpenHarmony::displayVersion()
+{
+    //    HYM-W5821 2.0.0.66(SP59DEVC00E66R1P4log)
+    QRegExp regex("(\\d+\\.\\d+\\.\\d+\\.\\d+)");
+    if (regex.indexIn(m_displayVersion) != -1) {
+        QString version = regex.cap(1);
+        return version;
+    };
+    return m_displayVersion;
+}
+
+bool QtOpenHarmony::isTouchPad()
+{
+    return m_isTouchPad;
+}
+
+bool QtOpenHarmony::defaultShowIsMaximized()
+{
+    return m_defaultShowIsMaximized;
+}
+
+bool QtOpenHarmony::isJsExited()
+{
+    return m_jsAppExited;
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonymain.h b/src/plugins/platforms/openharmony/qopenharmonymain.h
new file mode 100644
index 0000000000..13dc6d0cd2
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonymain.h
@@ -0,0 +1,35 @@
+#ifndef QOPENHARMONYMAIN_H
+#define QOPENHARMONYMAIN_H
+
+#include <napi/native_api.h>
+#include <QMargins>
+
+class QOpenHarmonyPlatformIntegration;
+struct NativeResourceManager;
+
+namespace QtOpenHarmony {
+
+void setOpenHarmonyPlatformIntegration(QOpenHarmonyPlatformIntegration *integration);
+
+double scaledDensity();
+
+double pixelDensity();
+
+QMargins frameMargins();
+
+void updateDisplayMetrics(int w, int h);
+bool isPhone();
+
+QString displayVersion();
+
+bool isTouchPad();
+
+bool defaultShowIsMaximized();
+
+bool isJsExited();
+
+NativeResourceManager *resourceManager();
+QOpenHarmonyPlatformIntegration *openharmonyPlatformIntegration();
+}
+
+#endif //QOPENHARMONYMAIN_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.cpp
new file mode 100644
index 0000000000..29ee0182a6
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.cpp
@@ -0,0 +1,65 @@
+#include <QPainter>
+#include <qpa/qplatformscreen.h>
+
+#include "qopenharmonylog.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformopenglwindow.h"
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformBackingStore::QOpenHarmonyPlatformBackingStore(QWindow *window)
+    : QPlatformBackingStore(window)
+{
+    if (window->handle())
+        setBackingStore(window);
+}
+
+QPaintDevice *QOpenHarmonyPlatformBackingStore::paintDevice()
+{
+    return &m_image;
+}
+
+void QOpenHarmonyPlatformBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+{
+    Q_UNUSED(offset);
+
+    if (!m_backingStoreSet)
+        setBackingStore(window);
+
+    (static_cast<QOpenHarmonyPlatformOpenGLWindow *>(window->handle()))->paint(m_image, region, offset);
+}
+
+void QOpenHarmonyPlatformBackingStore::resize(const QSize &size, const QRegion &staticContents)
+{
+    if (m_image.isNull() || m_image.size() != size) {
+        QImage::Format format = window()->screen()->handle()->format();
+
+        QImage oldImage  = m_image;
+        QImage newImage(size.width(), size.height(), format);
+
+        if (!oldImage.isNull() && !staticContents.isEmpty()) {
+            QRegion staticRegion(staticContents);
+            staticRegion &= QRect(0, 0, oldImage.width(), oldImage.height());
+            staticRegion &= QRect(0, 0, newImage.width(), newImage.height());
+            QPainter painter(&newImage);
+            painter.setCompositionMode(QPainter::CompositionMode_Source);
+            for (const QRect &rect : staticRegion)
+                painter.drawImage(rect, oldImage, rect);
+        }
+
+        m_image = newImage;
+    }
+}
+
+void QOpenHarmonyPlatformBackingStore::setBackingStore(QWindow *window)
+{
+    if (window->surfaceType() == QSurface::RasterSurface || window->surfaceType() == QSurface::RasterGLSurface) {
+        (static_cast<QOpenHarmonyPlatformWindow *>(window->handle()))->setBackingStore(this);
+        m_backingStoreSet = true;
+    } else {
+        LOGW("QOpenHarmonyPlatformBackingStore does not support OpenGL-only windows.");
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.h b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.h
new file mode 100644
index 0000000000..db75831b39
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformbackingstore.h
@@ -0,0 +1,25 @@
+#ifndef QOPENHARMONYPLATFORMBACKINGSTORE_H
+#define QOPENHARMONYPLATFORMBACKINGSTORE_H
+
+#include <qpa/qplatformbackingstore.h>
+#include <qpa/qwindowsysteminterface.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformBackingStore : public QPlatformBackingStore
+{
+public:
+    explicit QOpenHarmonyPlatformBackingStore(QWindow *window);
+    QPaintDevice *paintDevice() override;
+    void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
+    void resize(const QSize &size, const QRegion &staticContents) override;
+    QImage toImage() const override { return m_image; }
+    void setBackingStore(QWindow *window);
+protected:
+    QImage m_image;
+    bool m_backingStoreSet = false;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMBACKINGSTORE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.cpp
new file mode 100644
index 0000000000..c045275ed0
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.cpp
@@ -0,0 +1,218 @@
+#include "qopenharmonyplatformclipboard.h"
+#include "qopenharmonymain.h"
+#include "qopenharmonyjsobjectloader.h"
+
+#include <QImage>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+
+#include <QTimer>
+#include <QThread>
+#include <QImage>
+#include <QUrl>
+#include <QBuffer>
+#include <QByteArray>
+
+#ifndef QT_NO_CLIPBOARD
+
+#define qClipBoard QOpenHarmonyPlatformClipboard::instance()
+
+
+struct JsImage {
+    int w;
+    int h;
+    QByteArray buffer;
+};
+
+static QVariant jsImage2QVariant(napi_value value)
+{
+    int64_t w = qJs::getInt64(qJs::objectPropertyValue(value, "w"));
+    int64_t h = qJs::getInt64(qJs::objectPropertyValue(value, "h"));
+    QByteArray buffer = qJs::getByteArray(qJs::objectPropertyValue(value, "buffer"));
+    JsImage result;
+    result.w = w;
+    result.h = h;
+    result.buffer = buffer;
+    return QVariant::fromValue(result);
+}
+
+Q_DECLARE_METATYPE(JsImage)
+
+QOpenHarmonyPlatformClipboard *QOpenHarmonyPlatformClipboard::m_self = nullptr;
+
+static napi_value pasteChanged(napi_env env, napi_callback_info info)
+{
+    Q_UNUSED(env)
+    Q_UNUSED(info)
+/* FIXME 会引起崩溃 */
+#if 0
+    if (qClipBoard)
+        qClipBoard->emitChanged(QClipboard::Clipboard);
+#endif
+
+    return nullptr;
+}
+
+
+napi_value QOpenHarmonyPlatformClipboard::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("pasteChanged", pasteChanged),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+
+    return nullptr;
+}
+
+QOpenHarmonyPlatformClipboard::QOpenHarmonyPlatformClipboard()
+{
+    m_self = this;
+    m_jsClipboard = qJsObjectLoader->create("JsPasteBoard");
+    qRegisterMetaType<JsImage>();
+
+    std::function<QVariant(napi_value)> js2qt = jsImage2QVariant;
+    qJs::registerQVariantCreator<JsImage>(js2qt);
+}
+
+QOpenHarmonyPlatformClipboard::~QOpenHarmonyPlatformClipboard()
+{
+    m_self = nullptr;
+}
+
+QOpenHarmonyPlatformClipboard *QOpenHarmonyPlatformClipboard::instance()
+{
+    return m_self;
+}
+
+QMimeData *QOpenHarmonyPlatformClipboard::mimeData(QClipboard::Mode mode)
+{
+    Q_UNUSED(mode);
+    Q_ASSERT(supportsMode(mode));
+    m_mimeData.clear();
+
+    if (hasClipboardUri()) {
+        QStringList uris = clipboardUri();
+        QList<QUrl> urls;
+        for (int i = 0; i < uris.count(); ++i) {
+            urls << QUrl(uris.at(i));
+        }
+        m_mimeData.setUrls(urls);
+    }
+
+    if (hasClipboardText()) {
+        m_mimeData.setText(clipboardText());
+    }
+    if (hasClipboardHtml()) {
+        m_mimeData.setHtml(clipboardHtml());
+    }
+    if (hasClipboardPixelMap()) {
+        JsImage jsImage = clipboardPixelMap();
+        if (jsImage.w != 0 && jsImage.h != 0 && !jsImage.buffer.isEmpty()) {
+            QImage image(reinterpret_cast<uchar *>(jsImage.buffer.data()), jsImage.w, jsImage.h, QImage::Format_RGBA8888);
+            // openharmony is GBRA
+            image = image.rgbSwapped();
+            //image.save("/storage/Users/currentUser/Images/wh_copy_test.png");
+            m_mimeData.setImageData(image);
+        }
+    }
+    return &m_mimeData;
+}
+
+void QOpenHarmonyPlatformClipboard::setMimeData(QMimeData *data, QClipboard::Mode mode)
+{
+    if (!supportsMode(mode)) {
+        if (data != 0)
+            data->deleteLater();
+        return;
+    }
+
+    if (data == nullptr) {
+        m_jsClipboard->call<bool>("clearData");
+        return;
+    }
+
+    if (supportsMode(mode)) {
+        m_jsClipboard->call<bool>("clearData");
+        if (data->hasUrls()) {
+            QList<QUrl> urls = data->urls();
+            for (const auto &u : qAsConst(urls)) {
+                m_jsClipboard->call<bool>("setClipboardUri", u.toString());
+            }
+        }
+        if (data->hasText()) {
+            m_jsClipboard->call<bool>("setClipboardText", data->text());
+        }
+        if (data->hasHtml()) {
+            m_jsClipboard->call<bool>("setClipboardHtml", data->html());
+        }
+        if (data->hasImage()) {
+            QImage image = qvariant_cast<QImage>(data->imageData());
+            QImage::Format fm = image.format();
+            if (fm >= QImage::Format_RGB32 && fm != QImage::Format_RGBA8888)
+                image = image.convertToFormat(QImage::Format_RGBA8888);
+
+            int width = image.width();
+            int height = image.height();
+
+            int bytesPerPixel = image.depth() / 8;
+            int bytesPerLine = image.bytesPerLine();
+
+            QByteArray byteArray;
+            byteArray.resize(width * height * bytesPerPixel);
+
+            for (int y = 0; y < height; ++y) {
+                const uchar* line = image.constScanLine(y);
+                memcpy(byteArray.data() + y * bytesPerLine, line, bytesPerLine);
+            }
+            m_jsClipboard->call<bool>("setClipboardPixelMap", byteArray, image.width(), image.height());
+        }
+    }
+}
+
+bool QOpenHarmonyPlatformClipboard::supportsMode(QClipboard::Mode mode) const
+{
+    return QClipboard::Clipboard == mode;
+}
+
+bool QOpenHarmonyPlatformClipboard::hasClipboardText()
+{
+    return m_jsClipboard->call<bool>("hasClipboardText");
+}
+
+QString QOpenHarmonyPlatformClipboard::clipboardText()
+{
+    return m_jsClipboard->call<QString>("clipboardText");
+}
+
+bool QOpenHarmonyPlatformClipboard::hasClipboardPixelMap()
+{
+    return m_jsClipboard->call<bool>("hasClipboardPixelMap");
+}
+
+JsImage QOpenHarmonyPlatformClipboard::clipboardPixelMap()
+{
+    return m_jsClipboard->call<JsImage>("clipboardPixelMap");
+}
+
+bool QOpenHarmonyPlatformClipboard::hasClipboardUri()
+{
+    return m_jsClipboard->call<bool>("hasClipboardUri");
+}
+
+QStringList QOpenHarmonyPlatformClipboard::clipboardUri()
+{
+    return m_jsClipboard->call<QStringList>("clipboardUri");
+}
+
+bool QOpenHarmonyPlatformClipboard::hasClipboardHtml()
+{
+    return m_jsClipboard->call<bool>("hasClipboardHtml");
+}
+
+QString QOpenHarmonyPlatformClipboard::clipboardHtml()
+{
+    return m_jsClipboard->call<QString>("clipboardHtml");
+}
+
+#endif // QT_NO_CLIPBOARD
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.h b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.h
new file mode 100644
index 0000000000..07cfb40c98
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformclipboard.h
@@ -0,0 +1,46 @@
+#ifndef QOPENHARMONYPLATFORMCLIPBOARD_H
+#define QOPENHARMONYPLATFORMCLIPBOARD_H
+
+#include <qpa/qplatformclipboard.h>
+#include <QMimeData>
+#include <QSharedPointer>
+#include <napi/native_api.h>
+
+#ifndef QT_NO_CLIPBOARD
+class QOpenHarmonyJsObject;
+struct JsImage;
+
+class QOpenHarmonyPlatformClipboard: public QPlatformClipboard
+{
+public:
+    QOpenHarmonyPlatformClipboard();
+    ~QOpenHarmonyPlatformClipboard();
+    static QOpenHarmonyPlatformClipboard *instance();
+
+    QMimeData *mimeData(QClipboard::Mode mode = QClipboard::Clipboard) override;
+    void setMimeData(QMimeData *data, QClipboard::Mode mode = QClipboard::Clipboard) override;
+    bool supportsMode(QClipboard::Mode mode) const override;
+
+    bool hasClipboardText();
+    QString clipboardText();
+
+    bool hasClipboardPixelMap();
+    JsImage clipboardPixelMap();
+
+    bool hasClipboardUri();
+
+    QStringList clipboardUri();
+
+    bool hasClipboardHtml();
+
+    QString clipboardHtml();
+    static napi_value init(napi_env env, napi_value exports);
+private:
+    QMimeData m_mimeData;
+    static QOpenHarmonyPlatformClipboard *m_self;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsClipboard;
+};
+
+#endif // QT_NO_CLIPBOARD
+
+#endif // QOPENHARMONYPLATFORMCLIPBOARD_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformcursor.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformcursor.cpp
new file mode 100644
index 0000000000..ad6dd380b5
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformcursor.cpp
@@ -0,0 +1,151 @@
+#include "qopenharmonyplatformcursor.h"
+#include "qopenharmonyplatformwindow.h"
+#include <QtCore/qopenharmonydefines.h>
+#include <QCursor>
+#include <QPixmap>
+#include <QImage>
+#include <QByteArray>
+#include <QBuffer>
+#include <QIODevice>
+
+QT_BEGIN_NAMESPACE
+
+
+QOpenHarmonyPlatformCursor::QOpenHarmonyPlatformCursor(const QPlatformScreen *screen)
+    : m_screen(screen)
+{
+    m_jsCursor = qJsObjectLoader->create("JsCursor");
+}
+
+void QOpenHarmonyPlatformCursor::changeCursor(QCursor *windowCursor, QWindow *window)
+{
+    if (nullptr == windowCursor)
+        return;
+
+    if (m_jsCursor.isNull())
+    {
+        m_jsCursor = qJsObjectLoader->create("JsCursor");
+    }
+
+    Qt::CursorShape cursorShape = windowCursor->shape();
+    LOGI("changeCursor:cursorShape-->%{public}d", cursorShape);
+    int pointerStyle = DEFAULT;
+    switch(cursorShape)
+    {
+    case Qt::ArrowCursor:
+        pointerStyle = DEFAULT;
+        break;
+    case Qt::UpArrowCursor:
+        pointerStyle = NORTH;
+        break;
+    case Qt::CrossCursor:
+        pointerStyle = CROSS;
+        break;
+    case Qt::WaitCursor:
+        pointerStyle = LOADING;
+        break;
+    case Qt::IBeamCursor:
+        pointerStyle = TEXT_CURSOR;
+        break;
+    case Qt::SizeVerCursor:
+        pointerStyle = NORTH_SOUTH;
+        break;
+    case Qt::SizeHorCursor:
+        pointerStyle = WEST_EAST;
+        break;
+    case Qt::SizeBDiagCursor:
+        pointerStyle = NORTH_EAST_SOUTH_WEST;
+        break;
+    case Qt::SizeFDiagCursor:
+        pointerStyle = NORTH_WEST_SOUTH_EAST;
+        break;
+    case Qt::SizeAllCursor:
+        pointerStyle = MOVE;
+        break;
+    //todo:空白光标（隐藏）
+    case Qt::BlankCursor:
+        pointerStyle = DEFAULT;
+        break;
+    case Qt::SplitVCursor:
+        pointerStyle = RESIZE_UP_DOWN;
+        break;
+    case Qt::SplitHCursor:
+        pointerStyle = RESIZE_LEFT_RIGHT;
+        break;
+    case Qt::PointingHandCursor:
+        pointerStyle = HAND_POINTING;
+        break;
+            case Qt::ForbiddenCursor:
+        pointerStyle = CURSOR_FORBID;
+        break;
+    case Qt::WhatsThisCursor:
+        pointerStyle = HELP;
+        break;
+    //todo：鸿蒙没有类型的样式，暂时用”加载中“样式
+    case Qt::BusyCursor:
+        pointerStyle = LOADING;
+        break;
+    case Qt::OpenHandCursor:
+        pointerStyle = HAND_OPEN;
+        break;
+    case Qt::ClosedHandCursor:
+        pointerStyle = HAND_GRABBING;
+        break;
+    //todo：鸿蒙没有类型的样式，暂时用”默认“样式
+    case Qt::DragCopyCursor:
+        pointerStyle = DEFAULT;
+        break;
+    //todo：鸿蒙没有类型的样式，暂时用”默认“样式
+    case Qt::DragMoveCursor:
+        pointerStyle = DEFAULT;
+        break;
+    //todo：鸿蒙没有类型的样式，暂时用”默认“样式
+    case Qt::DragLinkCursor:
+        pointerStyle = DEFAULT;
+        break;
+       //自定义样式
+    case Qt::BitmapCursor:
+    case Qt::CustomCursor:
+        pointerStyle = CUSTOM;
+        break;
+    default:
+        pointerStyle = DEFAULT;
+        break;
+    }
+
+    QOpenHarmonyPlatformWindow *win = QOpenHarmonyPlatformWindow::get(window);
+    if(!win) return;
+
+    if (pointerStyle == CUSTOM) {
+        QImage image = windowCursor->pixmap().toImage();
+        QByteArray byteArray;
+        QBuffer buffer(&byteArray);
+        buffer.open(QIODevice::WriteOnly);
+        image.save(&buffer, "PNG");
+        buffer.close();
+        m_jsCursor->callWithoutReturn("setCustomCursorStyle", byteArray, image.width(), image.height(), windowCursor->hotSpot().x(), windowCursor->hotSpot().y());
+    } else {
+        m_jsCursor->callWithoutReturn("setPointerStyle", (int)pointerStyle, win->windowName());
+    }
+}
+
+void QOpenHarmonyPlatformCursor::setOverrideCursor(const QCursor &cursor)
+{
+    LOGI("setOverrideCursor:cursorShape-->%{public}d", cursor.shape());
+    QImage image = cursor.pixmap().toImage();
+    QByteArray byteArray;
+    QBuffer buffer(&byteArray);
+    buffer.open(QIODevice::WriteOnly);
+    image.save(&buffer, "PNG");
+    buffer.close();
+    m_jsCursor->callWithoutReturn("setCustomCursorStyle", byteArray, image.width(), image.height(), cursor.hotSpot().x(), cursor.hotSpot().y());
+}
+
+
+void QOpenHarmonyPlatformCursor::clearOverrideCursor()
+{
+
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformcursor.h b/src/plugins/platforms/openharmony/qopenharmonyplatformcursor.h
new file mode 100644
index 0000000000..48f5f0144e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformcursor.h
@@ -0,0 +1,78 @@
+
+#ifndef QOPENHARMONYPLATFORMCURSOR_H
+#define QOPENHARMONYPLATFORMCURSOR_H
+
+#include <qpa/qplatformcursor.h>
+#include <QtCore/qsharedpointer.h>
+#include <QtCore/qhash.h>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsObjectLoader>
+
+QT_BEGIN_NAMESPACE
+
+
+enum HarmonyPointerStyle{
+    DEFAULT,
+    EAST,
+    WEST,
+    SOUTH,
+    NORTH,
+    WEST_EAST,
+    NORTH_SOUTH,
+    NORTH_EAST,
+    NORTH_WEST,
+    SOUTH_EAST,
+    SOUTH_WEST,
+    NORTH_EAST_SOUTH_WEST,
+    NORTH_WEST_SOUTH_EAST,
+    CROSS,
+    CURSOR_COPY,
+    CURSOR_FORBID,
+    COLOR_SUCKER,
+    HAND_GRABBING,
+    HAND_OPEN,
+    HAND_POINTING,
+    HELP,
+    MOVE,
+    RESIZE_LEFT_RIGHT,
+    RESIZE_UP_DOWN,
+    SCREENSHOT_CHOOSE,
+    SCREENSHOT_CURSOR,
+    TEXT_CURSOR,
+    ZOOM_IN,
+    ZOOM_OUT,
+    MIDDLE_BTN_EAST,
+    MIDDLE_BTN_WEST,
+    MIDDLE_BTN_SOUTH,
+    MIDDLE_BTN_NORTH,
+    MIDDLE_BTN_NORTH_SOUTH,
+    MIDDLE_BTN_NORTH_EAST,
+    MIDDLE_BTN_NORTH_WEST,
+    MIDDLE_BTN_SOUTH_EAST,
+    MIDDLE_BTN_SOUTH_WEST,
+    MIDDLE_BTN_NORTH_SOUTH_WEST_EAST,
+    HORIZONTAL_TEXT_CURSOR,
+    CURSOR_CROSS,
+    CURSOR_CIRCLE,
+    LOADING,
+    RUNNING,
+    CUSTOM=99
+};
+
+class QOpenHarmonyPlatformCursor : public QPlatformCursor
+{
+public:
+    explicit QOpenHarmonyPlatformCursor(const QPlatformScreen *screen);
+
+    void changeCursor(QCursor * widgetCursor, QWindow * widget) override;
+    void setOverrideCursor(const QCursor &cursor) override;
+    void clearOverrideCursor() override;
+
+private:
+    const QPlatformScreen *const m_screen;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsCursor;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMCURSOR_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.cpp
new file mode 100644
index 0000000000..e002376aca
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.cpp
@@ -0,0 +1,329 @@
+#include "qopenharmonymain.h"
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonyplatformdialoghelpers.h"
+
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+#ifdef OH_URI
+#include <filemanagement/file_uri/oh_file_uri.h>
+#endif
+
+#include <QTimer>
+#include <QRegExp>
+#include <QStringList>
+#include <QTextDocument>
+#include <qpa/qplatformtheme.h>
+#include <private/qguiapplication_p.h>
+
+void QWaiter::wait(int timeout)
+{
+    if (timeout != -1)
+        QTimer::singleShot(timeout, &m_loop, &QEventLoop::quit);
+    m_loop.exec();
+}
+
+void QWaiter::cancelWait()
+{
+    if (m_loop.isRunning())
+        m_loop.exit();
+}
+
+QOpenHarmonyPlatformMessageDialogHelper::QOpenHarmonyPlatformMessageDialogHelper()
+    : m_buttonId(-1)
+    , m_shown(false)
+{
+    m_jsDialog = qJsObjectLoader->create("JsDialog");
+}
+
+QOpenHarmonyPlatformMessageDialogHelper::~QOpenHarmonyPlatformMessageDialogHelper()
+{
+
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::exec()
+{
+    if (!m_shown)
+        show(Qt::Dialog, Qt::ApplicationModal, 0);
+     wait(-1);
+}
+
+static QString htmlText(QString text)
+{
+    if (Qt::mightBeRichText(text))
+        return text;
+    text.remove(QLatin1Char('\r'));
+    return text.toHtmlEscaped().replace(QLatin1Char('\n'), QLatin1String("<br />"));
+}
+
+bool QOpenHarmonyPlatformMessageDialogHelper::show(Qt::WindowFlags windowFlags
+                                         , Qt::WindowModality windowModality
+                                         , QWindow *parent)
+{
+    if (m_shown)
+        return true;
+    Q_UNUSED(windowFlags)
+    Q_UNUSED(windowModality)
+    Q_UNUSED(parent)
+    if (m_jsDialog.isNull())
+        return false;
+    QSharedPointer<QMessageDialogOptions> opt = options();
+    if (!opt.data())
+        return false;
+
+    m_buttons.clear();
+    m_buttonIds.clear();
+    const int * currentLayout = buttonLayout(Qt::Horizontal);
+    while (*currentLayout != QPlatformDialogHelper::EOL) {
+        int role = (*currentLayout & ~QPlatformDialogHelper::Reverse);
+        addButtons(opt, static_cast<ButtonRole>(role));
+        ++currentLayout;
+    }
+
+    QString text = htmlText(opt->text());
+    QString str = htmlText(opt->informativeText());
+    if (!str.isEmpty())
+        text += str;
+    str = htmlText(opt->detailedText());
+    if (!str.isEmpty())
+        text += str;
+
+    m_jsDialog->callWithoutReturn("messageBox", QVariant(qlonglong(static_cast<QObject*>(this))), htmlText(opt->windowTitle()), text, m_buttons);
+    m_shown = true;
+    return true;
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::addButtons(QSharedPointer<QMessageDialogOptions> opt, ButtonRole role)
+{
+    for (const QMessageDialogOptions::CustomButton &b : opt->customButtons()) {
+        if (b.role == role) {
+            QString label = b.label;
+            label.remove(QChar('&'));
+            m_buttons << label;
+            m_buttonIds << b.id;
+        }
+    }
+
+    for (int i = QPlatformDialogHelper::FirstButton; i < QPlatformDialogHelper::LastButton; i<<=1) {
+        StandardButton b = static_cast<StandardButton>(i);
+        if (buttonRole(b) == role && (opt->standardButtons() & i)) {
+            const QString text = QGuiApplicationPrivate::platformTheme()->standardButtonText(b);
+            m_buttons << text;
+            m_buttonIds << i;
+        }
+    }
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::hide()
+{
+    m_shown = false;
+}
+
+void QOpenHarmonyPlatformMessageDialogHelper::setDialogResult(int buttonID)
+{
+    m_buttonId = buttonID;
+    cancelWait();
+    if (m_buttonId < 0) {
+        emit reject();
+        return;
+    }
+
+    int realId = m_buttonIds.at(m_buttonId);
+    QPlatformDialogHelper::StandardButton standardButton = static_cast<QPlatformDialogHelper::StandardButton>(realId);
+    QPlatformDialogHelper::ButtonRole role = QPlatformDialogHelper::buttonRole(standardButton);
+    if (buttonID > QPlatformDialogHelper::LastButton) {
+        const QMessageDialogOptions::CustomButton *custom = options()->customButton(buttonID);
+        Q_ASSERT(custom);
+        role = custom->role;
+    }
+    emit clicked(standardButton, role);
+}
+
+static napi_value dialogResult(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    int32_t value1 = qJs::getInt32(args[1]);
+
+
+    QObject *object = reinterpret_cast<QObject *>(value0);
+    QMetaObject::invokeMethod(object, "setDialogResult", Qt::QueuedConnection, Q_ARG(int, value1));
+    return nullptr;
+}
+
+napi_value QOpenHarmonyPlatformMessageDialogHelper::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("dialogResult", dialogResult),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+    return nullptr;
+}
+
+static napi_value selectedFilesResult(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+    int64_t value0 = qJs::getInt64(args[0]);
+    QStringList value1 = qJs::getStringList(args[1]);
+
+
+    QObject *object = reinterpret_cast<QObject *>(value0);
+    QMetaObject::invokeMethod(object, "setFileResult", Qt::QueuedConnection, Q_ARG(QStringList, value1));
+
+    return nullptr;
+}
+
+napi_value QOpenHarmonyPlatformFileDialogHelper::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("selectedFilesResult", selectedFilesResult),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+    return nullptr;
+}
+
+QOpenHarmonyPlatformFileDialogHelper::QOpenHarmonyPlatformFileDialogHelper()
+    : m_shown(false)
+{
+    m_jsDialog = qJsObjectLoader->create("JsDialog");
+}
+
+QOpenHarmonyPlatformFileDialogHelper::~QOpenHarmonyPlatformFileDialogHelper()
+{
+}
+
+bool QOpenHarmonyPlatformFileDialogHelper::defaultNameFilterDisables() const
+{
+    return true;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::setDirectory(const QUrl &directory)
+{
+    m_dir = directory;
+}
+
+QUrl QOpenHarmonyPlatformFileDialogHelper::directory() const
+{
+    return m_dir;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::selectFile(const QUrl &filename)
+{
+    m_saveFile = filename.toLocalFile();
+    if (m_saveFile.contains("/")) {
+        int index = m_saveFile.lastIndexOf("/");
+        m_saveFile = m_saveFile.right(m_saveFile.length() - index - 1);
+    }
+}
+
+QList<QUrl> QOpenHarmonyPlatformFileDialogHelper::selectedFiles() const
+{
+    QList<QUrl> result;
+    for (int i = 0; i < m_files.count(); ++i) {
+        const QUrl &url = QUrl(m_files.at(i));
+#ifdef OH_URI
+        const QString &path = url.toString();
+
+        char *data = nullptr;
+        const char *cpath = path.toLocal8Bit().constData();
+#if 0
+        bool valid = OH_FileUri_IsValidUri(cpath, path.length());
+#endif
+        FileManagement_ErrCode errCode = OH_FileUri_GetPathFromUri(cpath, path.length(), &data);
+        if (ERR_OK == errCode && nullptr != data) {
+            result << QUrl::fromLocalFile(QString::fromLocal8Bit(data));
+            free(data);
+        } else {
+            // file://docs/storage/Users/currentUser/xxx/  多了一个docs取消            
+            result << QUrl::fromLocalFile(url.path());
+        }
+#else
+        result << QUrl::fromLocalFile(url.path());
+#endif
+    }
+    QSharedPointer<QFileDialogOptions> opt = options();
+    if (opt.data()) {
+        bool save = (opt->acceptMode() == QFileDialogOptions::AcceptSave);
+        if (save) {
+            // 等待js端把文件创建出来，100可调整
+            QThread::msleep(100);
+        }
+    }
+    return result;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::setFilter()
+{
+
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::selectNameFilter(const QString &filter)
+{
+    m_filter = filter;
+}
+
+QString QOpenHarmonyPlatformFileDialogHelper::selectedNameFilter() const
+{
+    return m_filter;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::exec()
+{
+    if (!m_shown)
+        show(Qt::Dialog, Qt::ApplicationModal, nullptr);
+    wait(-1);
+}
+
+bool QOpenHarmonyPlatformFileDialogHelper::show(Qt::WindowFlags windowFlags, Qt::WindowModality windowModality, QWindow *parent)
+{
+    if (m_shown)
+        return true;
+    Q_UNUSED(windowModality)
+    if (m_jsDialog.isNull())
+        return false;
+    QSharedPointer<QFileDialogOptions> opt = options();
+    if (!opt.data())
+        return false;
+    bool open = (opt->acceptMode() == QFileDialogOptions::AcceptOpen);
+    if (open)
+        m_jsDialog->callWithoutReturn("openFileDialog", QVariant(qlonglong(static_cast<QObject*>(this))),
+                                      opt->nameFilters(), int(opt->fileMode()), m_dir.path());
+    else
+        m_jsDialog->callWithoutReturn("saveFileDialog", QVariant(qlonglong(static_cast<QObject*>(this))),
+                                      m_saveFile, opt->nameFilters());
+    m_shown = true;
+    return true;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::hide()
+{
+    m_shown = false;
+}
+
+void QOpenHarmonyPlatformFileDialogHelper::setFileResult(const QStringList &file)
+{
+    m_files.clear();
+    if (!file.isEmpty()) {
+        m_files << file;
+    }
+    cancelWait();
+    if (m_files.isEmpty())
+        emit reject();
+    else
+        emit accept();
+}
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.h b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.h
new file mode 100644
index 0000000000..5f5fd94f92
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformdialoghelpers.h
@@ -0,0 +1,87 @@
+#ifndef QOPENHARMONYPLATFORMDIALOGHELPERS_H
+#define QOPENHARMONYPLATFORMDIALOGHELPERS_H
+
+#include <qpa/qplatformdialoghelper.h>
+#include <napi/native_api.h>
+
+#include <QList>
+#include <QSharedPointer>
+#include <QEventLoop>
+
+class QOpenHarmonyJsObject;
+
+class QWaiter
+{
+public:
+    QWaiter() {}
+
+    void wait(int timeout = 1000);
+    void cancelWait();
+private:
+    QEventLoop m_loop;
+};
+
+class QOpenHarmonyPlatformMessageDialogHelper: public QPlatformMessageDialogHelper, public QWaiter
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformMessageDialogHelper();
+    ~QOpenHarmonyPlatformMessageDialogHelper();
+    void exec() override;
+    bool show(Qt::WindowFlags windowFlags,
+              Qt::WindowModality windowModality,
+              QWindow *parent) override;
+    void hide() override;
+
+    static napi_value init(napi_env env, napi_value exports);
+
+public slots:
+    void setDialogResult(int buttonID);
+
+private:
+    void addButtons(QSharedPointer<QMessageDialogOptions> opt, ButtonRole role);
+
+private:
+    int m_buttonId;
+    bool m_shown;
+    QStringList m_buttons;
+    QList<int> m_buttonIds;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsDialog;
+};
+
+class QOpenHarmonyPlatformFileDialogHelper: public QPlatformFileDialogHelper, public QWaiter
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformFileDialogHelper();
+    ~QOpenHarmonyPlatformFileDialogHelper();
+
+    virtual bool defaultNameFilterDisables() const override;
+    virtual void setDirectory(const QUrl &directory) override;
+    virtual QUrl directory() const override;
+    virtual void selectFile(const QUrl &filename) override;
+    virtual QList<QUrl> selectedFiles() const override;
+    virtual void setFilter() override;
+    virtual void selectNameFilter(const QString &filter) override;
+    virtual QString selectedNameFilter() const override;
+
+    virtual void exec() override;
+    virtual bool show(Qt::WindowFlags windowFlags,
+                          Qt::WindowModality windowModality,
+                          QWindow *parent) override;
+    virtual void hide() override;
+
+public slots:
+    void setFileResult(const QStringList &file);
+
+    static napi_value init(napi_env env, napi_value exports);
+private:
+    bool m_shown;
+    QStringList m_files;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsDialog;
+    QString m_saveFile;
+    QUrl m_dir;
+    QString m_filter;
+};
+
+#endif // QOPENHARMONYPLATFORMDIALOGHELPERS_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.cpp
new file mode 100644
index 0000000000..7c2de5f765
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.cpp
@@ -0,0 +1,82 @@
+#include <QDir>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+
+#include "qopenharmonyplatformfontdatabase.h"
+
+static QStringList gs_fonts;
+
+/* 通过鸿蒙ts接口查询系统提供的字体路径
+ * 然后传入C++端使用
+ */
+static napi_value setFontInfos(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    if (gs_fonts.isEmpty())
+        gs_fonts = qJs::getStringList(args[0]);
+
+    return Q_NULLPTR;
+}
+
+QT_BEGIN_NAMESPACE
+
+QString QOpenHarmonyPlatformFontDatabase::fontDir() const
+{
+    /* FIMXE 鸿蒙权限收紧,读取该目录会提示读取失败 */
+    return QLatin1String("/system/fonts");
+}
+
+void QOpenHarmonyPlatformFontDatabase::populateFontDatabase()
+{
+#if 1
+    /* FIXME
+     * 使用鸿蒙ts端查询到的字体路径
+     * 否则,扫描fontDir路径中的字体文件
+     * (该操作因为鸿蒙系统权限收紧会提示读取目录失败的警告)
+     */
+    if (!gs_fonts.isEmpty()) {
+        for (const QString &f : qAsConst(gs_fonts)) {
+            const QByteArray file = QFile::encodeName(f);
+            QFreeTypeFontDatabase::addTTFile(QByteArray(), file);
+        }
+        return;
+    }
+#endif
+    QString fontpath = fontDir();
+    QDir dir(fontpath);
+
+    if (Q_UNLIKELY(!dir.exists())) {
+        LOGW("QFontDatabase: Cannot find font directory %{public}s - is Qt installed correctly?",
+               qPrintable(fontpath));
+        //Todo Qt使用_stat函数获取状态信息时返回-1，权限被拒绝.但是使用entryInfoList能够列出目录下的字体
+    }
+
+    QStringList nameFilters;
+    nameFilters << QLatin1String("*.ttf")
+                << QLatin1String("*.otf")
+                << QLatin1String("*.ttc");    
+    const auto entries = dir.entryInfoList(nameFilters, QDir::Files);    
+    for (const QFileInfo &fi : entries) {        
+        const QByteArray file = QFile::encodeName(fi.absoluteFilePath());
+        QFreeTypeFontDatabase::addTTFile(QByteArray(), file);
+    }    
+}
+
+napi_value QOpenHarmonyPlatformFontDatabase::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("setFontInfos", setFontInfos),
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+    return nullptr;
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.h b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.h
new file mode 100644
index 0000000000..bfad0a18a1
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformfontdatabase.h
@@ -0,0 +1,19 @@
+#ifndef QOPENHARMONYPLATFORMFONTDATABASE_H
+#define QOPENHARMONYPLATFORMFONTDATABASE_H
+
+#include <napi/native_api.h>
+#include <QtFontDatabaseSupport/private/qfreetypefontdatabase_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformFontDatabase: public QFreeTypeFontDatabase
+{
+public:    
+    QString fontDir() const override;
+    void populateFontDatabase() override;
+    static napi_value init(napi_env env, napi_value exports);
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMFONTDATABASE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.cpp
new file mode 100644
index 0000000000..4f018d4bae
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.cpp
@@ -0,0 +1,65 @@
+#include <adapter_c.h>
+#include <QtCore/qvariant.h>
+#include <QtGui/qopenharmonywindowadapter.h>
+#include <qpa/qwindowsysteminterface.h>
+
+#include "qopenharmonylog.h"
+#include "qopenharmonyplatformforeignwindow.h"
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformForeignWindow::QOpenHarmonyPlatformForeignWindow(QWindow *window, WId nativeHandle)
+    : QOpenHarmonyPlatformWindow(window),
+      m_surfaceId(-1)
+{
+    setWId(nativeHandle);
+}
+
+QOpenHarmonyPlatformForeignWindow::~QOpenHarmonyPlatformForeignWindow()
+{
+
+}
+
+void QOpenHarmonyPlatformForeignWindow::lower()
+{
+    if (m_surfaceId == -1)
+        return;
+
+    QOpenHarmonyPlatformWindow::lower();
+}
+
+void QOpenHarmonyPlatformForeignWindow::raise()
+{
+    if (m_surfaceId == -1)
+        return;
+
+    QOpenHarmonyPlatformWindow::raise();
+}
+
+void QOpenHarmonyPlatformForeignWindow::setGeometry(const QRect &rect)
+{
+    QOpenHarmonyPlatformWindow::setGeometry(rect);
+}
+
+void QOpenHarmonyPlatformForeignWindow::setVisible(bool visible)
+{
+}
+
+void QOpenHarmonyPlatformForeignWindow::applicationStateChanged(Qt::ApplicationState state)
+{
+    QOpenHarmonyPlatformWindow::applicationStateChanged(state);
+}
+
+void QOpenHarmonyPlatformForeignWindow::setParent(const QPlatformWindow *window)
+{
+    Q_UNUSED(window);
+    LOGW("<--------LLLLL:::wanghao");
+    if (nullptr == window)
+        return;
+
+    bool result = QOpenHarmonyWindowAdapter::ReParentNode(window->winId(), this->winId());
+    if (!result)
+        LOGW("set window:%{public}d, parent:%{public}d, fail", this, window);
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.h b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.h
new file mode 100644
index 0000000000..e792d1a019
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformforeignwindow.h
@@ -0,0 +1,27 @@
+#ifndef QOPENHARMONYPLATFORMFOREIGNWINDOW_H
+#define QOPENHARMONYPLATFORMFOREIGNWINDOW_H
+
+#include "qopenharmonyplatformwindow.h"
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformForeignWindow : public QOpenHarmonyPlatformWindow
+{
+public:
+    explicit QOpenHarmonyPlatformForeignWindow(QWindow *window, WId nativeHandle);
+    ~QOpenHarmonyPlatformForeignWindow() override;
+    void lower() override;
+    void raise() override;
+    void setGeometry(const QRect &rect) override;
+    void setVisible(bool visible) override;
+    void applicationStateChanged(Qt::ApplicationState state) override;
+    void setParent(const QPlatformWindow *window) override;
+    bool isForeignWindow() const override { return true; }
+
+private:
+    int m_surfaceId;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMFOREIGNWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.cpp
new file mode 100644
index 0000000000..436f5914ea
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.cpp
@@ -0,0 +1,1538 @@
+#include "qopenharmonymain.h"
+#include "qopenharmonyjsobjectloader.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyjswindowmanager.h"
+#include "qopenharmonyjswindow.h"
+
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsEnvironment>
+#include <QtCore/qopenharmonydefines.h>
+
+#include <qevent.h>
+#include <qmetaobject.h>
+#include <qguiapplication.h>
+#include <qsharedpointer.h>
+#include <qthread.h>
+#include <qinputmethod.h>
+#include <qwindow.h>
+#include <private/qhighdpiscaling_p.h>
+
+#include <QTextCharFormat>
+#include <QTextBoundaryFinder>
+#include <qpa/qplatformintegration.h>
+#include <qpa/qwindowsysteminterface.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace {
+
+class BatchEditLock
+{
+public:
+
+    explicit BatchEditLock(QOpenHarmonyPlatformInputContext *context)
+        : m_context(context)
+    {
+        m_context->beginBatchEdit();
+    }
+
+    ~BatchEditLock()
+    {
+        m_context->endBatchEdit();
+    }
+
+    BatchEditLock(const BatchEditLock &) = delete;
+    BatchEditLock &operator=(const BatchEditLock &) = delete;
+
+private:
+
+    QOpenHarmonyPlatformInputContext *m_context;
+};
+
+} // namespace anonymous
+
+struct KeyRecord {
+    KeyRecord(int c, int a, int s, const QString &t) : code(c), ascii(a), state(s), text(t) {}
+    KeyRecord() {}
+
+    int code;
+    int ascii;
+    int state;
+    QString text;
+};
+
+// We need to record the pressed keys in order to decide, whether the key event is an autorepeat
+// event. As soon as its state changes, the chain of autorepeat events will be broken.
+static const int QT_MAX_KEY_RECORDINGS = 64; // User has LOTS of fingers...
+struct KeyRecorder
+{
+    inline KeyRecord *findKey(int code, bool remove);
+    inline void storeKey(int code, int ascii, int state, const QString& text);
+    inline void clearKeys();
+
+    int nrecs = 0;
+    KeyRecord deleted_record; // A copy of last entry removed from records[]
+    KeyRecord records[QT_MAX_KEY_RECORDINGS];
+};
+static KeyRecorder key_recorder;
+
+static void clearKeyRecorderOnApplicationInActive(Qt::ApplicationState state)
+{
+    if (state == Qt::ApplicationInactive)
+        key_recorder.clearKeys();
+}
+
+KeyRecord *KeyRecorder::findKey(int code, bool remove)
+{
+    KeyRecord *result = nullptr;
+    for (int i = 0; i < nrecs; ++i) {
+        if (records[i].code == code) {
+            if (remove) {
+                deleted_record = records[i];
+                // Move rest down, and decrease count
+                while (i + 1 < nrecs) {
+                    records[i] = records[i + 1];
+                    ++i;
+                }
+                --nrecs;
+                result = &deleted_record;
+            } else {
+                result = &records[i];
+            }
+            break;
+        }
+    }
+    return result;
+}
+
+void KeyRecorder::storeKey(int code, int ascii, int state, const QString& text)
+{
+    Q_ASSERT_X(nrecs != QT_MAX_KEY_RECORDINGS,
+               "Internal KeyRecorder",
+               "Keyboard recorder buffer overflow, consider increasing QT_MAX_KEY_RECORDINGS");
+
+    if (nrecs == QT_MAX_KEY_RECORDINGS) {
+        qWarning("Qt: Internal keyboard buffer overflow");
+        return;
+    }
+    records[nrecs++] = KeyRecord(code,ascii,state,text);
+}
+
+void KeyRecorder::clearKeys()
+{
+    nrecs = 0;
+}
+
+/*!
+ * \brief Qt-鸿蒙平台下的输入类型枚举值映射
+ * \param hints Qt下的枚举值
+ * \return 返回Qt-鸿蒙的输入类型映射值
+ */
+static int harmonyTextInputType(Qt::InputMethodHints hints)
+{
+    /* FIXME Qt支持位运算,鸿蒙文本类型不支持位运算的枚举值 */
+    if(hints.testFlag(Qt::ImhMultiLine))    /* 多行文本类型 */
+        return 1;
+    if (hints.testFlag(Qt::ImhPreferNumbers) ||
+        hints.testFlag(Qt::ImhDigitsOnly))   /* 数字类型 */
+        return 2;
+    if (hints.testFlag(Qt::ImhDate) ||
+        hints.testFlag(Qt::ImhTime))    /* 日期类型 */
+        return 4;
+    if (hints.testFlag(Qt::ImhHiddenText))  /* 密码类型 */
+        return 7;
+    if ((hints.testFlag(Qt::ImhDigitsOnly) |
+         hints.testFlag(Qt::ImhFormattedNumbersOnly)) &&
+        hints.testFlag(Qt::ImhHiddenText))  /* 数字密码类型 */
+        return 8;
+    if (hints.testFlag(Qt::ImhDialableCharactersOnly)) /* 电话号码类型 */
+        return 3;
+    if (hints.testFlag(Qt::ImhEmailCharactersOnly)) /* 邮箱地址类型 */
+        return 5;
+    if (hints.testFlag(Qt::ImhUrlCharactersOnly))   /* 链接类型 */
+        return 6;
+
+    return 0; /* 默认文本类型 */
+}
+/*!
+ * \brief Qt-鸿蒙平台下的EnterKey功能值映射
+ * \param type Qt下的EnterKey功能枚举值
+ * \return 返回Qt-鸿蒙的EnterKey功能映射值
+ */
+static int harmonyEnterKeyType(Qt::EnterKeyType type)
+{
+    switch (type) {
+    case Qt::EnterKeyDone:
+    case Qt::EnterKeyDefault:
+        return 6;
+    case Qt::EnterKeyReturn:
+    case Qt::EnterKeyPrevious:
+        return 7;
+    case Qt::EnterKeyGo: return 2;
+    case Qt::EnterKeySend: return 4;
+    case Qt::EnterKeySearch: return 3;
+    case Qt::EnterKeyNext:return 5;
+    default: break;
+    }
+    return 0;
+}
+
+static QOpenHarmonyPlatformInputContext *m_openHarmonyInputContext = 0;
+
+static napi_value sendEnterKey(napi_env env, napi_callback_info info)
+{
+    size_t argc = 1;
+    napi_value args[1];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 1) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    QObject *object = reinterpret_cast<QObject *>(value0);
+
+    QMetaObject::invokeMethod(object, "enterKeyDown", Qt::QueuedConnection);
+    return Q_NULLPTR;
+}
+
+static napi_value insertText(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    QString value1 = qJs::getString(args[1]);
+    QObject *object = reinterpret_cast<QObject *>(value0);
+
+    QMetaObject::invokeMethod(object, "commitText", Qt::QueuedConnection, Q_ARG(QString, value1));
+    return Q_NULLPTR;
+}
+
+static napi_value deleteLeft(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    int32_t value1 = qJs::getInt32(args[1]);
+    QObject *object = reinterpret_cast<QObject *>(value0);
+
+    QMetaObject::invokeMethod(object, "deleteSurroundingText", Qt::QueuedConnection,
+                              Q_ARG(int, int(value1)), Q_ARG(int, 0));
+    return Q_NULLPTR;
+}
+
+static napi_value deleteRight(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    int32_t value1 = qJs::getInt32(args[1]);
+    QObject *object = reinterpret_cast<QObject *>(value0);
+
+    QMetaObject::invokeMethod(object, "deleteSurroundingText", Qt::QueuedConnection,
+                              Q_ARG(int, 0), Q_ARG(int, int(value1)));
+
+    return Q_NULLPTR;
+}
+static napi_value moveCursor(napi_env env, napi_callback_info info)
+{
+    size_t argc = 2;
+    napi_value args[2];
+    NAPI_CALL(env, napi_get_cb_info(env, info, &argc, args, nullptr, nullptr));
+    if (argc != 2) {
+        napi_throw_type_error(env, NULL, "Wrong number of arguments");
+        return nullptr;
+    }
+
+    int64_t value0 = qJs::getInt64(args[0]);
+    int32_t value1 = qJs::getInt32(args[1]);
+    QObject *object = reinterpret_cast<QObject *>(value0);
+
+    QMetaObject::invokeMethod(object, "commitMoveCursor", Qt::QueuedConnection,
+                              Q_ARG(int, int(value1)));
+
+    return Q_NULLPTR;
+}
+
+
+// cursor position getter that also works with editors that have not been updated to the new API
+static inline int getAbsoluteCursorPosition(const QSharedPointer<QInputMethodQueryEvent> &query)
+{
+    QVariant absolutePos = query->value(Qt::ImAbsolutePosition);
+    return absolutePos.isValid() ? absolutePos.toInt() : query->value(Qt::ImCursorPosition).toInt();
+}
+
+// position of the start of the current block
+static inline int getBlockPosition(const QSharedPointer<QInputMethodQueryEvent> &query)
+{
+    QVariant absolutePos = query->value(Qt::ImAbsolutePosition);
+    return  absolutePos.isValid() ? absolutePos.toInt() - query->value(Qt::ImCursorPosition).toInt() : 0;
+}
+
+napi_value QOpenHarmonyPlatformInputContext::init(napi_env env, napi_value exports)
+{
+    napi_property_descriptor desc[] ={
+        DECLARE_NAPI_FUNCTION("insertText", insertText),
+        DECLARE_NAPI_FUNCTION("moveCursor", moveCursor),
+        DECLARE_NAPI_FUNCTION("deleteLeft", deleteLeft),
+        DECLARE_NAPI_FUNCTION("deleteRight", deleteRight),
+        DECLARE_NAPI_FUNCTION("sendEnterKey", sendEnterKey)
+    };
+    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));
+    return nullptr;
+}
+
+Qt::KeyboardModifiers QOpenHarmonyPlatformInputContext::queryKeyboardModifiers() const
+{
+    Qt::KeyboardModifiers mods(Qt::NoModifier);
+    for (Qt::KeyboardModifier m : qAsConst(m_mpd))
+        mods |= m;
+
+    return mods;
+}
+
+void QOpenHarmonyPlatformInputContext::updateCursorPosition()
+{
+    // qWarning() << "<--------------::::" << Q_FUNC_INFO;
+}
+
+void QOpenHarmonyPlatformInputContext::touchDown(float x, float y)
+{
+
+}
+
+void QOpenHarmonyPlatformInputContext::handleMouseEvent(const OpenHarmonyMouseEvent &event)
+{
+    QOpenHarmonyJsWindow *window = qJsWindowManager->window(event.component);
+    if (window == nullptr)
+        return;
+    if (event.type == QEvent::MouseMove) {
+        mouseMove(window, event.x, event.y, event.btn);
+    } else if (event.type == QEvent::MouseButtonPress) {
+        mousePress(window, event.x, event.y, event.btn);
+    } else if (event.type == QEvent::MouseButtonRelease) {
+        mouseRelease(window, event.x, event.y, event.btn);
+    }
+    QWindowSystemInterface::flushWindowSystemEvents();
+}
+
+void QOpenHarmonyPlatformInputContext::wheelEvent(const OpenHarmonyWheelEvent &event)
+{
+    QOpenHarmonyJsWindow *window = qJsWindowManager->window(event.component);
+    if (window == nullptr || m_ignoreMouseEvents)
+        return;
+    QPoint global = event.global;
+    QPoint pixelDelta = event.pixelDelta;
+    Qt::KeyboardModifiers mods = event.mods;
+
+    QWindow *tlw = m_mouseGrabber.data();
+    if (!tlw)
+        tlw = window->qtWindow();
+    QPoint localPos = tlw ? tlw->mapFromGlobal(global) : global;
+    QWindowSystemInterface::handleWheelEvent(tlw, localPos, global, pixelDelta,
+                                             QPoint(pixelDelta.x()*8, pixelDelta.y()*8), mods);
+}
+
+void QOpenHarmonyPlatformInputContext::mouseMove(QOpenHarmonyJsWindow *window, float x, float y, Qt::MouseButton button)
+{
+    if (window == nullptr || m_ignoreMouseEvents)
+        return;
+
+    QPoint globalPos(x,y);
+    QWindow *tlw = m_mouseGrabber.data();
+    if (!tlw)
+        tlw = window->qtWindow();
+    QPoint localPos = tlw ? tlw->mapFromGlobal(globalPos) : globalPos;
+    QWindowSystemInterface::handleMouseEvent(tlw, localPos, globalPos,
+                                             Qt::MouseButtons(m_mouseGrabber ? Qt::LeftButton : Qt::NoButton),
+                                             button, QEvent::MouseMove, queryKeyboardModifiers());
+}
+
+void QOpenHarmonyPlatformInputContext::mousePress(QOpenHarmonyJsWindow *window, float x, float y, Qt::MouseButton button)
+{
+    if (window == nullptr || m_ignoreMouseEvents)
+        return;
+
+    QPoint globalPos(x,y);
+    m_mouseGrabber = window->qtWindow();
+    QPoint localPos = m_mouseGrabber ? m_mouseGrabber->mapFromGlobal(globalPos) : globalPos;
+    QWindowSystemInterface::handleMouseEvent(m_mouseGrabber.data(), localPos, globalPos,
+                                             Qt::MouseButtons(button),
+                                             button, QEvent::MouseButtonPress, queryKeyboardModifiers());
+}
+
+void QOpenHarmonyPlatformInputContext::mouseRelease(QOpenHarmonyJsWindow *window, float x, float y, Qt::MouseButton button)
+{
+    if (window == nullptr || m_ignoreMouseEvents)
+        return;
+
+    QPoint globalPos(x,y);
+    QWindow *tlw = m_mouseGrabber.data();
+    if (!tlw)
+        tlw = window->qtWindow();
+    QPoint localPos = tlw ? tlw->mapFromGlobal(globalPos) : globalPos;
+    QWindowSystemInterface::handleMouseEvent(tlw, localPos, globalPos,
+                                             Qt::MouseButtons(Qt::NoButton),
+                                             button, QEvent::MouseButtonRelease, queryKeyboardModifiers());
+    m_mouseGrabber = 0;
+}
+
+void QOpenHarmonyPlatformInputContext::handleKeyEvent(const OpenHarmonyKeyEvent &event)
+{
+    QOpenHarmonyJsWindow *jsWindow = qJsWindowManager->window(event.component);
+    if (jsWindow == nullptr)
+        return;
+
+    QWindow *window = jsWindow->qtWindow();
+    OH_NativeXComponent_KeyCode code = event.code;
+    OH_NativeXComponent_KeyAction action = event.action;
+    OH_NativeXComponent_EventSourceType stype = event.stype;
+    static QHash<OH_NativeXComponent_KeyAction, QEvent::Type> sKeyType{
+                                                                         { OH_NATIVEXCOMPONENT_KEY_ACTION_DOWN, QEvent::KeyPress },
+                                                                         { OH_NATIVEXCOMPONENT_KEY_ACTION_UP, QEvent::KeyRelease },
+                                                                         };
+
+
+    static QHash<OH_NativeXComponent_KeyCode, Qt::Key> sKeyMap{
+        { KEY_HOME, Qt::Key_Home },
+        { KEY_BACK, Qt::Key_Back },
+        { KEY_MEDIA_PLAY_PAUSE, Qt::Key_MediaTogglePlayPause },
+        { KEY_MEDIA_STOP, Qt::Key_MediaStop },
+        { KEY_MEDIA_NEXT, Qt::Key_MediaNext },
+        { KEY_MEDIA_PREVIOUS, Qt::Key_MediaPrevious },
+        { KEY_MEDIA_REWIND, Qt::Key_AudioRewind },
+        { KEY_MEDIA_FAST_FORWARD, Qt::Key_AudioForward },
+        { KEY_VOLUME_UP, Qt::Key_VolumeUp },
+        { KEY_VOLUME_DOWN, Qt::Key_VolumeDown },
+        { KEY_POWER, Qt::Key_PowerDown },
+        { KEY_CAMERA, Qt::Key_Camera },
+        { KEY_VOLUME_MUTE, Qt::Key_VolumeMute },
+        { KEY_MUTE, Qt::Key_MicMute },
+        { KEY_BRIGHTNESS_UP, Qt::Key_MonBrightnessUp },
+        { KEY_BRIGHTNESS_DOWN, Qt::Key_MonBrightnessDown },
+        { KEY_0, Qt::Key_0 },
+        { KEY_1, Qt::Key_1 },
+        { KEY_2, Qt::Key_2 },
+        { KEY_3, Qt::Key_3 },
+        { KEY_4, Qt::Key_4 },
+        { KEY_5, Qt::Key_5 },
+        { KEY_6, Qt::Key_6 },
+        { KEY_7, Qt::Key_7 },
+        { KEY_8, Qt::Key_8 },
+        { KEY_9, Qt::Key_9 },
+        { KEY_STAR, Qt::Key_Asterisk },
+        { KEY_POUND, Qt::Key_NumberSign },
+        { KEY_DPAD_UP, Qt::Key_Up },
+        { KEY_DPAD_DOWN, Qt::Key_Down },
+        { KEY_DPAD_LEFT, Qt::Key_Left },
+        { KEY_DPAD_RIGHT, Qt::Key_Right },
+        //{ KEY_DPAD_CENTER, Qt::Key_ },
+        { KEY_A, Qt::Key_A },
+        { KEY_B, Qt::Key_B },
+        { KEY_C, Qt::Key_C },
+        { KEY_D, Qt::Key_D },
+        { KEY_E, Qt::Key_E },
+        { KEY_F, Qt::Key_F },
+        { KEY_G, Qt::Key_G },
+        { KEY_H, Qt::Key_H },
+        { KEY_I, Qt::Key_I },
+        { KEY_J, Qt::Key_J },
+        { KEY_K, Qt::Key_K },
+        { KEY_L, Qt::Key_L },
+        { KEY_M, Qt::Key_M },
+        { KEY_N, Qt::Key_N },
+        { KEY_O, Qt::Key_O },
+        { KEY_P, Qt::Key_P },
+        { KEY_Q, Qt::Key_Q },
+        { KEY_R, Qt::Key_R },
+        { KEY_S, Qt::Key_S },
+        { KEY_T, Qt::Key_T },
+        { KEY_U, Qt::Key_U },
+        { KEY_V, Qt::Key_V },
+        { KEY_W, Qt::Key_W },
+        { KEY_X, Qt::Key_X },
+        { KEY_Y, Qt::Key_Y },
+        { KEY_Z, Qt::Key_Z },
+        { KEY_COMMA, Qt::Key_Comma },
+        { KEY_PERIOD, Qt::Key_Period },
+        { KEY_ALT_LEFT, Qt::Key_Alt },
+        { KEY_ALT_RIGHT, Qt::Key_Alt },
+        { KEY_SHIFT_LEFT, Qt::Key_Shift },
+        { KEY_SHIFT_RIGHT, Qt::Key_Shift },
+        { KEY_TAB, Qt::Key_Tab  },
+        { KEY_SPACE, Qt::Key_Space },
+        //{ KEY_SYM, Qt::KEY_},
+        { KEY_EXPLORER, Qt::Key_Explorer },
+        //{ KEY_ENVELOPE, Qt::Key_ },
+        { KEY_ENTER, Qt::Key_Enter },
+        { KEY_DEL, Qt::Key_Back },
+        { KEY_GRAVE, Qt::Key_Apostrophe },
+        { KEY_MINUS, Qt::Key_Minus },
+        { KEY_EQUALS, Qt::Key_Equal },
+        { KEY_LEFT_BRACKET, Qt::Key_BracketLeft },
+        { KEY_RIGHT_BRACKET, Qt::Key_BracketRight },
+        { KEY_BACKSLASH, Qt::Key_Backslash },
+        { KEY_SEMICOLON, Qt::Key_Semicolon },
+        { KEY_APOSTROPHE, Qt::Key_Apostrophe },
+        { KEY_SLASH, Qt::Key_Slash },
+        { KEY_AT, Qt::Key_At },
+        { KEY_PLUS, Qt::Key_Plus },
+        { KEY_MENU, Qt::Key_Menu },
+        { KEY_PAGE_UP, Qt::Key_PageUp },
+        { KEY_PAGE_DOWN, Qt::Key_PageDown },
+        { KEY_ESCAPE, Qt::Key_Escape },
+        { KEY_FORWARD_DEL, Qt::Key_Delete },
+        { KEY_CTRL_LEFT, Qt::Key_Control },
+        { KEY_CTRL_RIGHT, Qt::Key_Control },
+        { KEY_CAPS_LOCK, Qt::Key_CapsLock },
+        { KEY_SCROLL_LOCK, Qt::Key_ScrollLock },
+        { KEY_META_LEFT, Qt::Key_Meta },
+        { KEY_META_RIGHT, Qt::Key_Meta },
+        //{ KEY_FUNCTION, Qt::Key_ },
+        { KEY_SYSRQ, Qt::Key_SysReq },
+        { KEY_BREAK, Qt::Key_Pause },
+        { KEY_MOVE_HOME, Qt::Key_Home },
+        { KEY_MOVE_END, Qt::Key_End },
+        { KEY_INSERT, Qt::Key_Insert },
+        { KEY_FORWARD, Qt::Key_Forward },
+        { KEY_MEDIA_PLAY, Qt::Key_MediaPlay },
+        { KEY_MEDIA_PAUSE, Qt::Key_MediaPause },
+        //{ KEY_MEDIA_CLOSE, Qt::Key_Media },
+        //{ KEY_MEDIA_EJECT, Qt::Key_Eject },
+        { KEY_MEDIA_RECORD, Qt::Key_MediaRecord },
+        { KEY_F1, Qt::Key_F1 },
+        { KEY_F2, Qt::Key_F2 },
+        { KEY_F3, Qt::Key_F3 },
+        { KEY_F4, Qt::Key_F4 },
+        { KEY_F5, Qt::Key_F5 },
+        { KEY_F6, Qt::Key_F6 },
+        { KEY_F7, Qt::Key_F7 },
+        { KEY_F8, Qt::Key_F8 },
+        { KEY_F9, Qt::Key_F9 },
+        { KEY_F10, Qt::Key_F10 },
+        { KEY_F11, Qt::Key_F11 },
+        { KEY_F12, Qt::Key_F12 },
+        { KEY_NUM_LOCK, Qt::Key_NumLock },
+        { KEY_NUMPAD_0, Qt::Key_0 },
+        { KEY_NUMPAD_1, Qt::Key_1 },
+        { KEY_NUMPAD_2, Qt::Key_2 },
+        { KEY_NUMPAD_3, Qt::Key_3 },
+        { KEY_NUMPAD_4, Qt::Key_4 },
+        { KEY_NUMPAD_5, Qt::Key_5 },
+        { KEY_NUMPAD_6, Qt::Key_6 },
+        { KEY_NUMPAD_7, Qt::Key_7 },
+        { KEY_NUMPAD_8, Qt::Key_8 },
+        { KEY_NUMPAD_9, Qt::Key_9 },
+        { KEY_NUMPAD_DIVIDE, Qt::Key_Slash },
+        { KEY_NUMPAD_MULTIPLY, Qt::Key_Asterisk },
+        { KEY_NUMPAD_SUBTRACT, Qt::Key_Minus },
+        { KEY_NUMPAD_ADD, Qt::Key_Plus },
+        { KEY_NUMPAD_DOT, Qt::Key_Period },
+        { KEY_NUMPAD_COMMA, Qt::Key_Comma },
+        { KEY_NUMPAD_ENTER, Qt::Key_Enter },
+        { KEY_NUMPAD_EQUALS, Qt::Key_Equal },
+        { KEY_NUMPAD_LEFT_PAREN, Qt::Key_ParenLeft },
+        { KEY_NUMPAD_RIGHT_PAREN, Qt::Key_ParenRight },
+        //{ KEY_VIRTUAL_MULTITASK, Qt::Key_ },
+        { KEY_SLEEP, Qt::Key_Sleep },
+        { KEY_ZENKAKU_HANKAKU, Qt::Key_Zenkaku_Hankaku },
+        //{ KEY_102ND,  Qt::Key_ },
+        //{ KEY_RO,  Qt::Key_ },
+        { KEY_KATAKANA, Qt::Key_Katakana },
+        { KEY_HIRAGANA, Qt::Key_Hiragana },
+        { KEY_HENKAN, Qt::Key_Henkan },
+        { KEY_KATAKANA_HIRAGANA, Qt::Key_Hiragana_Katakana },
+        { KEY_MUHENKAN, Qt::Key_Muhenkan },
+        { KEY_LINEFEED, Qt::Key_Return },
+        //{ KEY_MACRO, Qt::Key_macron },
+        //{ KEY_NUMPAD_PLUSMINUS, Qt::Key_ },
+        //{ KEY_SCALE, Qt::Key_ },
+        { KEY_HANGUEL, Qt::Key_Hangul },
+        { KEY_HANJA, Qt::Key_Hangul_Hanja },
+        { KEY_YEN, Qt::Key_yen },
+        { KEY_STOP, Qt::Key_Stop },
+        //{ KEY_AGAIN, Qt::Key_ },
+        //{ KEY_PROPS, Qt::Key_ },
+        { KEY_UNDO, Qt::Key_Undo },
+        { KEY_COPY, Qt::Key_Copy },
+        { KEY_OPEN, Qt::Key_Open },
+        { KEY_PASTE, Qt::Key_Paste },
+        { KEY_FIND, Qt::Key_Find },
+        { KEY_CUT, Qt::Key_Cut },
+        { KEY_HELP, Qt::Key_Help },
+        //{ KEY_CALC, Qt::Key_ },
+        //{ KEY_FILE, Qt::Key_ },
+        //{ KEY_BOOKMARKS, Qt::Key_Book },
+        //{ KEY_NEXT, Qt::Key_ },
+        //{ KEY_PLAYPAUSE, Qt::Key_MediaTogglePlayPause }
+        //{ KEY_PREVIOUS, Qt::Key_ },
+        //{ KEY_STOPCD, Qt::Key_ },
+        //{ KEY_CONFIG, Qt::Key_ },
+        { KEY_REFRESH, Qt::Key_Refresh },
+        { KEY_EXIT, Qt::Key_Exit },
+        //{ KEY_EDIT, Qt::Key_ },
+        //{ KEY_SCROLLUP, Qt::Key_ },
+        //{ KEY_SCROLLDOWN, Qt::Key_ },
+        { KEY_NEW, Qt::Key_New },
+        { KEY_REDO, Qt::Key_Redo },
+        { KEY_CLOSE, Qt::Key_Close },
+        { KEY_PLAY, Qt::Key_Play },
+        //{ KEY_BASSBOOST, Qt::Key_ },
+        { KEY_PRINT, Qt::Key_Print },
+        //{ KEY_CHAT, Qt::Key_ },
+        { KEY_FINANCE, Qt::Key_Finance },
+        { KEY_CANCEL, Qt::Key_Cancel },
+        //{ KEY_KBDILLUM_TOGGLE, Qt::Key_ },
+        { KEY_KBDILLUM_DOWN, Qt::Key_KeyboardBrightnessDown },
+        { KEY_KBDILLUM_UP, Qt::Key_KeyboardBrightnessUp },
+        { KEY_SEND, Qt::Key_Send },
+        { KEY_REPLY, Qt::Key_Reply },
+        { KEY_FORWARDMAIL, Qt::Key_Forward },
+        { KEY_SAVE, Qt::Key_Save },
+        { KEY_DOCUMENTS, Qt::Key_Documents },
+        //{ KEY_VIDEO_NEXT, Qt::Key_ },
+        //{ KEY_VIDEO_PREV, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_CYCLE, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_ZERO, Qt::Key_ },
+        //{ KEY_DISPLAY_OFF, Qt::Key_ },
+        //{ KEY_BTN_MISC, Qt::Key_ },
+        { KEY_GOTO, Qt::Key_Go },
+        { KEY_INFO, Qt::Key_Info },
+        //{ KEY_PROGRAM, Qt::Key_ },
+        //{ KEY_PVR, Qt::Key_ },
+        { KEY_SUBTITLE, Qt::Key_Subtitle },
+        //{ KEY_FULL_SCREEN, Qt::Key_ },
+        //{ KEY_KEYBOARD, Qt::Key_ },
+        //{ KEY_ASPECT_RATIO, Qt::Key_ },
+        //{ KEY_PC, Qt::Key_ },
+        //{ KEY_TV, Qt::Key_ },
+        //{ KEY_TV2, Qt::Key_ },
+        //{ KEY_VCR, Qt::Key_ },
+        //{ KEY_VCR2, Qt::Key_ },
+        //{ KEY_SAT, Qt::Key_ },
+        { KEY_CD, Qt::Key_CD },
+        //{ KEY_TAPE, Qt::Key_ },
+        //{ KEY_TUNER, Qt::Key_ },
+        { KEY_PLAYER, Qt::Key_Play },
+        //{ KEY_DVD, Qt::Key_ },
+        //{ KEY_AUDIO, Qt::Key_ },
+        { KEY_VIDEO, Qt::Key_Video },
+        { KEY_MEMO, Qt::Key_Memo },
+        { KEY_CALENDAR, Qt::Key_Calendar },
+        { KEY_RED, Qt::Key_Red },
+        { KEY_GREEN, Qt::Key_Green },
+        { KEY_YELLOW, Qt::Key_Yellow },
+        { KEY_BLUE, Qt::Key_Blue },
+        { KEY_CHANNELUP, Qt::Key_ChannelUp },
+        { KEY_CHANNELDOWN, Qt::Key_ChannelDown },
+        //{ KEY_LAST, Qt::Key_ },
+        //{ KEY_RESTART, Qt::Key_ },
+        //{ KEY_SLOW, Qt::Key_ },
+        //{ KEY_SHUFFLE, Qt::Key_ },
+        //{ KEY_VIDEOPHONE, Qt::Key_ },
+        { KEY_GAMES, Qt::Key_Game },
+        { KEY_ZOOMIN, Qt::Key_ZoomIn },
+        { KEY_ZOOMOUT, Qt::Key_ZoomOut },
+        //{ KEY_ZOOMRESET, Qt::Key_ },
+        //{ KEY_WORDPROCESSOR, Qt::Key_ },
+        //{ KEY_EDITOR, Qt::Key_ },
+        //{ KEY_SPREADSHEET, Qt::Key_ },
+        //{ KEY_GRAPHICSEDITOR, Qt::Key_ },
+        //{ KEY_PRESENTATION, Qt::Key_ },
+        //{ KEY_DATABASE, Qt::Key_ },
+        { KEY_NEWS, Qt::Key_News },
+        //{ KEY_VOICEMAIL, Qt::Key_ },
+        //{ KEY_ADDRESSBOOK, Qt::Key_ },
+        { KEY_MESSENGER, Qt::Key_Messenger },
+        //{ KEY_BRIGHTNESS_TOGGLE, Qt::Key_BrightnessAdjust }
+        //{ KEY_SPELLCHECK, Qt::Key_Spell }
+        //{ KEY_COFFEE, Qt::Key_ },
+        //{ KEY_MEDIA_REPEAT, Qt::Key_ },
+        //{ KEY_IMAGES, Qt::Key_ },
+        //{ KEY_BUTTONCONFIG, Qt::Key_ },
+        //{ KEY_TASKMANAGER, Qt::Key_TaskPane }
+        //{ KEY_JOURNAL, Qt::Key_ },
+        //{ KEY_CONTROLPANEL, Qt::Key_ },
+        //{ KEY_APPSELECT, Qt::Key_ },
+        { KEY_SCREENSAVER, Qt::Key_ScreenSaver },
+        //{ KEY_ASSISTANT, Qt::Key_ },
+        //{ KEY_KBD_LAYOUT_NEXT, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_MIN, Qt::Key_ },
+        //{ KEY_BRIGHTNESS_MAX, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_PREV, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_NEXT, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_PREVGROUP, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_NEXTGROUP, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_ACCEPT, Qt::Key_ },
+        //{ KEY_KBDINPUTASSIST_CANCEL, Qt::Key_ },
+        //{ KEY_FRONT, Qt::Key_ }
+        //{ KEY_SETUP, Qt::Key_Settings },
+        { KEY_WAKEUP, Qt::Key_WakeUp },
+        //{ KEY_SENDFILE, Qt::Key_ },
+        //{ KEY_DELETEFILE, Qt::Key_ },
+        { KEY_XFER, Qt::Key_Xfer },
+        //{ KEY_PROG1, Qt::Key_ },
+        //{ KEY_PROG2, Qt::Key_ },
+        //{ KEY_MSDOS, Qt::Key_ },
+        //{ KEY_SCREENLOCK, Qt::Key_ },
+        //{ KEY_DIRECTION_ROTATE_DISPLAY, Qt::Key },
+        //{ KEY_CYCLEWINDOWS, Qt::Key_ },
+        //{ KEY_COMPUTER, Qt::Key },
+        { KEY_EJECTCLOSECD, Qt::Key_Eject },
+        //{ KEY_ISO, Qt::Key_ },
+        //{ KEY_MOVE, Qt::Key_ },
+        { KEY_F13, Qt::Key_F13 },
+        { KEY_F14, Qt::Key_F14 },
+        { KEY_F15, Qt::Key_F15 },
+        { KEY_F16, Qt::Key_F16 },
+        { KEY_F17, Qt::Key_F17 },
+        { KEY_F18, Qt::Key_F18 },
+        { KEY_F19, Qt::Key_F19 },
+        { KEY_F20, Qt::Key_F20 },
+        { KEY_F21, Qt::Key_F21 },
+        { KEY_F22, Qt::Key_F22 },
+        { KEY_F23, Qt::Key_F23 },
+        { KEY_F24, Qt::Key_F24 },
+        //{ KEY_PROG3, Qt::Key_ },
+        //{ KEY_PROG4, Qt::Key_ },
+        //{ KEY_DASHBOARD, Qt::Key_ },
+        { KEY_SUSPEND, Qt::Key_Suspend },
+        //{ KEY_HP, Qt::Key_ },
+        //{ KEY_SOUND, Qt::Key_ },
+        { KEY_QUESTION, Qt::Key_Question },
+        //{ KEY_CONNECT, Qt::Key_ },
+        //{ KEY_SPORT, Qt::Key_ },
+        { KEY_SHOP, Qt::Key_Shop },
+        //{ KEY_ALTERASE, Qt::Key_ },
+        //{ KEY_SWITCHVIDEOMODE, Qt::Key_Mode_switch }
+        { KEY_BATTERY, Qt::Key_Battery },
+        { KEY_BLUETOOTH, Qt::Key_Bluetooth },
+        { KEY_WLAN, Qt::Key_WLAN },
+        { KEY_UWB, Qt::Key_UWB },
+        //{ KEY_WWAN_WIMAX, Qt::Key_ },
+        //{ KEY_RFKILL, Qt::Key_ },
+        //{ KEY_CHANNEL, Qt::Key_ },
+        { KEY_BTN_0, Qt::Key_0 },
+        { KEY_BTN_1, Qt::Key_1 },
+        { KEY_BTN_2, Qt::Key_2 },
+        { KEY_BTN_3, Qt::Key_3 },
+        { KEY_BTN_4, Qt::Key_4 },
+        { KEY_BTN_5, Qt::Key_5 },
+        { KEY_BTN_6, Qt::Key_6 },
+        { KEY_BTN_7, Qt::Key_7 },
+        { KEY_BTN_8, Qt::Key_8 },
+        { KEY_BTN_9, Qt::Key_9 }
+    };
+
+    static QHash<OH_NativeXComponent_KeyCode, Qt::KeyboardModifier> sKeyModifers{
+                                                                                   { KEY_SHIFT_LEFT, Qt::ShiftModifier },
+                                                                                   { KEY_SHIFT_RIGHT, Qt::ShiftModifier },
+                                                                                   { KEY_CTRL_LEFT, Qt::ControlModifier },
+                                                                                   { KEY_CTRL_RIGHT, Qt::ControlModifier },
+                                                                                   { KEY_ALT_LEFT, Qt::AltModifier },
+                                                                                   { KEY_ALT_RIGHT, Qt::AltModifier },
+                                                                                   { KEY_META_LEFT, Qt::MetaModifier },
+                                                                                   { KEY_META_RIGHT, Qt::MetaModifier },
+                                                                                   { KEY_NUM_LOCK, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_0, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_1, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_2, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_3, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_4, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_5, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_6, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_7, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_8, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_9, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_DIVIDE, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_MULTIPLY, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_SUBTRACT, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_ADD, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_DOT, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_COMMA, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_ENTER, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_EQUALS, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_LEFT_PAREN, Qt::KeypadModifier },
+                                                                                   { KEY_NUMPAD_RIGHT_PAREN, Qt::KeypadModifier},
+                                                                                   };
+
+    /* 有修饰符按下时记录按下的修饰符
+     * 松开时移除修饰符记录
+     */
+    QEvent::Type t = sKeyType.value(action, QEvent::None);
+    Qt::KeyboardModifier m = sKeyModifers.value(code, Qt::NoModifier);
+
+    /* 长按判断
+     * 记录按下的字符,判断字符是否已经按下
+     * 如果字符已经按下则认为是长按状态
+     */
+    bool autoRepeat = false;
+    if (OH_NATIVEXCOMPONENT_KEY_ACTION_DOWN == action) {
+        KeyRecord *rec = key_recorder.findKey(int(code), false);
+        if (rec) {
+            autoRepeat = true;
+        } else {
+            key_recorder.storeKey(int(code), 0, 0, QString());
+        }
+    } else {
+        key_recorder.findKey(int(code), true);
+    }
+
+    bool send = true;
+    if (Qt::NoModifier != m && QEvent::KeyPress == t){
+        send = !m_mpd.contains(m);
+        if (send) {
+            m_mpd.insert(m);
+        }
+    }
+
+    if (Qt::NoModifier != m && QEvent::KeyRelease == t) {
+        m_mpd.remove(m);
+    }
+
+    if (!send)
+        return;
+
+    int nativeModifier = 0;
+    for (Qt::KeyboardModifier mf : m_mpd)
+        nativeModifier |= int(mf);
+
+    int state = 0;
+    state |= (nativeModifier & Qt::ShiftModifier ? int(Qt::ShiftModifier) : 0);
+    state |= (nativeModifier & Qt::ControlModifier ? int(Qt::ControlModifier) : 0);
+    state |= (nativeModifier & Qt::AltModifier ? int(Qt::AltModifier) : 0);
+    state |= (nativeModifier & Qt::MetaModifier ? int(Qt::MetaModifier) : 0);
+
+    Qt::Key key = sKeyMap.value(code, Qt::Key_unknown);
+    if (key == Qt::Key_Control)
+        state = state ^ Qt::ControlModifier;
+    else if (key == Qt::Key_Shift)
+        state = state ^ Qt::ShiftModifier;
+    else if (key == Qt::Key_Alt)
+        state = state ^ Qt::AltModifier;
+
+    const Qt::KeyboardModifiers modifiers(state);
+    QWindowSystemInterface::handleExtendedKeyEvent(window, t, key, modifiers, code, code, nativeModifier, QString(), autoRepeat);
+}
+
+QOpenHarmonyPlatformInputContext::QOpenHarmonyPlatformInputContext()
+    : QPlatformInputContext()
+      , m_composingTextStart(-1)
+      , m_composingCursor(-1)
+      , m_batchEditNestingLevel(0)
+      , m_focusObject(Q_NULLPTR)
+{    
+    m_jsInputCtl = qJsObjectLoader->create("JsInputMethod");
+    m_openHarmonyInputContext = this;
+    qRegisterMetaType<OpenHarmonyMouseEvent>();
+}
+
+QOpenHarmonyPlatformInputContext::~QOpenHarmonyPlatformInputContext()
+{
+    m_openHarmonyInputContext = Q_NULLPTR;
+}
+/*!
+ * \brief 检查输入上下文是否具有指定的功能
+ * \param capability 枚举值，用于指定功能类型
+ * \return 返回布尔值，如果具有指定功能，则返回 true，否则返回 false
+ */
+bool QOpenHarmonyPlatformInputContext::hasCapability(Capability capability) const
+{
+    switch (capability) {
+    case HiddenTextCapability:
+        return false;
+    default:break;
+    }
+    return true;
+}
+/*!
+ * \brief 重置输入法状态，将输入法状态恢复到默认状态
+ */
+void QOpenHarmonyPlatformInputContext::reset()
+{
+    // qWarning() << "<-----------::" << Q_FUNC_INFO;
+    focusObjectStopComposing();
+    m_batchEditNestingLevel = 0;
+#if 0
+    if (m_jsInputCtl->call<bool>("isAttached"))
+        m_jsInputCtl->call<bool>("detach");
+#endif
+    clearInput();
+    emitInputPanelVisibleChanged();
+}
+/*!
+ * \brief 提交当前输入法状态，将当前输入法状态应用到文本编辑器中
+ */
+void QOpenHarmonyPlatformInputContext::commit()
+{
+    // qWarning() << "<-----------::" << Q_FUNC_INFO;
+    if(m_jsInputCtl->call<bool>("isAttached"))
+        m_jsInputCtl->call<bool>("detach");
+}
+/*!
+ * \brief 编辑器更新通知。由QInputMethod::update()调用
+ * 函数的作用是更新输入上下文的状态,以便与应用程序的输入方法通信
+ * 并响应输入法相关的查询,一般流程如下:
+ * 1.当输入法状态发生变化，或者焦点对象发生变化时
+ * QGuiApplication 会调用当前活动的 QPlatformInputContext 对象的 update 函数
+ *
+ * 2.在 update 函数内部，QPlatformInputContext 可以查询焦点对象的相关信息,
+ * 例如文本内容、光标位置等，然后将这些信息传递给输入法对象
+ *
+ * 3.输入法对象根据接收到的信息更新其状态，并相应地调整显示内容或行为
+ * 4.用户与输入法进行交互，输入文本或者调整输入法的设置
+ * 5.当用户输入完成或者输入法状态发生变化时，输入法对象可能会触发输入法事件,
+ * 通知 QPlatformInputContext 对象更新状态
+ */
+void QOpenHarmonyPlatformInputContext::update(Qt::InputMethodQueries queries)
+{
+    // qWarning() << "<-----------::" << Q_FUNC_INFO;
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery(queries);
+    if (query.isNull())
+        return;
+
+#warning TODO extract the needed data from query
+}
+
+/*!
+ * \brief 调用输入法的动作，以执行指定的操作，如向前移动光标、向后删除等
+ * \param act 动作类型
+ * \param cursorPosition 光标位置
+ */
+void QOpenHarmonyPlatformInputContext::invokeAction(QInputMethod::Action act, int cursorPosition)
+{
+    // qWarning() << "<-----------::" << Q_FUNC_INFO;
+#warning TODO Handle
+    Q_UNUSED(act);
+    Q_UNUSED(cursorPosition);
+}
+/*!
+ * \brief 过滤输入事件，以便输入上下文可以处理输入事件并相应地调整输入法状态
+ * \param event 输入事件
+ * \return 返回布尔值
+ */
+bool QOpenHarmonyPlatformInputContext::filterEvent(const QEvent *event)
+{
+    return QPlatformInputContext::filterEvent(event);
+}
+/*!
+ * \brief 获取键盘区域的矩形范围，以便应用程序可以根据键盘的显示状态调整布局
+ * \return 返回键盘区域矩形大小
+ */
+QRectF QOpenHarmonyPlatformInputContext::keyboardRect() const
+{
+    //TODO acquire softkeyborad rect
+    return QRectF();
+}
+
+/*!
+ * \brief 返回布尔值，指示输入面板是否处于动画状态
+ * \return 返回布尔值
+ */
+bool QOpenHarmonyPlatformInputContext::isAnimating() const
+{
+    return false;
+}
+/*!
+ * \brief 显示输入面板
+ */
+void QOpenHarmonyPlatformInputContext::showInputPanel()
+{
+    // qWarning() << "<-----------::" << Q_FUNC_INFO;
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return;
+
+    bool imEnable = query->queries().testFlag(Qt::ImEnabled);
+    if (!imEnable)
+        return;
+
+/* FIXME QML 控件中没有cursorPositionChanged */
+#if 0
+    disconnect(m_updateCursorPosConnection);
+    if (qGuiApp->focusObject()->metaObject()->indexOfSignal("cursorPositionChanged(int,int)") >= 0) // QLineEdit breaks the pattern
+        m_updateCursorPosConnection = connect(qGuiApp->focusObject(), SIGNAL(cursorPositionChanged(int,int)), this, SLOT(updateCursorPosition()));
+    else
+        m_updateCursorPosConnection = connect(qGuiApp->focusObject(), SIGNAL(cursorPositionChanged()), this, SLOT(updateCursorPosition()));
+#endif
+
+    Qt::InputMethodHints hints = query->value(Qt::ImHints).value<Qt::InputMethodHints>();
+    Qt::EnterKeyType enterType = query->value(Qt::ImEnterKeyType).value<Qt::EnterKeyType>();
+
+    bool isAttached = m_jsInputCtl->call<bool>("isAttached");
+    if (!isAttached)
+        m_jsInputCtl->call<bool>("attach", QVariant(qlonglong(static_cast<QObject*>(this))),
+                                 harmonyTextInputType(hints),
+                                 harmonyEnterKeyType(enterType));
+
+    emitInputPanelVisibleChanged();
+}
+/*!
+ * \brief 隐藏输入面板
+ */
+void QOpenHarmonyPlatformInputContext::hideInputPanel()
+{
+    // qWarning() << "<-----------::" << Q_FUNC_INFO;
+#if 0
+    if(m_jsInputCtl->call<bool>("isAttached"))
+       m_jsInputCtl->call<bool>("detach");
+#endif
+    clearInput();
+    emitInputPanelVisibleChanged();
+}
+/*!
+ * \brief 返回布尔值，指示输入面板的可见性状态
+ * \return 返回布尔值
+ */
+bool QOpenHarmonyPlatformInputContext::isInputPanelVisible() const
+{
+    bool visible = m_jsInputCtl->call<bool>("isInputPanelVisible");
+    return visible;
+}
+/*!
+ * \brief 设置获得焦点的对象
+ * \param object 对象指针
+ */
+void QOpenHarmonyPlatformInputContext::setFocusObject(QObject *object)
+{
+    if (object != m_focusObject) {
+        m_focusObject = object;
+        reset();
+    }
+    QPlatformInputContext::setFocusObject(object);
+}
+
+bool QOpenHarmonyPlatformInputContext::beginBatchEdit()
+{
+    ++m_batchEditNestingLevel;
+    return true;
+}
+
+bool QOpenHarmonyPlatformInputContext::endBatchEdit()
+{
+    if (--m_batchEditNestingLevel == 0) { //ending batch edit mode
+        //focusObjectStartComposing();
+        updateCursorPosition();
+    }
+    return true;
+}
+
+QOpenHarmonyPlatformInputContext *QOpenHarmonyPlatformInputContext::openHarmonyInputContext()
+{
+    return m_openHarmonyInputContext;
+}
+
+void QOpenHarmonyPlatformInputContext::setPlatformIntegration(QOpenHarmonyPlatformIntegration *integration)
+{
+    m_integration = integration;
+}
+
+void QOpenHarmonyPlatformInputContext::clear()
+{
+    m_integration = nullptr;
+    m_ignoreMouseEvents = false;
+}
+
+void QOpenHarmonyPlatformInputContext::touchBegin()
+{
+    m_touchPoints.clear();
+}
+
+void QOpenHarmonyPlatformInputContext::touchAdd(int id, int action, float force, float x, float y)
+{
+    OpenHarmonyTouchPoint touchPoint;
+    touchPoint.id = id;
+    touchPoint.action = action;
+    touchPoint.force = force;
+    touchPoint.x = x;
+    touchPoint.y = y;
+    m_touchPoints.push_back(touchPoint);
+}
+
+void QOpenHarmonyPlatformInputContext::touchEnd(const OpenHarmonyTouchEvent &event)
+{
+    QOpenHarmonyJsWindow *window = qJsWindowManager->window(event.component);
+    if ((window == nullptr) || (m_integration == nullptr) || m_touchPoints.isEmpty())
+        return;
+
+
+    QList<QWindowSystemInterface::TouchPoint> qtTouchPoints;
+
+    QOpenHarmonyJsWindow *parent = window->parent();
+    QOpenHarmonyJsWindow *dest = (parent == nullptr) ? window : parent;
+    while (parent != nullptr) {
+        dest = parent;
+        parent = parent->parent();
+    }
+
+    QMargins m = dest->frameMargins();
+    QRect rc = m_integration->screen()->availableGeometry();
+
+    const double dw = static_cast<double>(rc.width());
+    const double dh = static_cast<double>(rc.height());
+    for (int i = 0; i < m_touchPoints.count(); ++i) {
+        const OpenHarmonyTouchPoint &point = m_touchPoints[i];
+        int action = point.action;
+
+        Qt::TouchPointState state = Qt::TouchPointStationary;
+        switch (action) {
+        case 0:
+            state = Qt::TouchPointPressed;
+            break;
+        case 1:
+            state = Qt::TouchPointMoved;
+            break;
+        case 2:
+            state = Qt::TouchPointStationary;
+            break;
+        case 3:
+            state = Qt::TouchPointReleased;
+            break;
+        }
+
+        QWindowSystemInterface::TouchPoint touchPoint;
+        touchPoint.id = point.id;
+        touchPoint.pressure = static_cast<qreal>(point.force);
+        //    touchPoint.rotation = qRadiansToDegrees(rotation);
+        touchPoint.rotation = 0;
+        QPoint globalPoint = dest->mapToGlobal(QPoint(point.x - m.left(), point.y - m.top()));
+        int x = globalPoint.x();
+        int y = globalPoint.y();
+        touchPoint.normalPosition = QPointF(double(x / dw), double(y / dh));
+        touchPoint.state = state;
+
+        float minor = 50;
+        float major = 50;
+        touchPoint.area = QRectF(x - minor,
+                                 y - major,
+                                 double(minor * 2),
+                                 double(major * 2));
+        qtTouchPoints << touchPoint;
+    }
+
+    QTouchDevice *touchDevice = m_integration->touchDevice();
+    if (touchDevice == nullptr) {
+        touchDevice = new QTouchDevice;
+        touchDevice->setType(QtOpenHarmony::isTouchPad() ? QTouchDevice::TouchPad : QTouchDevice::TouchScreen);
+        QTouchDevice::Capabilities capabilities = QTouchDevice::Position | QTouchDevice::Area | QTouchDevice::NormalizedPosition | QTouchDevice::Pressure;
+        if (touchDevice->type() == QTouchDevice::TouchPad)
+            capabilities |= QTouchDevice::MouseEmulation;
+        touchDevice->setCapabilities(capabilities);
+        QWindowSystemInterface::registerTouchDevice(touchDevice);
+        m_integration->setTouchDevice(touchDevice);
+    }
+
+    QWindowSystemInterface::handleTouchEvent(window->qtWindow(), touchDevice, qtTouchPoints, queryKeyboardModifiers());
+    QWindowSystemInterface::flushWindowSystemEvents(QEventLoop::ExcludeUserInputEvents);
+}
+
+void QOpenHarmonyPlatformInputContext::setComposingText(const QString &text)
+{
+    m_composingText = text;
+}
+
+QString QOpenHarmonyPlatformInputContext::getTextAfterCursor(int length, int flags)
+{
+    Q_UNUSED(flags);
+    if (length <= 0)
+        return QString();
+
+    QString text;
+
+    QVariant reportedTextAfter = QInputMethod::queryFocusObject(Qt::ImTextAfterCursor, length);
+    if (reportedTextAfter.isValid()) {
+        text = reportedTextAfter.toString();
+    } else {
+        // Compatibility code for old controls that do not implement the new API
+        QSharedPointer<QInputMethodQueryEvent> query =
+                focusObjectInputMethodQuery(Qt::ImCursorPosition | Qt::ImSurroundingText);
+        if (query) {
+            const int cursorPos = query->value(Qt::ImCursorPosition).toInt();
+            text = query->value(Qt::ImSurroundingText).toString().mid(cursorPos);
+        }
+    }
+
+    if (focusObjectIsComposing()) {
+        // Controls do not report preedit text, so we have to add it
+        const int cursorPosInsidePreedit = m_composingCursor - m_composingTextStart;
+        text = m_composingText.midRef(cursorPosInsidePreedit) + text;
+    } else {
+        // We must not return selected text if there is any
+        QSharedPointer<QInputMethodQueryEvent> query =
+                focusObjectInputMethodQuery(Qt::ImCursorPosition | Qt::ImAnchorPosition);
+        if (query) {
+            const int cursorPos = query->value(Qt::ImCursorPosition).toInt();
+            const int anchorPos = query->value(Qt::ImAnchorPosition).toInt();
+            if (anchorPos > cursorPos)
+                text.remove(0, anchorPos - cursorPos);
+        }
+    }
+
+    text.truncate(length);
+    return text;
+}
+
+QString QOpenHarmonyPlatformInputContext::getTextBeforeCursor(int length, int flags)
+{
+    Q_UNUSED(flags);
+    if (length <= 0)
+        return QString();
+
+    QString text;
+
+    QVariant reportedTextBefore = QInputMethod::queryFocusObject(Qt::ImTextBeforeCursor, length);
+    if (reportedTextBefore.isValid()) {
+        text = reportedTextBefore.toString();
+    } else {
+        // Compatibility code for old controls that do not implement the new API
+        QSharedPointer<QInputMethodQueryEvent> query =
+                focusObjectInputMethodQuery(Qt::ImCursorPosition | Qt::ImSurroundingText);
+        if (query) {
+            const int cursorPos = query->value(Qt::ImCursorPosition).toInt();
+            text = query->value(Qt::ImSurroundingText).toString().left(cursorPos);
+        }
+    }
+
+    if (focusObjectIsComposing()) {
+        // Controls do not report preedit text, so we have to add it
+        const int cursorPosInsidePreedit = m_composingCursor - m_composingTextStart;
+        text += m_composingText.leftRef(cursorPosInsidePreedit);
+    } else {
+        // We must not return selected text if there is any
+        QSharedPointer<QInputMethodQueryEvent> query =
+                focusObjectInputMethodQuery(Qt::ImCursorPosition | Qt::ImAnchorPosition);
+        if (query) {
+            const int cursorPos = query->value(Qt::ImCursorPosition).toInt();
+            const int anchorPos = query->value(Qt::ImAnchorPosition).toInt();
+            if (anchorPos < cursorPos)
+                text.chop(cursorPos - anchorPos);
+        }
+    }
+
+    if (text.length() > length)
+        text = text.right(length);
+    return text;
+}
+
+void QOpenHarmonyPlatformInputContext::clearInput()
+{
+    m_composingText.clear();
+    m_composingTextStart  = -1;
+    m_composingCursor = -1;
+}
+/*!
+ * \brief FIXME 临时方法发送EnterKey按键事件
+ */
+void QOpenHarmonyPlatformInputContext::enterKeyDown()
+{
+    LOGW("<--------------------- enterKeyDown ----------------->");
+    QKeyEvent k1(QEvent::KeyPress, Qt::Key_Enter, Qt::NoModifier, KEY_ENTER, KEY_ENTER, KEY_ENTER);
+    QGuiApplication::sendEvent(m_focusObject, &k1);
+
+    QKeyEvent k2(QEvent::KeyRelease, Qt::Key_Enter, Qt::NoModifier, KEY_ENTER, KEY_ENTER, KEY_ENTER);
+    QGuiApplication::sendEvent(m_focusObject, &k2);
+}
+
+void QOpenHarmonyPlatformInputContext::commitText(QString text)
+{
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return;
+
+    BatchEditLock batchEditLock(this);
+
+    const int absoluteCursorPos = getAbsoluteCursorPosition(query);
+    int absoluteAnchorPos = getBlockPosition(query) + query->value(Qt::ImAnchorPosition).toInt();
+
+    auto setCursorPosition = [=]() {
+        const int cursorPos = query->value(Qt::ImCursorPosition).toInt();
+        QInputMethodEvent event({}, { { QInputMethodEvent::Selection, cursorPos, 0 } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+    };
+
+    // If we have composing region and selection (and therefore focusObjectIsComposing() == false),
+    // we must clear selection so that we won't delete it when we will be replacing composing text
+    if (!m_composingText.isEmpty() && absoluteCursorPos != absoluteAnchorPos) {
+        setCursorPosition();
+        absoluteAnchorPos = absoluteCursorPos;
+    }
+
+    // The value of Qt::ImCursorPosition is not updated at the start
+    // when the first character is added, so we must update it (QTBUG-85090)
+    if (absoluteCursorPos == 0 && text.length() == 1 && getTextAfterCursor(1,1).length() >= 0) {
+        setCursorPosition();
+    }
+
+    // If we had no composing region, pretend that we had a zero-length composing region at current
+    // cursor position to simplify code. Also account for that we must delete selected text if there
+    // (still) is any.
+    const int effectiveAbsoluteCursorPos = qMin(absoluteCursorPos, absoluteAnchorPos);
+    if (m_composingTextStart == -1)
+        m_composingTextStart = effectiveAbsoluteCursorPos;
+
+    const int oldComposingTextLen = m_composingText.length();
+    m_composingText = text;
+
+
+    QInputMethodEvent event;
+    event.setCommitString(text);
+    QGuiApplication::sendEvent(m_focusObject, &event);    
+}
+
+void QOpenHarmonyPlatformInputContext::commitMoveCursor(int direction)
+{
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return;
+
+    QInputMethodEvent event;
+    const int absolutecursorPos = getAbsoluteCursorPosition(query);
+    /* 1-up 2-down
+     * 3-left 4-right
+     */
+    switch(direction)
+    {
+    case 1:
+        break;
+    case 2:
+        break;
+    case 3:
+        event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, qMax(absolutecursorPos - 1, 0), 0 } });
+        break;
+    case 4:
+        event = QInputMethodEvent ({}, { { QInputMethodEvent::Selection, absolutecursorPos + 1, 0 } });
+        break;
+    default:break;
+    }
+    QGuiApplication::sendEvent(m_focusObject, &event);
+}
+
+void QOpenHarmonyPlatformInputContext::showInputPanelLater(Qt::ApplicationState state)
+{
+    if (state != Qt::ApplicationActive)
+        return;
+    disconnect(qGuiApp, SIGNAL(applicationStateChanged(Qt::ApplicationState)), this, SLOT(showInputPanelLater(Qt::ApplicationState)));
+    showInputPanel();
+}
+
+void QOpenHarmonyPlatformInputContext::deleteSurroundingText(int leftLength, int rightLength)
+{
+#if 0
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return;
+
+    const int absolutecursorPos = getAbsoluteCursorPosition(query);
+    const QString &selectText = query->value(Qt::ImCurrentSelection).toString();
+    const int selectLength = selectText.length();
+    int beginPos = absolutecursorPos;
+
+    QInputMethodEvent event;
+    if (!selectText.isEmpty()) {
+        beginPos = qMax(absolutecursorPos - selectLength, 0);
+        event = QInputMethodEvent ({}, { { QInputMethodEvent::Selection, beginPos, selectLength } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event.setCommitString({}, beginPos, selectLength);
+        QGuiApplication::sendEvent(m_focusObject, &event);
+    }
+
+    if (leftLength > 0) {
+        beginPos = qMax(absolutecursorPos - leftLength, 0);
+        qWarning() << absolutecursorPos << selectLength << beginPos;
+
+        event = QInputMethodEvent ({}, { { QInputMethodEvent::Selection, beginPos, leftLength} });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event.setCommitString({}, beginPos, leftLength);
+        QGuiApplication::sendEvent(m_focusObject, &event);        
+    }
+
+    if (rightLength > 0) {
+        beginPos = absolutecursorPos <= 0 ? -1 : absolutecursorPos;
+        event = QInputMethodEvent ({}, { { QInputMethodEvent::Selection, beginPos, rightLength }});
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event.setCommitString({}, beginPos, rightLength);
+        QGuiApplication::sendEvent(m_focusObject, &event);
+    }
+
+    event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, beginPos, 0 } });
+    QGuiApplication::sendEvent(m_focusObject, &event);
+#else
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return;
+
+
+    const int absolutecursorPos = getAbsoluteCursorPosition(query);
+    const QString &selectText = query->value(Qt::ImCurrentSelection).toString();
+    const int selectLength = selectText.length();
+    int beginPos = absolutecursorPos;
+
+    QInputMethodEvent event;
+    if (!selectText.isEmpty()) {
+        beginPos = qMax(absolutecursorPos - selectLength, 0);
+        event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, beginPos, selectLength } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event.setCommitString({}, beginPos, selectLength);
+        QGuiApplication::sendEvent(m_focusObject, &event);
+    }
+
+    if (leftLength > 0) {
+        QString textBeforeCursor = query->value(Qt::ImTextBeforeCursor).toString();
+        int deleteStartPos = textBeforeCursor.length() - leftLength;
+        deleteStartPos = qMax(deleteStartPos, 0);
+
+        QString textToDelete = textBeforeCursor.right(leftLength);
+        event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, deleteStartPos, textToDelete.length() } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event.setCommitString({}, deleteStartPos, textToDelete.length());
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, deleteStartPos, 0 } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+    }
+
+    if (rightLength > 0) {
+        QString textAfterCursor = query->value(Qt::ImTextAfterCursor).toString();
+        QString textToDelete = textAfterCursor.left(rightLength);
+
+        event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, absolutecursorPos, textToDelete.length() } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event.setCommitString({}, absolutecursorPos, textToDelete.length());
+        QGuiApplication::sendEvent(m_focusObject, &event);
+
+        event = QInputMethodEvent({}, { { QInputMethodEvent::Selection, absolutecursorPos, 0 } });
+        QGuiApplication::sendEvent(m_focusObject, &event);
+    }
+#endif
+}
+
+void QOpenHarmonyPlatformInputContext::sendInputMethodEvent(QInputMethodEvent *event)
+{
+    if (!qGuiApp)
+        return;
+
+    QObject *focusObject = qGuiApp->focusObject();
+    if (!focusObject)
+        return;
+
+    QCoreApplication::sendEvent(focusObject, event);
+}
+
+QSharedPointer<QInputMethodQueryEvent> QOpenHarmonyPlatformInputContext::focusObjectInputMethodQuery(Qt::InputMethodQueries queries)
+{
+    if (!qGuiApp)
+        return {};
+
+    QObject *focusObject = qGuiApp->focusObject();
+    if (!focusObject)
+        return {};
+
+    QInputMethodQueryEvent *ret = new QInputMethodQueryEvent(queries);
+    QCoreApplication::sendEvent(focusObject, ret);
+    return QSharedPointer<QInputMethodQueryEvent>(ret);
+}
+
+bool QOpenHarmonyPlatformInputContext::focusObjectIsComposing() const
+{
+    return m_composingCursor != -1;
+}
+
+void QOpenHarmonyPlatformInputContext::focusObjectStartComposing()
+{
+    if (focusObjectIsComposing() || m_composingText.isEmpty())
+        return;
+
+           // Composing strings containing newline characters are rare and may cause problems
+    if (m_composingText.contains(QLatin1Char('\n')))
+        return;
+
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (!query)
+        return;
+
+    if (query->value(Qt::ImCursorPosition).toInt() != query->value(Qt::ImAnchorPosition).toInt())
+        return;
+
+    const int absoluteCursorPos = getAbsoluteCursorPosition(query);
+    if (absoluteCursorPos < m_composingTextStart
+        || absoluteCursorPos > m_composingTextStart + m_composingText.length())
+        return;
+
+    m_composingCursor = absoluteCursorPos;
+
+    QTextCharFormat underlined;
+    underlined.setFontUnderline(true);
+
+    QInputMethodEvent event(m_composingText, {
+                                                     { QInputMethodEvent::Cursor, absoluteCursorPos - m_composingTextStart, 1 },
+                                                     { QInputMethodEvent::TextFormat, 0, m_composingText.length(), underlined }
+                                             });
+
+    event.setCommitString({}, m_composingTextStart - absoluteCursorPos, m_composingText.length());
+
+    QGuiApplication::sendEvent(m_focusObject, &event);
+}
+
+bool QOpenHarmonyPlatformInputContext::focusObjectStopComposing()
+{
+    if (!focusObjectIsComposing())
+        return true; // not composing
+
+    QSharedPointer<QInputMethodQueryEvent> query = focusObjectInputMethodQuery();
+    if (query.isNull())
+        return false;
+
+    const int blockPos = getBlockPosition(query);
+    const int localCursorPos = m_composingCursor - blockPos;
+
+    m_composingCursor = -1;
+
+    {
+        // commit the composing test
+        QList<QInputMethodEvent::Attribute> attributes;
+        QInputMethodEvent event(QString(), attributes);
+        event.setCommitString(m_composingText);
+        sendInputMethodEvent(&event);
+    }
+    {
+        // Moving Qt's cursor to where the preedit cursor used to be
+        QList<QInputMethodEvent::Attribute> attributes;
+        attributes.append(
+                QInputMethodEvent::Attribute(QInputMethodEvent::Selection, localCursorPos, 0));
+        QInputMethodEvent event(QString(), attributes);
+        sendInputMethodEvent(&event);
+    }
+
+    return true;
+}
+
+
+QT_END_NAMESPACE
+
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.h b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.h
new file mode 100644
index 0000000000..1075711f40
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatforminputcontext.h
@@ -0,0 +1,148 @@
+#ifndef QOPENHARMONYPLATFORMINPUTCONTEXT_H
+#define QOPENHARMONYPLATFORMINPUTCONTEXT_H
+
+#include <QPointer>
+#include <functional>
+#include <napi/native_api.h>
+#include <qpa/qplatforminputcontext.h>
+#include <qpa/qwindowsysteminterface.h>
+#include <ace/xcomponent/native_interface_xcomponent.h>
+#include <ace/xcomponent/native_xcomponent_key_event.h>
+
+class QOpenHarmonyJsObject;
+class QOpenHarmonyJsWindow;
+class QOpenHarmonyPlatformIntegration;
+
+QT_BEGIN_NAMESPACE
+
+struct OpenHarmonyMouseEvent{
+    OH_NativeXComponent *component;
+    float x;
+    float y;
+    QEvent::Type type;
+    Qt::MouseButton btn;
+};
+
+struct OpenHarmonyWheelEvent{
+    OH_NativeXComponent *component;
+    QPoint global;
+    QPoint pixelDelta;
+    Qt::KeyboardModifiers mods;
+};
+
+struct OpenHarmonyTouchPoint {
+    int id;
+    int action;
+    float force;
+    float x;
+    float y;
+};
+
+struct OpenHarmonyTouchEvent {
+    OH_NativeXComponent *component;
+    int id;
+};
+
+struct OpenHarmonyKeyEvent {
+    OH_NativeXComponent *component;
+    OH_NativeXComponent_KeyCode code;
+    OH_NativeXComponent_KeyAction action;
+    OH_NativeXComponent_EventSourceType stype;
+    int64_t deviceId;
+    int64_t timeStamp;
+};
+
+
+Q_DECLARE_METATYPE(OpenHarmonyMouseEvent)
+Q_DECLARE_METATYPE(OpenHarmonyWheelEvent)
+Q_DECLARE_METATYPE(OpenHarmonyTouchEvent)
+Q_DECLARE_METATYPE(OpenHarmonyKeyEvent)
+
+class QOpenHarmonyPlatformInputContext: public QPlatformInputContext
+{
+    Q_OBJECT
+
+public:
+    QOpenHarmonyPlatformInputContext();
+    ~QOpenHarmonyPlatformInputContext() override;
+
+    /* 判断输入上下文是否有效 */
+    bool isValid() const override { return true; }
+    bool hasCapability(Capability capability) const override;
+
+    void reset() override;
+    void commit() override;
+    void update(Qt::InputMethodQueries queries) override;
+    void invokeAction(QInputMethod::Action act, int cursorPosition) override;
+
+    bool filterEvent(const QEvent *event) override;
+    QRectF keyboardRect() const override;
+
+    bool isAnimating() const override;
+
+    void showInputPanel() override;
+    void hideInputPanel() override;
+    bool isInputPanelVisible() const override;
+
+    void setFocusObject(QObject *object) override;
+
+    bool beginBatchEdit();
+    bool endBatchEdit();
+
+    void clear();
+    void touchBegin();
+    void setComposingText(const QString &text);
+    QString getTextAfterCursor(int length, int flags);
+    QString getTextBeforeCursor(int length, int flags);
+
+    void touchAdd(int id, int action, float force, float x, float y);
+    static QOpenHarmonyPlatformInputContext * openHarmonyInputContext();
+    void setPlatformIntegration(QOpenHarmonyPlatformIntegration *integration);
+    static napi_value init(napi_env env, napi_value exports);
+
+    Qt::KeyboardModifiers queryKeyboardModifiers() const;
+
+public Q_SLOTS:
+    void updateCursorPosition();
+    void touchEnd(const OpenHarmonyTouchEvent &event);
+    void handleMouseEvent(const OpenHarmonyMouseEvent &event);
+    void wheelEvent(const OpenHarmonyWheelEvent &event);
+    void handleKeyEvent(const OpenHarmonyKeyEvent &event);
+
+private Q_SLOTS:
+    void touchDown(float x, float y);
+    void mouseMove(QOpenHarmonyJsWindow *window, float x, float y, Qt::MouseButton button);
+    void mousePress(QOpenHarmonyJsWindow *window, float x, float y, Qt::MouseButton button);
+    void mouseRelease(QOpenHarmonyJsWindow *window, float x, float y, Qt::MouseButton button);
+    void clearInput();
+    void enterKeyDown();
+    void commitText(QString text);
+    void commitMoveCursor(int direction);
+    void showInputPanelLater(Qt::ApplicationState state);
+    void deleteSurroundingText(int leftLength, int rightLength);
+
+private:
+    bool focusObjectIsComposing() const;
+    void focusObjectStartComposing();
+    bool focusObjectStopComposing();
+    void sendInputMethodEvent(QInputMethodEvent *event);    
+    QSharedPointer<QInputMethodQueryEvent> focusObjectInputMethodQuery(Qt::InputMethodQueries queries = Qt::ImQueryAll);
+
+private:
+    QString m_composingText;
+    int m_composingTextStart;
+    int m_composingCursor;
+    QObject *m_focusObject;
+    int m_batchEditNestingLevel;
+    QSet<Qt::KeyboardModifier> m_mpd; /* 记录按下的修饰键 */
+    bool m_ignoreMouseEvents = false;
+    QMetaObject::Connection m_updateCursorPosConnection;
+    QOpenHarmonyPlatformIntegration *m_integration = nullptr;
+    QList<OpenHarmonyTouchPoint> m_touchPoints;
+    QSharedPointer<QOpenHarmonyJsObject> m_jsInputCtl;
+    QPointer<QWindow> m_mouseGrabber;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMINPUTCONTEXT_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.cpp
new file mode 100644
index 0000000000..fdf77dd58e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.cpp
@@ -0,0 +1,321 @@
+#include "qopenharmonyplatformintegration.h"
+
+#include <QtGui/private/qguiapplication_p.h>
+#include <QGuiApplication>
+#include <QOpenGLContext>
+#include <QThread>
+#include <QMetaObject>
+#include <QOffscreenSurface>
+
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformwindow.h>
+#include <qpa/qplatformoffscreensurface.h>
+
+#include "qabstracteventdispatcher.h"
+#include "qopenharmonyeventdispatcher.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyplatformforeignwindow.h"
+#include "qopenharmonyplatformopenglcontext.h"
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformfontdatabase.h"
+#include "qopenharmonyplatformoffscreensurface.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyplatformtheme.h"
+#include "qopenharmonyplatformclipboard.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonyplatformservices.h"
+
+#if QT_CONFIG(vulkan)
+#include "qopenharmonyplatformvulkaninstance.h"
+#endif
+#include "qopenharmonydefines.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonymain.h"
+
+#include <QtGui/qpa/qplatforminputcontextfactory_p.h>
+#include <QtPlatformHeaders/QEGLNativeContext>
+#include <QtGui/qpa/qplatformcursor.h>
+
+QT_BEGIN_NAMESPACE
+
+int QOpenHarmonyPlatformIntegration::m_defaultGeometryWidth = 720;
+int QOpenHarmonyPlatformIntegration::m_defaultGeometryHeight = 1280;
+int QOpenHarmonyPlatformIntegration::m_defaultScreenWidth = 720;
+int QOpenHarmonyPlatformIntegration::m_defaultScreenHeight = 1280;
+int QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeWidth = 68;
+int QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeHeight = 121;
+int QOpenHarmonyPlatformIntegration::m_defaultLeft = 0;
+int QOpenHarmonyPlatformIntegration::m_defaultTop = 72;
+
+Qt::ScreenOrientation QOpenHarmonyPlatformIntegration::m_orientation = Qt::PrimaryOrientation;
+Qt::ScreenOrientation QOpenHarmonyPlatformIntegration::m_nativeOrientation = Qt::PrimaryOrientation;
+
+bool QOpenHarmonyPlatformIntegration::m_showPasswordEnabled = false;
+
+
+QOpenHarmonyPlatformIntegration::QOpenHarmonyPlatformIntegration(const QStringList &paramList)
+{
+    Q_UNUSED(paramList);
+
+    QOpenHarmonyEGLCore::init();
+    m_eglDisplay = QOpenHarmonyEGLCore::eglDisplay();
+    m_eglConfig = QOpenHarmonyEGLCore::eglConfig();
+
+//    QWindowSystemInterface::setSynchronousWindowSystemEvents(true);
+    m_harmonyFontDatabase.reset(new QOpenHarmonyPlatformFontDatabase);
+
+    m_primaryScreen.reset(new QOpenHarmonyPlatformScreen);
+    m_primaryScreen->setPhysicalSize(QSize(m_defaultPhysicalSizeWidth, m_defaultPhysicalSizeHeight));
+    m_primaryScreen->setSize(QSize(m_defaultScreenWidth, m_defaultScreenHeight));
+    m_primaryScreen->setAvailableGeometry(QRect(m_defaultLeft, m_defaultTop, m_defaultGeometryWidth, m_defaultGeometryHeight));
+    QWindowSystemInterface::handleScreenAdded(m_primaryScreen.data());
+
+    QPlatformCursor::setCapability(QPlatformCursor::OverrideCursor);
+
+    m_mainThread = QThread::currentThread();
+
+#ifndef QT_NO_CLIPBOARD
+    m_platformClipboard.reset(new QOpenHarmonyPlatformClipboard);
+#endif
+
+    m_platformNativeInterface.reset(new QOpenHarmonyPlatformNativeInterface());
+    m_platformServices.reset(new QOpenHarmonyPlatformServices());
+    QCoreApplication::postEvent(m_platformNativeInterface.data(), new QEvent(QEvent::User));
+}
+
+
+bool QOpenHarmonyPlatformIntegration::hasCapability(Capability cap) const
+{
+    return true;
+}
+
+QPlatformBackingStore *QOpenHarmonyPlatformIntegration::createPlatformBackingStore(QWindow *window) const
+{
+    return new QOpenHarmonyPlatformBackingStore(window);
+}
+
+#ifndef QT_NO_OPENGL
+QPlatformOpenGLContext *QOpenHarmonyPlatformIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
+{
+    QSurfaceFormat format(context->format());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+    format.setDepthBufferSize(8);
+    format.setStencilBufferSize(8);
+    EGLConfig confg = QOpenHarmonyEGLCore::eglConfig();
+    auto ctx = new QOpenHarmonyPlatformOpenGLContext(format, context->shareHandle(), m_eglDisplay, &confg, context->nativeHandle());
+    context->setNativeHandle(QVariant::fromValue<QEGLNativeContext>(QEGLNativeContext(ctx->eglContext(), m_eglDisplay)));
+    return ctx;
+}
+#endif
+
+QPlatformOffscreenSurface *QOpenHarmonyPlatformIntegration::createPlatformOffscreenSurface(QOffscreenSurface *surface) const
+{
+    QSurfaceFormat format(surface->requestedFormat());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+
+    if (surface->nativeHandle()) {
+        return new QOpenHarmonyPlatformOffscreenSurface(m_eglDisplay, format, surface);
+    }
+
+    return new QEGLPbuffer(m_eglDisplay, format, surface);
+}
+
+QPlatformWindow *QOpenHarmonyPlatformIntegration::createPlatformWindow(QWindow *window) const
+{
+    return new QOpenHarmonyPlatformOpenGLWindow(window, m_eglDisplay);
+}
+
+QPlatformWindow *QOpenHarmonyPlatformIntegration::createForeignWindow(QWindow *window, WId nativeHandle) const
+{
+    return new QOpenHarmonyPlatformForeignWindow(window, nativeHandle);
+}
+
+QAbstractEventDispatcher *QOpenHarmonyPlatformIntegration::createEventDispatcher() const
+{
+    return new QOpenHarmonyEventDispatcher;
+}
+
+QOpenHarmonyPlatformIntegration::~QOpenHarmonyPlatformIntegration()
+{
+    QOpenHarmonyEGLCore::clear();
+    QOpenHarmonyPlatformInputContext *context = qobject_cast<QOpenHarmonyPlatformInputContext *>(m_platformInputContext.data());
+    if (context != nullptr)
+        context->clear();
+    QtOpenHarmony::setOpenHarmonyPlatformIntegration(nullptr);
+}
+
+void QOpenHarmonyPlatformIntegration::initialize()
+{
+    const QString icStr = QPlatformInputContextFactory::requested();
+    if (icStr.isNull()) {
+        QOpenHarmonyPlatformInputContext *context = new QOpenHarmonyPlatformInputContext;
+        context->setPlatformIntegration(this);
+        m_platformInputContext.reset(context);
+    }
+    else
+        m_platformInputContext.reset(QPlatformInputContextFactory::create(icStr));
+}
+
+Qt::KeyboardModifiers QOpenHarmonyPlatformIntegration::queryKeyboardModifiers() const
+{
+    if (m_platformInputContext.isNull())
+        return QPlatformIntegration::queryKeyboardModifiers();
+
+
+    if (QOpenHarmonyPlatformInputContext *context =
+        static_cast<QOpenHarmonyPlatformInputContext*>(m_platformInputContext.data())){
+        return context->queryKeyboardModifiers();
+    }
+
+    return Qt::KeyboardModifiers(Qt::NoModifier);
+}
+
+QPlatformInputContext *QOpenHarmonyPlatformIntegration::inputContext() const
+{
+    return m_platformInputContext.data();
+}
+
+QPlatformNativeInterface *QOpenHarmonyPlatformIntegration::nativeInterface() const
+{
+    return m_platformNativeInterface.data();
+}
+
+QPlatformServices *QOpenHarmonyPlatformIntegration::services() const
+{
+    return m_platformServices.data();
+}
+
+QVariant QOpenHarmonyPlatformIntegration::styleHint(StyleHint hint) const
+{
+    switch (hint) {
+    case PasswordMaskDelay:
+        return m_showPasswordEnabled ? 1500 : 0;
+    case ShowIsMaximized:
+        return QtOpenHarmony::defaultShowIsMaximized();
+    default:
+        return QPlatformIntegration::styleHint(hint);
+    }
+}
+
+Qt::WindowState QOpenHarmonyPlatformIntegration::defaultWindowState(Qt::WindowFlags flags) const
+{
+    // Don't maximize dialogs on OpenHarmony
+    if (flags & Qt::Dialog & ~Qt::Window) {
+        return Qt::WindowNoState;
+    }
+    return QPlatformIntegration::defaultWindowState(flags);
+}
+/* NOTE 改主题名称和加载的样式插件相关联 */
+static const QLatin1String openharmonyThemeName("openharmony");
+QStringList QOpenHarmonyPlatformIntegration::themeNames() const
+{
+    return QStringList{ "harmonyos", QString(openharmonyThemeName) };
+}
+
+QPlatformTheme *QOpenHarmonyPlatformIntegration::createPlatformTheme(const QString &name) const
+{
+    return new QOpenHarmonyPlatformTheme;
+}
+
+void QOpenHarmonyPlatformIntegration::setDefaultDisplayMetrics(int left, int top, int gw, int gh, int sw, int sh, int screenWidth, int screenHeight)
+{
+    m_defaultLeft = left;
+    m_defaultTop = top;
+    m_defaultGeometryWidth = gw;
+    m_defaultGeometryHeight = gh;
+    m_defaultPhysicalSizeWidth = sw;
+    m_defaultPhysicalSizeHeight = sh;
+    m_defaultScreenWidth = screenWidth;
+    m_defaultScreenHeight = screenHeight;
+}
+
+void QOpenHarmonyPlatformIntegration::setDefaultDesktopSize(int gw, int gh)
+{
+    m_defaultScreenWidth = gw;
+    m_defaultScreenHeight = gh;
+}
+
+void QOpenHarmonyPlatformIntegration::setDefaultGeometrySize(int gw, int gh)
+{
+    m_defaultGeometryWidth = gw;
+    m_defaultGeometryHeight = gh;
+}
+
+void QOpenHarmonyPlatformIntegration::setScreenOrientation(Qt::ScreenOrientation currentOrientation,
+                                                       Qt::ScreenOrientation nativeOrientation)
+{
+    m_orientation = currentOrientation;
+    m_nativeOrientation = nativeOrientation;
+}
+
+void QOpenHarmonyPlatformIntegration::flushPendingUpdates()
+{
+    m_primaryScreen->setPhysicalSize(QSize(m_defaultPhysicalSizeWidth,
+                                           m_defaultPhysicalSizeHeight));
+    m_primaryScreen->setSize(QSize(m_defaultScreenWidth, m_defaultScreenHeight));
+    m_primaryScreen->setAvailableGeometry(QRect(m_defaultLeft, m_defaultTop, m_defaultGeometryWidth, m_defaultGeometryHeight));
+}
+
+void QOpenHarmonyPlatformIntegration::setDesktopSize(int left, int top, int width, int height)
+{
+    if (m_primaryScreen.isNull())
+        return;
+    m_primaryScreen->setAvailableGeometry(QRect(left, top, width, height));
+}
+
+void QOpenHarmonyPlatformIntegration::setDisplayMetrics(int width, int height)
+{
+    if (m_primaryScreen.isNull())
+        return;
+    QMetaObject::invokeMethod(m_primaryScreen.data(), "setPhysicalSize", Qt::AutoConnection, Q_ARG(QSize, QSize(width, height)));
+}
+
+void QOpenHarmonyPlatformIntegration::setScreenSize(int width, int height)
+{
+    if (m_primaryScreen.isNull())
+        return;
+    QMetaObject::invokeMethod(m_primaryScreen.data(), "setSize", Qt::AutoConnection, Q_ARG(QSize, QSize(width, height)));
+}
+
+QPlatformFontDatabase *QOpenHarmonyPlatformIntegration::fontDatabase() const
+{
+    return m_harmonyFontDatabase.data();
+}
+
+#ifndef QT_NO_CLIPBOARD
+QPlatformClipboard *QOpenHarmonyPlatformIntegration::clipboard() const
+{
+    return m_platformClipboard.data();
+}
+#endif
+
+#if QT_CONFIG(vulkan)
+
+QPlatformVulkanInstance *QOpenHarmonyPlatformIntegration::createPlatformVulkanInstance(QVulkanInstance *instance) const
+{
+    return new QOpenHarmonyPlatformVulkanInstance(instance);
+}
+
+#endif // QT_CONFIG(vulkan)
+
+void QOpenHarmonyPlatformNativeInterface::customEvent(QEvent *event)
+{
+    if (event->type() != QEvent::User)
+        return;
+
+    QOpenHarmonyPlatformIntegration *api = static_cast<QOpenHarmonyPlatformIntegration *>(QGuiApplicationPrivate::platformIntegration());
+    QtOpenHarmony::setOpenHarmonyPlatformIntegration(api);
+    api->flushPendingUpdates();
+}
+
+
+QT_END_NAMESPACE
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.h b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.h
new file mode 100644
index 0000000000..3058c7010f
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformintegration.h
@@ -0,0 +1,134 @@
+#ifndef QOPENHARMONYPLATFORMINTERATION_H
+#define QOPENHARMONYPLATFORMINTERATION_H
+
+#include <QtGui/qtguiglobal.h>
+
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformmenu.h>
+#include <qpa/qplatformnativeinterface.h>
+#include <qpa/qplatformservices.h>
+
+#include <EGL/egl.h>
+
+#include <memory>
+#include <QScopedPointer>
+
+QT_BEGIN_NAMESPACE
+
+class QTouchDevice;
+class QDesktopWidget;
+class QOpenHarmonyDrag;
+class QPlatformAccessibility;
+class QOpenHarmonyPlatformScreen;
+class QOpenHarmonyPlatformFontDatabase;
+class QOpenHarmonyPlatformInputContext;
+
+
+class QOpenHarmonyPlatformNativeInterface: public QPlatformNativeInterface
+{
+protected:
+    void customEvent(QEvent *event) override;
+};
+
+class QOpenHarmonyPlatformIntegration : public QPlatformIntegration
+{
+    friend class QOpenHarmonyPlatformScreen;
+
+public:
+    QOpenHarmonyPlatformIntegration(const QStringList &paramList);
+    ~QOpenHarmonyPlatformIntegration() override;
+
+    void initialize() override;
+    Qt::KeyboardModifiers queryKeyboardModifiers() const override;
+    bool hasCapability(QPlatformIntegration::Capability cap) const override;
+    QPlatformWindow *createPlatformWindow(QWindow *window) const override;
+    QPlatformWindow *createForeignWindow(QWindow *window, WId nativeHandle) const override;
+    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const override;
+#ifndef QT_NO_OPENGL
+    QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
+#endif
+    QAbstractEventDispatcher *createEventDispatcher() const override;
+    QOpenHarmonyPlatformScreen *screen() { return m_primaryScreen.data(); }
+    QPlatformOffscreenSurface *createPlatformOffscreenSurface(QOffscreenSurface *surface) const override;
+
+    virtual void setDesktopSize(int left, int top, int width, int height);
+    virtual void setDisplayMetrics(int width, int height);
+    void setScreenSize(int width, int height);
+    bool isVirtualDesktop() { return true; }
+
+    QPlatformFontDatabase *fontDatabase() const override;
+
+#ifndef QT_NO_CLIPBOARD
+    QPlatformClipboard *clipboard() const override;
+#endif
+
+    QPlatformInputContext *inputContext() const override;
+    QPlatformNativeInterface *nativeInterface() const override;
+    QPlatformServices *services() const override;
+
+//#ifndef QT_NO_ACCESSIBILITY
+//    virtual QPlatformAccessibility *accessibility() const override;
+//#endif
+
+    QVariant styleHint(StyleHint hint) const override;
+    Qt::WindowState defaultWindowState(Qt::WindowFlags flags) const override;
+
+    QStringList themeNames() const override;
+    QPlatformTheme *createPlatformTheme(const QString &name) const override;
+
+    static void setDefaultDisplayMetrics(int left, int top, int gw, int gh, int sw, int sh, int width, int height);
+    static void setDefaultDesktopSize(int gw, int gh);
+    static void setDefaultGeometrySize(int gw, int gh);
+    static void setScreenOrientation(Qt::ScreenOrientation currentOrientation,
+                                     Qt::ScreenOrientation nativeOrientation);
+
+    static QSize defaultDesktopSize()
+    {
+        return QSize(m_defaultGeometryWidth, m_defaultGeometryHeight);
+    }
+
+    QTouchDevice *touchDevice() const { return m_touchDevice; }
+    void setTouchDevice(QTouchDevice *touchDevice) { m_touchDevice = touchDevice; }
+
+    void flushPendingUpdates();
+
+#if QT_CONFIG(vulkan)
+    QPlatformVulkanInstance *createPlatformVulkanInstance(QVulkanInstance *instance) const;
+#endif // QT_CONFIG(vulkan)
+private:
+    EGLDisplay m_eglDisplay;
+    EGLConfig m_eglConfig;
+    QTouchDevice *m_touchDevice = nullptr;
+
+    QScopedPointer<QOpenHarmonyPlatformScreen> m_primaryScreen;
+
+    QThread *m_mainThread;
+
+    static int m_defaultGeometryWidth;
+    static int m_defaultGeometryHeight;
+    static int m_defaultPhysicalSizeWidth;
+    static int m_defaultPhysicalSizeHeight;
+    static int m_defaultScreenWidth;
+    static int m_defaultScreenHeight;
+    static int m_defaultLeft;
+    static int m_defaultTop;
+
+    static Qt::ScreenOrientation m_orientation;
+    static Qt::ScreenOrientation m_nativeOrientation;
+    static bool m_showPasswordEnabled;
+
+    QScopedPointer<QOpenHarmonyPlatformFontDatabase> m_harmonyFontDatabase;
+
+    QScopedPointer<QPlatformInputContext> m_platformInputContext;
+
+#ifndef QT_NO_CLIPBOARD
+    QScopedPointer<QPlatformClipboard> m_platformClipboard;
+#endif
+
+    QScopedPointer<QPlatformNativeInterface> m_platformNativeInterface;
+    QScopedPointer<QPlatformServices> m_platformServices;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.cpp
new file mode 100644
index 0000000000..def46c762e
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.cpp
@@ -0,0 +1,32 @@
+#include "qopenharmonyplatformoffscreensurface.h"
+
+#include <QtGui/QOffscreenSurface>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformOffscreenSurface::QOpenHarmonyPlatformOffscreenSurface(EGLDisplay display, const QSurfaceFormat &format, QOffscreenSurface *offscreenSurface)
+    : QPlatformOffscreenSurface(offscreenSurface)
+    , m_format(format)
+    , m_display(display)
+    , m_surface(EGL_NO_SURFACE)
+{
+    // Get native handle
+    EGLNativeWindowType surfaceTexture = (EGLNativeWindowType)offscreenSurface->nativeHandle();
+
+    EGLConfig config = q_configFromGLFormat(m_display, m_format, false);
+    if (config) {
+        const EGLint attributes[] = {
+            EGL_NONE
+        };
+        m_surface = eglCreateWindowSurface(m_display, config, surfaceTexture, attributes);
+    }
+}
+
+QOpenHarmonyPlatformOffscreenSurface::~QOpenHarmonyPlatformOffscreenSurface()
+{
+    eglDestroySurface(m_display, m_surface);
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.h b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.h
new file mode 100644
index 0000000000..0b4009d140
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformoffscreensurface.h
@@ -0,0 +1,28 @@
+#ifndef QOPENHARMONYPLATFORMOFFSCREENSURFACETEXTURE_H
+#define QOPENHARMONYPLATFORMOFFSCREENSURFACETEXTURE_H
+
+#include <qpa/qplatformoffscreensurface.h>
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+class QOffscreenSurface;
+class QOpenHarmonyPlatformOffscreenSurface : public QPlatformOffscreenSurface
+{
+public:
+    QOpenHarmonyPlatformOffscreenSurface(EGLDisplay display, const QSurfaceFormat &format,
+                                            QOffscreenSurface *offscreenSurface);
+    ~QOpenHarmonyPlatformOffscreenSurface();
+
+    QSurfaceFormat format() const override { return m_format; }
+    bool isValid() const override { return m_surface != EGL_NO_SURFACE; }
+
+    EGLSurface surface() const { return m_surface; }
+private:
+    QSurfaceFormat m_format;
+    EGLDisplay m_display;
+    EGLSurface m_surface;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMOFFSCREENSURFACETEXTURE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.cpp
new file mode 100644
index 0000000000..fdb3c5cfbb
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.cpp
@@ -0,0 +1,49 @@
+#include "qopenharmonyplatformopenglcontext.h"
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonydefines.h"
+
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+
+#include <QSurface>
+#include <QtGui/private/qopenglcontext_p.h>
+#include <QtGui/QOffscreenSurface>
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformOpenGLContext::QOpenHarmonyPlatformOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display, EGLConfig *config,
+                                                             const QVariant &nativeHandle)
+    :QEGLPlatformContext(format, share, display, config, nativeHandle)
+{
+}
+
+//void QOpenHarmonyPlatformOpenGLContext::swapBuffers(QPlatformSurface *surface)
+//{
+//    if (surface->surface()->surfaceClass() == QSurface::Window &&
+//            static_cast<QOpenHarmonyPlatformOpenGLWindow *>(surface)->checkNativeSurface(eglConfig())) {
+//        QEGLPlatformContext::makeCurrent(surface);
+//    }
+
+//    QEGLPlatformContext::swapBuffers(surface);
+//}
+
+//bool QOpenHarmonyPlatformOpenGLContext::makeCurrent(QPlatformSurface *surface)
+//{
+//    return QEGLPlatformContext::makeCurrent(surface);
+//}
+
+EGLSurface QOpenHarmonyPlatformOpenGLContext::eglSurfaceForPlatformSurface(QPlatformSurface *surface)
+{
+    if (surface->surface()->surfaceClass() == QSurface::Window) {
+        return static_cast<QOpenHarmonyPlatformOpenGLWindow *>(surface)->eglSurface(eglConfig());
+    } else {
+        auto platformOffscreenSurface = static_cast<QPlatformOffscreenSurface*>(surface);
+        if (platformOffscreenSurface->offscreenSurface()->nativeHandle())
+            return 0;
+//            return static_cast<QOpenHarmonyPlatformOffscreenSurface *>(surface)->surface();
+        else
+            return static_cast<QEGLPbuffer *>(surface)->pbuffer();
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.h b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.h
new file mode 100644
index 0000000000..c885aa5fec
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglcontext.h
@@ -0,0 +1,22 @@
+#ifndef QOPENHARMONYPLATFORMOPENGLCONTEXT_H
+#define QOPENHARMONYPLATFORMOPENGLCONTEXT_H
+
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformOpenGLContext : public QEGLPlatformContext
+{
+public:
+    QOpenHarmonyPlatformOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display, EGLConfig *config, const QVariant &nativeHandle);
+//    void swapBuffers(QPlatformSurface *surface) override;
+//    bool makeCurrent(QPlatformSurface *surface) override;
+
+private:
+    EGLSurface eglSurfaceForPlatformSurface(QPlatformSurface *surface) override;
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMOPENGLCONTEXT_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.cpp
new file mode 100644
index 0000000000..e816db99c2
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.cpp
@@ -0,0 +1,267 @@
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonyjsobject.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyjswindowmanager.h"
+#include "qopenharmonyjswindow.h"
+#include "qopenharmonymain.h"
+
+#include <QTimer>
+#include <QPainter>
+#include <QStaticText>
+#include <QSurfaceFormat>
+#include <QtGui/private/qwindow_p.h>
+#include <QtGui/qguiapplication.h>
+
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformscreen.h>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+QT_BEGIN_NAMESPACE
+enum {
+    defaultWindowWidth = 800,
+    defaultWindowHeight = 600
+};
+
+QOpenHarmonyPlatformOpenGLWindow::QOpenHarmonyPlatformOpenGLWindow(QWindow *window, EGLDisplay display)
+    :QOpenHarmonyPlatformWindow(window), m_eglDisplay(display), m_jsWindow(nullptr)
+{   
+}
+
+QOpenHarmonyPlatformOpenGLWindow::~QOpenHarmonyPlatformOpenGLWindow()
+{    
+    clearEgl();
+    if (m_jsWindow != nullptr) {
+        m_jsWindow->setQtWindow(nullptr);
+        qJsWindowManager->destoryWindow(m_jsWindow);
+        m_jsWindow = nullptr;
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::initialize()
+{
+    QOpenHarmonyPlatformWindow::initialize();
+    QRect rect = initialGeometry(window(),
+                                 window()->geometry(), defaultWindowWidth, defaultWindowHeight);
+    QOpenHarmonyPlatformWindow::setGeometry(rect);
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::repaint()
+{
+    m_jsWindow->repaint();
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::setGeometry(const QRect &rect)
+{
+    QOpenHarmonyPlatformWindow::setGeometry(rect);
+    if (m_jsWindow == nullptr)
+        return;
+    // 设置jswindow的尺寸
+    m_jsWindow->setGeometry(rect);
+    if (m_windowState & Qt::WindowNoState)
+        m_normalGeometry = rect;
+}
+
+EGLSurface QOpenHarmonyPlatformOpenGLWindow::surface()
+{
+    if (m_jsWindow == nullptr) {
+        createJsWindow();
+    }
+
+    return m_jsWindow == nullptr ? EGL_NO_SURFACE : m_jsWindow->eglSurface();
+}
+
+EGLSurface QOpenHarmonyPlatformOpenGLWindow::eglSurface(EGLConfig config)
+{
+    if (QGuiApplication::applicationState() == Qt::ApplicationSuspended)
+        return m_eglSurface;
+
+    if (m_eglSurface == EGL_NO_SURFACE) {
+        checkNativeSurface(config);
+    }
+    return m_eglSurface;
+}
+
+bool QOpenHarmonyPlatformOpenGLWindow::checkNativeSurface(EGLConfig config)
+{
+    createEgl(config);
+    // we've create another surface, the window should be repainted
+    QRect availableGeometry = screen()->availableGeometry();
+    if (geometry().width() > 0 && geometry().height() > 0 && availableGeometry.width() > 0 && availableGeometry.height() > 0)
+        QWindowSystemInterface::handleExposeEvent(window(), QRegion(QRect(QPoint(), geometry().size())));
+    return true;
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::applicationStateChanged(Qt::ApplicationState state)
+{
+    QOpenHarmonyPlatformWindow::applicationStateChanged(state);
+    if (state <=  Qt::ApplicationHidden) {
+        clearEgl();
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::propagateSizeHints()
+{
+    if (m_jsWindow == nullptr)
+        return;
+    QSize minimumSize = windowMinimumSize();
+    QSize maximumSize = windowMaximumSize();
+    m_jsWindow->setWindowLimits(minimumSize, maximumSize);
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::createEgl(EGLConfig config)
+{
+//    clearEgl();
+    EGLint winAttribs[] = {EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR, EGL_NONE};
+    m_eglSurface = surface();
+    m_format = q_glFormatFromConfig(m_eglDisplay, config, window()->requestedFormat());
+    if (Q_UNLIKELY(m_eglSurface == EGL_NO_SURFACE)) {
+        EGLint error = eglGetError();
+        eglTerminate(m_eglDisplay);
+        LOGW("EGL Error : Could not create the egl surface: error = 0x%{public}d\n", error);
+    }
+}
+
+QSurfaceFormat QOpenHarmonyPlatformOpenGLWindow::format() const
+{
+    if (m_eglSurface == 0)
+        return window()->requestedFormat();
+    else
+        return m_format;
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::setWindowState(Qt::WindowStates state)
+{
+    QOpenHarmonyPlatformWindow::setWindowState(state);
+    if (state == m_windowState)
+        return;
+    m_windowState = state;
+    if (m_jsWindow == nullptr || !m_jsWindow->isVisible())
+        return;
+    setWindowState_sys(m_windowState);
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::clearEgl()
+{
+    if (m_eglSurface != EGL_NO_SURFACE) {
+        eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::createJsWindow() const
+{
+    qDebug() << "create open harmony window for" << this;
+    QOpenHarmonyPlatformOpenGLWindow *self = const_cast<QOpenHarmonyPlatformOpenGLWindow *>(this);
+    m_jsWindow = qJsWindowManager->createWindow(self);
+    if (m_jsWindow != nullptr)
+        return;
+    if (isTopLevelWindow()) {
+        m_jsWindow->startListener();
+        self->propagateSizeHints();
+    }
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::paint(const QImage &image, const QRegion &region, const QPoint &offset)
+{
+    if (m_jsWindow == nullptr || !isExposed())
+        return;
+    QImage windowImage = image;
+#ifdef USE_MASK
+    QPainter compositePainter(&windowImage);
+    compositePainter.save();
+    compositePainter.setBrush(QBrush(Qt::red));
+    QString ct("managed by isoftstone");
+    QStaticText sct(ct);
+    QFontMetrics fm(compositePainter.font());
+    int height = fm.height();
+    int width = fm.horizontalAdvance(ct);
+    QPoint tp = windowImage.rect().bottomRight();
+    tp.rx() -= (width + 2);
+    tp.ry() -= (height + 2);
+    compositePainter.drawStaticText(tp, sct);
+    compositePainter.restore();
+#endif
+    m_jsWindow->paint(windowImage, region, offset);
+}
+
+EGLDisplay QOpenHarmonyPlatformOpenGLWindow::eglDisplay() const
+{
+    return m_eglDisplay;
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::setVisible(bool visible)
+{    
+    QOpenHarmonyPlatformWindow::setVisible(visible);
+    if (m_jsWindow == nullptr) {
+        createJsWindow();
+    }
+
+    if (m_jsWindow == nullptr) {
+        return;
+    }
+    if (visible) {
+        const QWindow *w = window();
+        const Qt::WindowFlags flags = w->flags();
+        setWindowState_sys(m_windowState);
+    } else {
+        m_jsWindow->setVisible(visible);
+    }
+}
+
+QOpenHarmonyJsWindow *QOpenHarmonyPlatformOpenGLWindow::jsWindow() const
+{
+    return m_jsWindow;
+}
+
+void QOpenHarmonyPlatformOpenGLWindow::handleGeometryChange()
+{
+    QRect rect = m_jsWindow->jsGeometry();
+    QOpenHarmonyPlatformWindow::setGeometry(rect);
+    QWindowSystemInterface::handleExposeEvent(window(), rect);
+}
+
+WId QOpenHarmonyPlatformOpenGLWindow::winId() const
+{
+    if (m_jsWindow == nullptr)
+        createJsWindow();
+    if (m_jsWindow == nullptr)
+        return 0;
+    return m_jsWindow->id();
+}
+
+QMargins QOpenHarmonyPlatformOpenGLWindow::frameMargins() const
+{
+    if (m_jsWindow == nullptr)
+        return QMargins();
+    QMargins m = m_jsWindow->frameMargins();
+    return m;
+}
+
+
+void QOpenHarmonyPlatformOpenGLWindow::setWindowState_sys(Qt::WindowStates state)
+{
+    if (m_jsWindow == nullptr)
+        return;
+
+    if (state & Qt::WindowFullScreen)
+        m_jsWindow->showFullScreen();
+    else if (state & Qt::WindowMaximized)
+        m_jsWindow->showMaximized();
+    else if (state == Qt::WindowMinimized) {
+        m_jsWindow->showMinimized();
+    } else if (state == Qt::WindowNoState) {
+        m_jsWindow->setGeometry(geometry());
+        m_jsWindow->showNormal();
+    }
+    // 在Pad上,XComponent接收不到SurfaceChanged事件,手动触发
+    if (QtOpenHarmony::defaultShowIsMaximized) {
+        m_jsWindow->handleSurfaceChanged();
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.h b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.h
new file mode 100644
index 0000000000..dc096311d9
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformopenglwindow.h
@@ -0,0 +1,62 @@
+#ifndef QOPENHARMONYPLATFORMOPENGLWINDOW_H
+#define QOPENHARMONYPLATFORMOPENGLWINDOW_H
+
+#include <QHash>
+#include <EGL/egl.h>
+#include "qopenharmonyplatformwindow.h"
+
+QT_BEGIN_NAMESPACE
+class QOpenHarmonyJsObject;
+class QOpenHarmonyJsWindow;
+
+class QOpenHarmonyPlatformOpenGLWindow : public QOpenHarmonyPlatformWindow
+{
+public:
+    explicit QOpenHarmonyPlatformOpenGLWindow(QWindow *window, EGLDisplay display);
+    ~QOpenHarmonyPlatformOpenGLWindow() override;
+
+    void initialize() override;
+
+    void setGeometry(const QRect &rect) override;
+
+    EGLSurface eglSurface(EGLConfig config);
+    QSurfaceFormat format() const override;
+
+    virtual void setWindowState(Qt::WindowStates state) override;
+    bool checkNativeSurface(EGLConfig config);
+
+    void applicationStateChanged(Qt::ApplicationState) override;
+    void propagateSizeHints() override;
+
+    void repaint() override;
+    EGLDisplay eglDisplay() const;
+
+    void setVisible(bool visible);
+
+    QOpenHarmonyJsWindow *jsWindow() const;
+
+    virtual void handleGeometryChange();
+
+    WId winId() const override;
+
+    QMargins frameMargins() const;
+
+    void paint(const QImage &image, const QRegion &region, const QPoint &offset);
+protected:
+    void setWindowState_sys(Qt::WindowStates state);
+    EGLSurface surface();
+    void createEgl(EGLConfig config);
+    void clearEgl();
+    void createJsWindow() const;
+
+private:
+    EGLDisplay m_eglDisplay = EGL_NO_DISPLAY;
+    EGLSurface m_eglSurface = EGL_NO_SURFACE;
+    QSurfaceFormat m_format;
+    mutable QOpenHarmonyJsWindow *m_jsWindow = nullptr;
+    Qt::WindowStates m_windowState = Qt::WindowNoState;
+    QRect m_normalGeometry;
+};
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYPLATFORMOPENGLWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformplugin.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformplugin.cpp
new file mode 100644
index 0000000000..c4cb6257c3
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformplugin.cpp
@@ -0,0 +1,26 @@
+#include <qpa/qplatformintegrationplugin.h>
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonydefines.h"
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformIntegrationPlugin: public QPlatformIntegrationPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "openharmony.json")
+public:
+    QPlatformIntegration *create(const QString &key, const QStringList &paramList) override;
+};
+
+
+QPlatformIntegration *QOpenHarmonyPlatformIntegrationPlugin::create(const QString &key, const QStringList &paramList)
+{
+    Q_UNUSED(paramList);
+    if (!key.compare(QLatin1String("openharmony"), Qt::CaseInsensitive))
+        return new QOpenHarmonyPlatformIntegration(paramList);
+    return 0;
+}
+
+QT_END_NAMESPACE
+#include "qopenharmonyplatformplugin.moc"
+
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.cpp
new file mode 100644
index 0000000000..31773b94a4
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.cpp
@@ -0,0 +1,169 @@
+#include <QTime>
+
+#ifdef USE_MASK
+#include <QBrush>
+#endif
+
+#include <QStaticText>
+#include <qpa/qwindowsysteminterface.h>
+
+#include "qopenharmonymain.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonyplatformbackingstore.h"
+#include "qopenharmonyplatformintegration.h"
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonyplatformopenglwindow.h"
+#include "qopenharmonydefines.h"
+#include "qopenharmonyplatformcursor.h"
+
+#include <qguiapplication.h>
+
+#include <QtGui/QGuiApplication>
+#include <QtGui/QWindow>
+#include <QtGui/private/qwindow_p.h>
+#include <QtEglSupport/private/qt_egl_p.h>
+
+#include <vector>
+
+QT_BEGIN_NAMESPACE
+
+
+QOpenHarmonyPlatformScreen::QOpenHarmonyPlatformScreen()
+    : QObject(), QPlatformScreen(), m_cursor(new QOpenHarmonyPlatformCursor(this))
+{
+    m_availableGeometry = QRect(QOpenHarmonyPlatformIntegration::m_defaultLeft, QOpenHarmonyPlatformIntegration::m_defaultTop, QOpenHarmonyPlatformIntegration::m_defaultGeometryWidth, QOpenHarmonyPlatformIntegration::m_defaultGeometryHeight);
+    m_size = QSize(QOpenHarmonyPlatformIntegration::m_defaultScreenWidth, QOpenHarmonyPlatformIntegration::m_defaultScreenHeight);
+
+    m_format = QImage::Format_RGBA8888_Premultiplied;
+    m_depth = 32;
+    m_physicalSize.setHeight(QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeHeight);
+    m_physicalSize.setWidth(QOpenHarmonyPlatformIntegration::m_defaultPhysicalSizeWidth);
+}
+
+QOpenHarmonyPlatformScreen::~QOpenHarmonyPlatformScreen()
+{
+
+}
+
+QWindow *QOpenHarmonyPlatformScreen::topWindow() const
+{
+    for (QOpenHarmonyPlatformWindow *w : m_windowStack) {
+        if (w->window()->type() == Qt::Window ||
+                w->window()->type() == Qt::Popup ||
+                w->window()->type() == Qt::Dialog) {
+            return w->window();
+        }
+    }
+    return nullptr;
+}
+
+QWindow *QOpenHarmonyPlatformScreen::topLevelAt(const QPoint &p) const
+{
+    for (QOpenHarmonyPlatformWindow *w : m_windowStack) {
+        if (w->geometry().contains(p, false) && w->window()->isVisible())
+            return w->window();
+    }
+    return nullptr;
+}
+
+void QOpenHarmonyPlatformScreen::addWindow(QOpenHarmonyPlatformWindow *window)
+{
+    if (m_windowStack.contains(window))
+        return;
+    m_windowStack.prepend(window);
+
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+}
+
+void QOpenHarmonyPlatformScreen::removeWindow(QOpenHarmonyPlatformWindow *window)
+{
+    if (!m_windowStack.contains(window))
+        return;
+    m_windowStack.removeOne(window);
+
+
+    QWindow *w = topWindow();
+    if (w == nullptr)
+        return;
+    QWindowSystemInterface::handleWindowActivated(w);
+}
+
+void QOpenHarmonyPlatformScreen::raise(QOpenHarmonyPlatformWindow *window)
+{
+    int index = m_windowStack.indexOf(window);
+    if (index <= 0)
+        return;
+    m_windowStack.move(index, 0);
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+}
+
+void QOpenHarmonyPlatformScreen::lower(QOpenHarmonyPlatformWindow *window)
+{
+    int index = m_windowStack.indexOf(window);
+    if (index == -1 || index == (m_windowStack.size() - 1))
+        return;
+    m_windowStack.move(index, m_windowStack.size() - 1);
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+}
+
+void QOpenHarmonyPlatformScreen::setPhysicalSize(const QSize &size)
+{
+    m_physicalSize = size;
+}
+
+void QOpenHarmonyPlatformScreen::setSize(const QSize &size)
+{
+    m_size = size;
+    QWindowSystemInterface::handleScreenGeometryChange(QPlatformScreen::screen(), geometry(), availableGeometry());
+}
+
+void QOpenHarmonyPlatformScreen::setAvailableGeometry(const QRect &rect)
+{
+    if (m_availableGeometry == rect)
+        return;
+
+    QRect oldGeometry = m_availableGeometry;
+
+    m_availableGeometry = rect;
+
+    QWindowSystemInterface::handleScreenGeometryChange(QPlatformScreen::screen(), geometry(), availableGeometry());
+    resizeMaximizedWindows();
+
+    if (oldGeometry.width() == 0 && oldGeometry.height() == 0 && rect.width() > 0 && rect.height() > 0) {
+        QList<QWindow *> windows = QGuiApplication::allWindows();
+        for (int i = 0; i < windows.size(); ++i) {
+            QWindow *w = windows.at(i);
+            if (w->handle()) {
+                QRect geometry = w->handle()->geometry();
+                if (geometry.width() > 0 && geometry.height() > 0)
+                    QWindowSystemInterface::handleExposeEvent(w, QRect(QPoint(0, 0), geometry.size()));
+            }
+        }
+    }
+}
+
+QDpi QOpenHarmonyPlatformScreen::logicalDpi() const
+{
+    qreal lDpi = QtOpenHarmony::scaledDensity() * 72;
+    return QDpi(lDpi, lDpi);
+}
+
+qreal QOpenHarmonyPlatformScreen::pixelDensity() const
+{
+    return QtOpenHarmony::pixelDensity();
+}
+
+Qt::ScreenOrientation QOpenHarmonyPlatformScreen::orientation() const
+{
+    return QOpenHarmonyPlatformIntegration::m_orientation;
+}
+
+Qt::ScreenOrientation QOpenHarmonyPlatformScreen::nativeOrientation() const
+{
+    return QOpenHarmonyPlatformIntegration::m_nativeOrientation;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.h b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.h
new file mode 100644
index 0000000000..a9761d58dd
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformscreen.h
@@ -0,0 +1,61 @@
+#ifndef QOPENHARMONYPLATFORMSCREEN_H
+#define QOPENHARMONYPLATFORMSCREEN_H
+
+#include <qpa/qplatformscreen.h>
+#include <native_window/external_window.h>
+#include <QList>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformWindow;
+
+class QOpenHarmonyPlatformScreen: public QObject, public QPlatformScreen
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformScreen();
+    ~QOpenHarmonyPlatformScreen();
+
+    QRect geometry() const override { return QRect(QPoint(), m_size); }
+    QRect availableGeometry() const override { return m_availableGeometry; }
+    int depth() const override { return m_depth; }
+    QImage::Format format() const override { return m_format; }
+    QSizeF physicalSize() const override { return m_physicalSize; }
+
+    inline QWindow *topWindow() const;
+    QWindow *topLevelAt(const QPoint & p) const override;
+
+    // compositor api
+    void addWindow(QOpenHarmonyPlatformWindow *window);
+    void removeWindow(QOpenHarmonyPlatformWindow *window);
+    void raise(QOpenHarmonyPlatformWindow *window);
+    void lower(QOpenHarmonyPlatformWindow *window);
+
+    using CursorPtr = QScopedPointer<QPlatformCursor>;
+    QPlatformCursor *cursor() const override { return m_cursor.data(); }
+
+
+public slots:
+    void setPhysicalSize(const QSize &size);
+    void setAvailableGeometry(const QRect &rect);
+    void setSize(const QSize &size);
+private:
+    typedef QList<QOpenHarmonyPlatformWindow *> WindowStackType;
+    WindowStackType m_windowStack;
+
+    QRect m_availableGeometry;
+    int m_depth;
+    QImage::Format m_format;
+    QSizeF m_physicalSize;
+    QSize m_size;
+
+    const CursorPtr m_cursor;
+private:
+    QDpi logicalDpi() const override;
+    qreal pixelDensity()  const override;
+    Qt::ScreenOrientation orientation() const override;
+    Qt::ScreenOrientation nativeOrientation() const override;
+};
+
+QT_END_NAMESPACE
+#endif
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformservices.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformservices.cpp
new file mode 100644
index 0000000000..055b1b7991
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformservices.cpp
@@ -0,0 +1,46 @@
+#include "qopenharmonyplatformservices.h"
+
+#include <QUrl>
+#include <QThread>
+#include <QtCore/qopenharmonydefines.h>
+
+QT_BEGIN_NAMESPACE
+
+
+
+bool QOpenHarmonyPlatformServices::openUrl(const QUrl &url)
+{
+    QUrl theUrl(url);
+
+    if (m_jsService.isNull())
+    {
+        m_jsService = qJsObjectLoader->create("JsServices");
+    }
+    QString urlStr = theUrl.toString();
+    //短时间重复使用鸿蒙的want打开网址，可能会导致传递的url丢失
+    QThread::msleep(300);
+    bool result = m_jsService->call<bool>("openUrl", urlStr);
+    return result;
+}
+
+
+//TODO
+bool QOpenHarmonyPlatformServices::openDocument(const QUrl &url)
+{
+     return false;
+}
+
+//TODO
+QByteArray QOpenHarmonyPlatformServices::desktopEnvironment() const
+{
+    return nullptr;
+}
+
+
+
+
+
+
+
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformservices.h b/src/plugins/platforms/openharmony/qopenharmonyplatformservices.h
new file mode 100644
index 0000000000..b41060aaa0
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformservices.h
@@ -0,0 +1,25 @@
+#ifndef QOPENHARMONYPLATFORMSERVICES_H
+#define QOPENHARMONYPLATFORMSERVICES_H
+
+#include <qpa/qplatformservices.h>
+#include <QOpenHarmonyJsObject>
+#include <QOpenHarmonyJsObjectLoader>
+
+QT_BEGIN_NAMESPACE
+
+
+class QOpenHarmonyPlatformServices : public QPlatformServices
+{
+public:
+    bool openUrl(const QUrl &url) override;
+    bool openDocument(const QUrl &url) override;
+    QByteArray desktopEnvironment() const override;
+
+private:
+    QSharedPointer<QOpenHarmonyJsObject> m_jsService;
+};
+
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.cpp
new file mode 100644
index 0000000000..f9fc3685a1
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.cpp
@@ -0,0 +1,140 @@
+#include <qcolor.h>
+#include <qpalette.h>
+#include "qopenharmonyplatformtheme.h"
+#include "qopenharmonyplatformdialoghelpers.h"
+
+#include <QCoreApplication>
+#include <private/qguiapplication_p.h>
+
+static QPalette qt_harmonyPalette()
+{
+#if 1
+    QColor base(250, 250, 250);
+    QColor text("#182431");
+    QColor background(250, 250, 250);
+    QColor light = background.lighter(150);
+    QColor mid(background.darker(130));
+    QColor midLight = mid.lighter(110);
+    QColor disabledBase(background);
+    QColor dark = background.darker(150);
+    QColor darkDisabled = dark.darker(110);
+    QColor highlightedText = Qt::black;
+    QColor disabledText = QColor(190, 190, 190);
+    QColor button(241, 241, 241);
+    QColor shadow(201, 201, 201);
+    QColor highlight(0, 120, 215);
+    QColor disabledShadow = shadow.lighter(150);
+
+    QPalette harmonyPalette = QPalette(Qt::black, background, light, dark, mid, text, base);
+    harmonyPalette.setColor(QPalette::Disabled, QPalette::ButtonText, Qt::gray);
+    harmonyPalette.setColor(QPalette::Disabled, QPalette::Text, Qt::gray);
+    harmonyPalette.setBrush(QPalette::Midlight, midLight);
+    harmonyPalette.setBrush(QPalette::Button, button);
+    harmonyPalette.setBrush(QPalette::Shadow, shadow);
+    harmonyPalette.setBrush(QPalette::HighlightedText, highlightedText);
+
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::Text, disabledText);
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::WindowText, disabledText);
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::ButtonText, disabledText);
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::Base, disabledBase);
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::Dark, darkDisabled);
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::Shadow, disabledShadow);
+
+    harmonyPalette.setBrush(QPalette::Active, QPalette::Highlight, highlight);
+    harmonyPalette.setBrush(QPalette::Inactive, QPalette::Highlight, highlight);
+    harmonyPalette.setBrush(QPalette::Disabled, QPalette::Highlight, highlight.lighter(150));
+    return harmonyPalette;
+#endif
+
+#if 0
+    QColor backGround(239, 239, 239);
+    QColor light = backGround.lighter(150);
+    QColor mid(backGround.darker(130));
+    QColor midLight = mid.lighter(110);
+    QColor base = Qt::white;
+    QColor disabledBase(backGround);
+    QColor dark = backGround.darker(150);
+    QColor darkDisabled = QColor(209, 209, 209).darker(110);
+    QColor text = Qt::black;
+    QColor hightlightedText = Qt::white;
+    QColor disabledText = QColor(190, 190, 190);
+    QColor button = backGround;
+    QColor shadow = dark.darker(135);
+    QColor disabledShadow = shadow.lighter(150);
+
+    QPalette fusionPalette(Qt::black,backGround,light,dark,mid,text,base);
+    fusionPalette.setBrush(QPalette::Midlight, midLight);
+    fusionPalette.setBrush(QPalette::Button, button);
+    fusionPalette.setBrush(QPalette::Shadow, shadow);
+    fusionPalette.setBrush(QPalette::HighlightedText, hightlightedText);
+
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::Text, disabledText);
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::WindowText, disabledText);
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::ButtonText, disabledText);
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::Base, disabledBase);
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::Dark, darkDisabled);
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::Shadow, disabledShadow);
+
+    fusionPalette.setBrush(QPalette::Active, QPalette::Highlight, QColor(48, 140, 198));
+    fusionPalette.setBrush(QPalette::Inactive, QPalette::Highlight, QColor(48, 140, 198));
+    fusionPalette.setBrush(QPalette::Disabled, QPalette::Highlight, QColor(145, 145, 145));
+    return fusionPalette;
+#endif
+}
+
+QOpenHarmonyPlatformTheme::QOpenHarmonyPlatformTheme()
+{
+    QGuiApplication::setPalette(qt_harmonyPalette());
+}
+
+QString QOpenHarmonyPlatformTheme::standardButtonText(int button) const
+{
+    switch (button) {
+    case QPlatformDialogHelper::Yes:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "Yes");
+    case QPlatformDialogHelper::YesToAll:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "Yes to All");
+    case QPlatformDialogHelper::No:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "No");
+    case QPlatformDialogHelper::NoToAll:
+        return QCoreApplication::translate("QOpenHarmonyPlatformTheme", "No to All");
+    }
+    return QPlatformTheme::standardButtonText(button);
+}
+
+bool QOpenHarmonyPlatformTheme::usePlatformNativeDialog(QPlatformTheme::DialogType type) const
+{
+    Q_UNUSED(type)
+    return true;
+}
+
+const QPalette *QOpenHarmonyPlatformTheme::palette(Palette type) const
+{
+    if (type == QPlatformTheme::SystemPalette) {
+        QPalette *p = new QPalette(qt_harmonyPalette());
+        return p;
+    }
+    return nullptr;
+}
+
+QPlatformDialogHelper *QOpenHarmonyPlatformTheme::createPlatformDialogHelper(QPlatformTheme::DialogType type) const
+{
+    switch (type) {
+//    case MessageDialog:
+//        return new QOpenHarmonyPlatformMessageDialogHelper;
+    case FileDialog:
+        return new QOpenHarmonyPlatformFileDialogHelper;
+    default:
+        return 0;
+    }
+}
+
+QVariant QOpenHarmonyPlatformTheme::themeHint(ThemeHint hint) const
+{
+    switch(hint) {
+    case ThemeHint::StyleNames:
+        return QVariant(QStringList{ "harmonyos", "openharmony" }); /* FIXME 暂时认为OpenHarmony HarmonyOS是两种不同的主题样式 */
+    default:
+        return QPlatformTheme::themeHint(hint);
+    }
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.h b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.h
new file mode 100644
index 0000000000..34ee717e33
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformtheme.h
@@ -0,0 +1,18 @@
+#ifndef QOPENHARMONYPLATFORMTHEME_H
+#define QOPENHARMONYPLATFORMTHEME_H
+
+#include <QtCore/qvariant.h>
+#include <qpa/qplatformtheme.h>
+
+class QOpenHarmonyPlatformTheme: public QPlatformTheme
+{
+public:
+    QOpenHarmonyPlatformTheme();
+    QVariant themeHint(ThemeHint hint) const override;
+    virtual QString standardButtonText(int button) const override;
+    bool usePlatformNativeDialog(DialogType type) const override;
+    const QPalette *palette(Palette type = SystemPalette) const override;
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const override;
+};
+
+#endif // QOPENHARMONYPLATFORMTHEME_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.cpp
new file mode 100644
index 0000000000..5c6af22330
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.cpp
@@ -0,0 +1,28 @@
+#include "qopenharmonylog.h"
+#include "qopenharmonyplatformvulkaninstance.h"
+
+QT_BEGIN_NAMESPACE
+
+QOpenHarmonyPlatformVulkanInstance::QOpenHarmonyPlatformVulkanInstance(QVulkanInstance *instance)
+    : m_instance(instance)
+{
+    m_lib.setFileName(QStringLiteral("vulkan"));
+
+    if (!m_lib.load()) {
+        LOGW("Failed to load %{public}s", qPrintable(m_lib.fileName()));
+        return;
+    }
+
+    init(&m_lib);
+}
+
+void QOpenHarmonyPlatformVulkanInstance::createOrAdoptInstance()
+{
+    initInstance(m_instance, QByteArrayList() << QByteArrayLiteral("VK_OHOS_surface") << QByteArrayLiteral("VK_KHR_surface"));
+}
+
+QOpenHarmonyPlatformVulkanInstance::~QOpenHarmonyPlatformVulkanInstance()
+{
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.h b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.h
new file mode 100644
index 0000000000..27803ba6a1
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformvulkaninstance.h
@@ -0,0 +1,24 @@
+#ifndef QOPENHARMONYPLATFORMVULKANINSTANCE_H
+#define QOPENHARMONYPLATFORMVULKANINSTANCE_H
+
+#include <QtVulkanSupport/private/qbasicvulkanplatforminstance_p.h>
+#include <QLibrary>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformVulkanInstance : public QBasicPlatformVulkanInstance
+{
+public:
+    QOpenHarmonyPlatformVulkanInstance(QVulkanInstance *instance);
+    ~QOpenHarmonyPlatformVulkanInstance();
+
+    void createOrAdoptInstance() override;
+
+private:
+    QVulkanInstance *m_instance;
+    QLibrary m_lib;
+};
+
+QT_END_NAMESPACE
+
+#endif // QOPENHARMONYPLATFORMVULKANINSTANCE_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.cpp b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.cpp
new file mode 100644
index 0000000000..e426be5da1
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.cpp
@@ -0,0 +1,275 @@
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonyplatformscreen.h"
+#include "qopenharmonymain.h"
+
+#include <QMetaObject>
+#include <qguiapplication.h>
+#include <QtCore/qopenharmonydefines.h>
+#include <qpa/qwindowsysteminterface.h>
+#include <QtGui/private/qhighdpiscaling_p.h>
+#include <QtCore/qopenharmonyjsenvironment.h>
+
+QT_BEGIN_NAMESPACE
+
+
+static QList<QOpenHarmonyPlatformWindow *> allWindows;
+
+QOpenHarmonyPlatformWindow::QOpenHarmonyPlatformWindow(QWindow *window)
+    : QPlatformWindow(window)    
+{
+}
+
+QOpenHarmonyPlatformWindow::~QOpenHarmonyPlatformWindow()
+{
+    allWindows.removeOne(this);
+}
+
+void QOpenHarmonyPlatformWindow::initialize()
+{
+    setWindowState(window()->windowStates());
+    m_helper.reset(new QOpenHarmonyPlatformWindowHelper(this));
+    allWindows.append(this);
+    m_hasFrame = detectionWindowHasFrame();
+}
+
+void QOpenHarmonyPlatformWindow::lower()
+{
+    platformScreen()->lower(this);
+}
+
+void QOpenHarmonyPlatformWindow::raise()
+{
+    platformScreen()->raise(this);
+}
+
+void QOpenHarmonyPlatformWindow::setOpacity(qreal level)
+{
+    /* TODO 需要控制整个窗体的透明度 */
+    Q_UNUSED(level);
+}
+
+void QOpenHarmonyPlatformWindow::setVisible(bool visible)
+{
+    if (visible) {
+        platformScreen()->addWindow(this);
+    } else {
+        platformScreen()->removeWindow(this);
+    }
+    QPlatformWindow::setVisible(visible);
+}
+
+void QOpenHarmonyPlatformWindow::setGeometry(const QRect &rect)
+{
+    QPlatformWindow::setGeometry(rect);
+    QWindowSystemInterface::handleGeometryChange(window(), rect);
+}
+
+bool QOpenHarmonyPlatformWindow::isTopLevelWindow() const
+{
+    return window()->isTopLevel();
+}
+
+bool QOpenHarmonyPlatformWindow::hasFrame() const
+{
+    return m_hasFrame;
+
+}
+
+bool QOpenHarmonyPlatformWindow::hasFocus() const
+{
+    Qt::WindowType type = static_cast<Qt::WindowType>(int(window()->flags()) & Qt::WindowType_Mask);
+    return !((type == Qt::Popup) || (type == Qt::ToolTip) || (type == Qt::Tool));
+}
+
+QMargins QOpenHarmonyPlatformWindow::frameMargins() const
+{
+    return QMargins();
+}
+
+QString QOpenHarmonyPlatformWindow::parentWindowName() const
+{
+    QOpenHarmonyPlatformWindow *p = dynamic_cast<QOpenHarmonyPlatformWindow *>(parent());
+    if (p == nullptr)
+        return QString();
+    return p->windowName();
+}
+
+QOpenHarmonyPlatformWindowHelper *QOpenHarmonyPlatformWindow::helper() const
+{
+    return m_helper.data();
+}
+
+void QOpenHarmonyPlatformWindow::setParent(const QPlatformWindow *window)
+{
+    Q_UNUSED(window);
+}
+
+void QOpenHarmonyPlatformWindow::setWId(WId nativeHandle)
+{
+    m_windowId = nativeHandle;
+}
+
+QOpenHarmonyPlatformScreen *QOpenHarmonyPlatformWindow::platformScreen() const
+{
+    return static_cast<QOpenHarmonyPlatformScreen *>(window()->screen()->handle());
+}
+
+void QOpenHarmonyPlatformWindow::setWindowTitle(const QString &title)
+{
+    m_title = title;
+}
+
+QString QOpenHarmonyPlatformWindow::windowTitle() const
+{
+    return formatWindowTitle(m_title, " - ");
+}
+
+void QOpenHarmonyPlatformWindow::setWindowName(const QString &name)
+{
+    m_name = name;
+}
+
+QString QOpenHarmonyPlatformWindow::windowName() const
+{
+    return m_name;
+}
+
+void QOpenHarmonyPlatformWindow::requestActivateWindow()
+{
+
+}
+
+bool QOpenHarmonyPlatformWindow::isExposed() const
+{
+    return qApp->applicationState() > Qt::ApplicationHidden
+            && window()->isVisible()
+            && !window()->geometry().isEmpty();
+}
+
+void QOpenHarmonyPlatformWindow::applicationStateChanged(Qt::ApplicationState)
+{
+    QRegion region;
+    if (isExposed())
+        region = geometry();
+
+    QWindowSystemInterface::handleExposeEvent(window(), region);
+    QWindowSystemInterface::flushWindowSystemEvents();
+}
+
+QOpenHarmonyPlatformWindowHelper::QOpenHarmonyPlatformWindowHelper(QOpenHarmonyPlatformWindow *window)
+    : m_window(window)
+{
+
+}
+
+// harmony os state
+#define WINDOW_SHOWN 1
+#define WINDOW_ACTIVE 2
+#define WINDOW_INACTIVE 3
+#define WINDOW_HIDDEN 4
+#define WINDOW_DESTROYED 7
+
+void QOpenHarmonyPlatformWindow::handleWindowEvent(int event)
+{
+    if (event == WINDOW_DESTROYED) {
+        QWindowSystemInterface::handleCloseEvent(window());
+        QWindowSystemInterface::flushWindowSystemEvents();
+    } else if (event == WINDOW_HIDDEN){
+        lower();
+    } else if (event == WINDOW_SHOWN) {
+        raise();
+    } else if (event == WINDOW_ACTIVE) {
+        raise();
+    } else if (event == WINDOW_INACTIVE) {
+        lower();
+    }
+}
+
+// openharmony
+#define STATUS_UNDEFINED        0
+#define STATUS_FULL_SCREEN      1
+#define STATUS_MAXIMIZE         2
+#define STATUS_MINIMIZE         3
+#define STATUS_FLOATING         4
+#define STATUS_SPLIT_SCREEN     5
+
+void QOpenHarmonyPlatformWindow::handleWindowStatusEvent(int event)
+{
+    switch (event) {
+    case STATUS_UNDEFINED:
+        return;
+    case STATUS_MINIMIZE:
+        handleWindowStateChange(Qt::WindowMinimized);
+        return;
+    case STATUS_MAXIMIZE:
+        handleWindowStateChange(Qt::WindowMaximized);
+        break;
+    case STATUS_FLOATING:
+        handleWindowStateChange(Qt::WindowNoState);
+        break;
+    case STATUS_FULL_SCREEN:
+        handleWindowStateChange(Qt::WindowMaximized);
+//        handleWindowStateChange(Qt::WindowFullScreen);
+        break;
+    }
+}
+
+QOpenHarmonyPlatformWindow *QOpenHarmonyPlatformWindow::get(QWindow *window)
+{
+    auto it = std::find_if(allWindows.constBegin(), allWindows.constEnd(), [window](QOpenHarmonyPlatformWindow *pw){
+        return pw->window() == window;
+    });
+    return it == allWindows.constEnd() ? nullptr : *it;
+}
+
+bool QOpenHarmonyPlatformWindow::detectionWindowHasFrame()
+{
+    bool topLevel = isTopLevelWindow();
+    Qt::WindowFlags flags = window()->flags();
+    Qt::WindowType type = static_cast<Qt::WindowType>(int(flags) & Qt::WindowType_Mask);
+    bool dialog = false;
+    bool tool = false;
+    bool popup = false;
+    switch (type) {
+    case Qt::Dialog:
+    case Qt::Sheet:
+        dialog = true;
+        break;
+    case Qt::Drawer:
+    case Qt::Tool:
+        tool = true;
+        break;
+    case Qt::Popup:
+        popup = true;
+        break;
+    default:
+        break;
+    }
+
+    qDebug() << this << window()->objectName() << "window is dialog: " << dialog << "is tool: " << tool << "is popup: " << popup
+             << "type: " << type << "windowFlags: " << flags;
+
+    if ((flags & Qt::MSWindowsFixedSizeDialogHint))
+        dialog = true;
+    if (popup || (type == Qt::ToolTip) || (type == Qt::SplashScreen)) {
+        return false;
+    } else if (topLevel) {
+        if (flags & Qt::FramelessWindowHint)
+            return false;                // no border
+        else
+            return true;
+    } else {
+        return false;
+    }
+    return false;
+}
+
+void QOpenHarmonyPlatformWindow::handleWindowStateChange(Qt::WindowStates state)
+{
+    QWindowSystemInterface::handleWindowStateChanged(window(), state);
+    if (state & Qt::WindowMinimized) {
+        QWindowSystemInterface::flushWindowSystemEvents(QEventLoop::ExcludeUserInputEvents);
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.h b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.h
new file mode 100644
index 0000000000..670241e35a
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyplatformwindow.h
@@ -0,0 +1,105 @@
+#ifndef QOPENHARMONYPLATFORMWINDOW_H
+#define QOPENHARMONYPLATFORMWINDOW_H
+#include <qobject.h>
+#include <qrect.h>
+#include <qscopedpointer.h>
+#include <qpa/qplatformwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOpenHarmonyPlatformScreen;
+class QOpenHarmonyPlatformBackingStore;
+class QOpenHarmonyPlatformWindow;
+class QOpenHarmonyPlatformWindowHelper;
+
+class QOpenHarmonyPlatformWindow : public QPlatformWindow
+{
+
+public:
+    explicit QOpenHarmonyPlatformWindow(QWindow *window);
+    ~QOpenHarmonyPlatformWindow();
+
+    void initialize() override;
+
+    void lower() override;
+    void raise() override;
+
+    void setOpacity(qreal level) override;
+
+    void setVisible(bool visible);
+    void setParent(const QPlatformWindow *window) override;
+    WId winId() const override { return m_windowId; }
+    void setWId(WId nativeHandle);
+    QOpenHarmonyPlatformScreen *platformScreen() const;
+
+    void setWindowTitle(const QString &title);
+    QString windowTitle() const;
+
+    void setWindowName(const QString &name);
+    QString windowName() const;
+
+    void requestActivateWindow() override;
+
+    inline bool isRaster() const {
+        if (isForeignWindow())
+            return false;
+
+        return window()->surfaceType() == QSurface::RasterSurface
+            || window()->surfaceType() == QSurface::RasterGLSurface;
+    }
+    bool isExposed() const override;
+
+    virtual void applicationStateChanged(Qt::ApplicationState);
+
+    void setBackingStore(QOpenHarmonyPlatformBackingStore *store) { m_backingStore = store; }
+    QOpenHarmonyPlatformBackingStore *backingStore() const { return m_backingStore; }
+
+    virtual void repaint() { }
+    virtual void handleGeometryChange() {}
+
+    void setGeometry(const QRect &rect) override;
+
+    bool isTopLevelWindow() const;
+
+    bool hasFrame() const;
+
+    bool hasFocus() const;
+
+    virtual QMargins frameMargins() const;
+
+    QString parentWindowName() const;
+
+    QOpenHarmonyPlatformWindowHelper *helper() const;
+
+    void handleWindowEvent(int event);
+    void handleWindowStatusEvent(int event);
+
+    static QOpenHarmonyPlatformWindow *get(QWindow *window);
+protected:
+    bool detectionWindowHasFrame();
+    void handleWindowStateChange(Qt::WindowStates state);
+
+    WId m_windowId;
+    QString m_title;
+    QString m_name;    
+    QOpenHarmonyPlatformBackingStore *m_backingStore = nullptr;
+    QScopedPointer<QOpenHarmonyPlatformWindowHelper> m_helper;
+    bool m_hasFrame;
+};
+
+class QOpenHarmonyPlatformWindowHelper : public QObject
+{
+    Q_OBJECT
+public:
+    QOpenHarmonyPlatformWindowHelper(QOpenHarmonyPlatformWindow *window);
+public slots:
+    void handleGeometryChange() { m_window->handleGeometryChange(); }
+    void handleWindowEvent(int event) { m_window->handleWindowEvent(event); }
+    void handleWindowStatusEvent(int event) { m_window->handleWindowStatusEvent(event); }
+    void handleRepaintEvent() { m_window->repaint(); }
+private:
+    QOpenHarmonyPlatformWindow *m_window;
+};
+
+QT_END_NAMESPACE
+#endif // QOPENHARMONYPLATFORMWINDOW_H
diff --git a/src/plugins/platforms/openharmony/qopenharmonyxcomponent.cpp b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.cpp
new file mode 100644
index 0000000000..698f9892ce
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.cpp
@@ -0,0 +1,515 @@
+#include <QKeyEvent>
+#include <QMargins>
+#include <QDebug>
+#include <native_window/external_window.h>
+#include <sys/mman.h>
+#include <QCoreApplication>
+#include <QTimer>
+
+#include "qopenharmonyxcomponent.h"
+#include "qopenharmonyplatforminputcontext.h"
+#include "qopenharmonyeglcore.h"
+#include "qopenharmonyjswindowmanager.h"
+#include "qopenharmonyjswindow.h"
+#include "qopenharmonyplatformwindow.h"
+#include "qopenharmonylog.h"
+#include "qopenharmonymain.h"
+
+static OH_NativeXComponent_Callback *g_componentCallback = nullptr;
+static OH_NativeXComponent_MouseEvent_Callback *g_mouseEventCallback = nullptr;
+static int g_ref = 0;
+
+class RepaintHelper : public QObject
+{
+    Q_OBJECT
+public:
+    RepaintHelper(QOpenHarmonyXComponent * component): m_component(component) {}
+    virtual ~RepaintHelper() {}
+
+    void update() {
+        QTimer::singleShot(10, this, [this]{
+            QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest));
+        });
+    }
+
+    bool event(QEvent *event);
+private:
+    QOpenHarmonyXComponent *m_component;
+};
+#include "qopenharmonyxcomponent.moc"
+
+bool RepaintHelper::event(QEvent *event)
+{
+    if (event->type() == QEvent::UpdateRequest) {
+        m_component->repaint();
+        return true;
+    }
+    return QObject::event(event);
+}
+
+static inline Qt::KeyboardModifiers keyStateToModifiers(OH_NativeXComponent_KeyCode code)
+{
+    Qt::KeyboardModifiers mods(Qt::NoModifier);
+    if ((code == KEY_CTRL_LEFT) || (code == KEY_CTRL_RIGHT))
+        mods |= Qt::ControlModifier;
+    else if ((code == KEY_SHIFT_LEFT) || (code == KEY_SHIFT_RIGHT))
+        mods |= Qt::ShiftModifier;
+    else if ((code == KEY_ALT_LEFT) || (code == KEY_ALT_RIGHT))
+        mods |= Qt::AltModifier;
+    return mods;
+}
+
+QOpenHarmonyXComponent::QOpenHarmonyXComponent(OH_NativeXComponent *component)
+    : m_nativeComponent(component)
+    , m_window(nullptr)
+{
+    m_egl.reset(new QOpenHarmonyEGLCore);
+    initXComponent(component);
+}
+
+QOpenHarmonyXComponent::~QOpenHarmonyXComponent()
+{
+    if (m_helper != nullptr)
+        delete m_helper;
+    m_window = nullptr;
+}
+
+void QOpenHarmonyXComponent::setWindow(QOpenHarmonyJsWindow *jsWindow)
+{
+    m_window = jsWindow;
+}
+
+void QOpenHarmonyXComponent::paint(const QImage &image, const QRegion &region, const QPoint &offset)
+{
+    m_image = image;
+    m_region = region;
+    m_offset = offset;
+    repaint();
+}
+
+QString QOpenHarmonyXComponent::name() const
+{
+    return m_name;
+}
+
+void QOpenHarmonyXComponent::onSurfaceCreated(OH_NativeXComponent *component, void *window)
+{
+    QOpenHarmonyJsWindow *jsWindow = qJsWindowManager->window(component);
+    if (jsWindow == nullptr)
+        return;
+    OHNativeWindow *nativeWindow = static_cast<OHNativeWindow *>(window);
+    jsWindow->setNativeWindow(nativeWindow);
+}
+
+void QOpenHarmonyXComponent::onSurfaceChanged(OH_NativeXComponent *component, void *window)
+{
+    Q_UNUSED(window)
+    QOpenHarmonyJsWindow *w = qJsWindowManager->window(component);
+    if (w == nullptr)
+        return;
+    w->handleSurfaceChanged();
+}
+
+void QOpenHarmonyXComponent::onSurfaceDestroyed(OH_NativeXComponent *component, void *window)
+{    
+    if (--g_ref == 0) {
+        if (g_mouseEventCallback == nullptr) {
+            delete g_mouseEventCallback;
+            g_mouseEventCallback = nullptr;
+        }
+        if (g_componentCallback) {
+            delete g_componentCallback;
+            g_componentCallback = nullptr;
+        }
+    }
+}
+
+void QOpenHarmonyXComponent::dispatchKeyEvent(OH_NativeXComponent *component, void *window)
+{
+    Q_UNUSED(window);
+    QOpenHarmonyPlatformInputContext *context = QOpenHarmonyPlatformInputContext::openHarmonyInputContext();
+    if (Q_NULLPTR == component || Q_NULLPTR == context)
+        return;
+
+    OH_NativeXComponent_KeyEvent *keyEvent = Q_NULLPTR;
+    /* 获取由XComponent触发的按键事件 */
+    if (OH_NativeXComponent_GetKeyEvent(component, &keyEvent) >= 0) {
+        OH_NativeXComponent_KeyAction action;
+        OH_NativeXComponent_GetKeyEventAction(keyEvent, &action); /* 获取按键事件的动作 */
+
+        OH_NativeXComponent_KeyCode code;
+        OH_NativeXComponent_GetKeyEventCode(keyEvent, &code); /*  获取按键事件的键码值 */
+
+        OH_NativeXComponent_EventSourceType sourceType;
+        OH_NativeXComponent_GetKeyEventSourceType(keyEvent, &sourceType); /* 获取按键事件的输入源类型 */
+
+        int64_t deviceId;
+        OH_NativeXComponent_GetKeyEventDeviceId(keyEvent, &deviceId); /* 获取按键事件的设备ID */
+
+        int64_t timeStamp;
+        OH_NativeXComponent_GetKeyEventTimestamp(keyEvent, &timeStamp); /* 获取按键事件的时间戳 */
+
+        OpenHarmonyKeyEvent event;
+        event.component = component;
+        event.code = code;
+        event.action = action;
+        event.stype = sourceType;
+        event.deviceId = deviceId;
+        event.timeStamp = timeStamp;
+        QMetaObject::invokeMethod(context, "handleKeyEvent",
+                                  Qt::QueuedConnection, Q_ARG(OpenHarmonyKeyEvent, event));
+
+    } else {
+        LOGW("Get Key Event Error");
+    }
+}
+
+static int getAction(int id, int index, OH_NativeXComponent_TouchEventType type, int x, int y, int pointsize, OH_NativeXComponent_HistoricalPoint* historicalPoints)
+{
+    OH_NativeXComponent_TouchEventType action = type;
+    if (action == OH_NATIVEXCOMPONENT_MOVE) {
+        if (pointsize > 0) {
+            for (int h = 0; h < pointsize; ++h) {
+                if (id != historicalPoints[h].id)
+                    continue;
+                if (historicalPoints[h].x != x ||
+                    historicalPoints[h].y != y)
+                    return 1;
+            }
+            return 2;
+        }
+        return 1;
+    }
+    if (action == OH_NATIVEXCOMPONENT_DOWN) {
+        return 0;
+    } else if (action == OH_NATIVEXCOMPONENT_UP) {
+        return 3;
+    }
+    return 2;
+}
+
+void QOpenHarmonyXComponent::dispatchTouchEvent(OH_NativeXComponent *component, void *window)
+{    
+    if (nullptr == component || nullptr == window)
+        return;
+
+    // 触摸板会触发touch事件和mouse事件，导致2次鼠标事件
+    if (QtOpenHarmony::isTouchPad())
+        return;
+
+    OH_NativeXComponent_TouchEvent touchEvent;
+    int32_t ret = OH_NativeXComponent_GetTouchEvent(component, window, &touchEvent);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+
+    QOpenHarmonyPlatformInputContext *context = QOpenHarmonyPlatformInputContext::openHarmonyInputContext();
+    if (nullptr == context)
+        return;
+
+    context->touchBegin();
+
+    int32_t size;
+    OH_NativeXComponent_HistoricalPoint* historicalPoints = nullptr;
+    ret = OH_NativeXComponent_GetHistoricalPoints(component, window, &size, &historicalPoints);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+
+    for (int i = 0; i < touchEvent.numPoints; i++) {
+        OH_NativeXComponent_TouchPoint &point = touchEvent.touchPoints[i];
+        int action = getAction(point.id, i, touchEvent.type, point.x, point.y, size, historicalPoints);
+        context->touchAdd(point.id, action, point.force, point.screenX, point.screenY);
+    }
+    OpenHarmonyTouchEvent event;
+    event.component = component;
+    event.id = 0;
+    QMetaObject::invokeMethod(QOpenHarmonyPlatformInputContext::openHarmonyInputContext(),
+                              "touchEnd", Qt::QueuedConnection, Q_ARG(OpenHarmonyTouchEvent, event));
+}
+
+void QOpenHarmonyXComponent::dispatchMouseEvent(OH_NativeXComponent *component, void *window)
+{
+    if (QOpenHarmonyPlatformInputContext::openHarmonyInputContext() == nullptr)
+        return;
+
+    OH_NativeXComponent_MouseEvent mouseEvent;
+    int32_t ret = OH_NativeXComponent_GetMouseEvent(component, window, &mouseEvent);
+    if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+        return;
+
+    OH_NativeXComponent_MouseEventAction action = mouseEvent.action;
+    OH_NativeXComponent_MouseEventButton button = mouseEvent.button;
+    Qt::MouseButton qbtn = Qt::NoButton;
+    switch (button) {
+    case OH_NATIVEXCOMPONENT_LEFT_BUTTON:
+        qbtn = Qt::LeftButton;
+        break;
+    case OH_NATIVEXCOMPONENT_RIGHT_BUTTON:
+        qbtn = Qt::RightButton;
+        break;
+    case OH_NATIVEXCOMPONENT_MIDDLE_BUTTON:
+        qbtn = Qt::MiddleButton;
+        break;
+    case OH_NATIVEXCOMPONENT_BACK_BUTTON:
+        qbtn = Qt::BackButton;
+        break;
+    case OH_NATIVEXCOMPONENT_FORWARD_BUTTON:
+        qbtn = Qt::ForwardButton;
+        break;
+    default:
+        break;
+    }
+
+//    LOGI("%{public}s mouse event %{public}d, button is %{public}d screen point (%{public}f, %{public}f)", w->name().toLatin1().constData(), action, qbtn, mouseEvent.screenX, mouseEvent.screenY);
+    OpenHarmonyMouseEvent event;
+    event.x = mouseEvent.screenX;
+    event.y = mouseEvent.screenY;
+    event.component = component;
+    event.btn = qbtn;
+
+    switch (action) {
+    case OH_NATIVEXCOMPONENT_MOUSE_RELEASE:
+        event.type = QEvent::MouseButtonRelease;
+        break;
+    case OH_NATIVEXCOMPONENT_MOUSE_PRESS:
+        event.type = QEvent::MouseButtonPress;
+        break;
+    case OH_NATIVEXCOMPONENT_MOUSE_MOVE:
+        event.type = QEvent::MouseMove;
+        break;
+    default:
+        event.type = QEvent::None;
+        break;
+    }
+    /* FIXME 移动端设备中和touch事件重复
+     * 导致进入两次鼠标相关事件 */
+    if (!QtOpenHarmony::isPhone() || QtOpenHarmony::isTouchPad())
+        return;
+
+    QMetaObject::invokeMethod(QOpenHarmonyPlatformInputContext::openHarmonyInputContext(),
+                              "handleMouseEvent", Qt::QueuedConnection, Q_ARG(OpenHarmonyMouseEvent, event));
+}
+
+void QOpenHarmonyXComponent::dispatchHoverEvent(OH_NativeXComponent *component, bool isHover)
+{
+
+}
+
+#if QT_CONFIG(wheelevent)
+void QOpenHarmonyXComponent::dispatchArkUIInputEvent(OH_NativeXComponent *component, ArkUI_UIInputEvent *event,
+                                                     ArkUI_UIInputEvent_Type type)
+{
+    if (nullptr == event ||
+        QOpenHarmonyPlatformInputContext::openHarmonyInputContext() == nullptr)
+        return;
+
+    float gx = OH_ArkUI_PointerEvent_GetDisplayX(event);
+    float gy = OH_ArkUI_PointerEvent_GetDisplayY(event);
+
+    QPoint global(gx, gy);
+
+    /* 获取UI输入事件发生的时间 */
+    int64_t timestamp = OH_ArkUI_UIInputEvent_GetEventTime(event);
+    double vaxis = OH_ArkUI_AxisEvent_GetVerticalAxisValue(event);
+    double haxis = OH_ArkUI_AxisEvent_GetHorizontalAxisValue(event);
+
+    // float tiltX = OH_ArkUI_PointerEvent_GetTiltX(event, 0);
+    // LOGE(<-----------arkUI event tiltX--:%{public}d", tiltX);
+
+    // float tiltY = OH_ArkUI_PointerEvent_GetTiltY(event, 0);
+    // LOGE(<-----------arkUI event tiltY--:%{public}d", tiltY);
+    /* FIXME 获取是否有修饰键,按键判断可能无效,是否应该由系统提供按键查询接口? */
+    Qt::KeyboardModifiers mods(Qt::NoModifier);
+    OH_NativeXComponent_KeyEvent *keyEvent = Q_NULLPTR;
+    if (OH_NativeXComponent_GetKeyEvent(component, &keyEvent) >= 0) {
+        OH_NativeXComponent_KeyCode code;
+        OH_NativeXComponent_GetKeyEventCode(keyEvent, &code); /* 获取按键事件的键码值 */
+        mods = keyStateToModifiers(code);
+    }
+    QPoint pixelDelta(-haxis, -vaxis); /* NOTE 这里取相反的值,保持和Qt滑轮滚动方向一致 */
+    OpenHarmonyWheelEvent ohevent;
+    ohevent.component = component;
+    ohevent.global = global;
+    ohevent.pixelDelta = pixelDelta;
+    ohevent.mods = mods;
+    QMetaObject::invokeMethod(QOpenHarmonyPlatformInputContext::openHarmonyInputContext(),
+                              "wheelEvent", Qt::QueuedConnection, Q_ARG(OpenHarmonyWheelEvent, ohevent));
+}
+#endif
+
+void QOpenHarmonyXComponent::initXComponent(OH_NativeXComponent *component)
+{
+    if (m_nativeComponent != nullptr) {
+        /* 注册界面渲染事件回调 */
+        if (g_componentCallback == nullptr) {
+            g_componentCallback = new OH_NativeXComponent_Callback;
+            g_componentCallback->OnSurfaceCreated = &QOpenHarmonyXComponent::onSurfaceCreated;
+            g_componentCallback->OnSurfaceChanged = &QOpenHarmonyXComponent::onSurfaceChanged;
+            g_componentCallback->OnSurfaceDestroyed = &QOpenHarmonyXComponent::onSurfaceDestroyed;
+            g_componentCallback->DispatchTouchEvent = &QOpenHarmonyXComponent::dispatchTouchEvent;
+        }
+        int32_t ret = OH_NativeXComponent_RegisterCallback(component, g_componentCallback);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            LOGI("set surface touch callback failed");
+        }
+#if QT_CONFIG(wheelevent)
+        /* 注册UI输入事件回调,轴事件 */
+        ret = OH_NativeXComponent_RegisterUIInputEventCallback(component, &QOpenHarmonyXComponent::dispatchArkUIInputEvent,
+                                                               ARKUI_UIINPUTEVENT_TYPE_AXIS);
+
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            LOGI("set axis event callback failed");
+        }
+#endif
+        /* 注册界鼠标事件回调 */
+        if (g_mouseEventCallback == nullptr) {
+            g_mouseEventCallback = new OH_NativeXComponent_MouseEvent_Callback;
+            g_mouseEventCallback->DispatchMouseEvent = &QOpenHarmonyXComponent::dispatchMouseEvent;
+            g_mouseEventCallback->DispatchHoverEvent = &QOpenHarmonyXComponent::dispatchHoverEvent;
+        }
+        ret = OH_NativeXComponent_RegisterMouseEventCallback(component, g_mouseEventCallback);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            LOGI("set surface mouse callback failed");
+        }
+
+        /* 注册键盘事件回调 */
+        ret = OH_NativeXComponent_RegisterKeyEventCallback(component, &QOpenHarmonyXComponent::dispatchKeyEvent);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS)
+            LOGI("set surface keybord callback failed");
+
+        char id[OH_XCOMPONENT_ID_LEN_MAX + 1] = { };
+        uint64_t id_length = OH_XCOMPONENT_ID_LEN_MAX + 1;
+
+        ret = OH_NativeXComponent_GetXComponentId(component, id, &id_length);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            return;
+        }
+        LOGI("get xcomponent succeded %{public}s", id);
+        m_name = QString::fromUtf8(id);
+        g_ref++;
+    }
+}
+
+void QOpenHarmonyXComponent::repaint()
+{
+    QSize ss = surfaceSize();
+    QSize qtSize = m_image.size();
+    QSize diff = ss - qtSize;
+    bool needToRepaint = (qAbs(diff.width()) > 2) || (qAbs(diff.height()) > 2);
+    if (needToRepaint) {
+        qWarning() << "the qt window size is not equal xcomponent size: "  << qtSize << ss;
+        if (m_helper == nullptr)
+            m_helper = new RepaintHelper(this);
+        m_helper->update();
+        return;
+    }
+
+    if (m_window == nullptr)
+        return;
+    OHNativeWindow *window = m_window->nativeWindow();
+    int fenceFd = 0;
+    NativeWindowBuffer *buffer = nullptr;
+    int ret = OH_NativeWindow_NativeWindowRequestBuffer(window, &buffer, &fenceFd);
+    if (ret != 0) {
+        qWarning() << "request buffer for native window failed";
+        return;
+    }
+    BufferHandle *bufferHandle = OH_NativeWindow_GetBufferHandleFromNative(buffer);
+    if (bufferHandle == nullptr) {
+        qWarning() << "request buffer handle from native window failed";
+        return;
+    }
+
+    uchar *mappedAddress =
+            static_cast<uchar*>(mmap(bufferHandle->virAddr, bufferHandle->size, PROT_READ | PROT_WRITE, MAP_SHARED, bufferHandle->fd, 0));
+    if (mappedAddress == MAP_FAILED) {
+        qWarning() << "mmap failed";
+        return;
+    }
+
+#if 0
+    int count = m_region.rectCount();
+    Region *dirtyRegion = new Region;
+    dirtyRegion->rects = new Region::Rect[count];
+    dirtyRegion->rectNumber = count;
+    int index = 0;
+    for (auto it = m_region.begin(); it != m_region.end(); ++it) {
+        QRect dirtyRect = *it;
+        dirtyRegion->rects[index].x = dirtyRect.x();
+        dirtyRegion->rects[index].y = dirtyRect.y();
+        dirtyRegion->rects[index].w = dirtyRect.width();
+        dirtyRegion->rects[index].h = dirtyRect.height();
+        int width = qMin(bufferHandle->width, dirtyRect.right());
+        int height = qMin(bufferHandle->height, dirtyRect.bottom());
+        index++;
+        int bytesPL = (width - dirtyRect.left()) * 4/*m_image.bytesPerLine()*/;
+        for (int h = dirtyRect.top(); h < height; ++h) {
+            uchar *pixel = mappedAddress + bufferHandle->stride * h + dirtyRect.left() * 4;
+            uchar *value = m_image.scanLine(h) + dirtyRect.left() * 4;
+            memcpy(pixel, value, bytesPL);
+        }
+    }
+    OH_NativeWindow_NativeWindowFlushBuffer(window, buffer, fenceFd, *dirtyRegion);
+
+#else
+    int width = qMin(bufferHandle->width, m_image.width());
+    int height = qMin(bufferHandle->height, m_image.height());
+    int bytesPL = width * 4/*m_image.bytesPerLine()*/;
+    for (int h = 0; h < height; ++h) {
+        uchar *pixel = mappedAddress + bufferHandle->stride * h;
+        uchar *value = m_image.scanLine(h);
+        memcpy(pixel, value, bytesPL);
+    }
+
+    Region reg{nullptr, 0};
+    OH_NativeWindow_NativeWindowFlushBuffer(window, buffer, fenceFd, reg);
+#endif
+    int result = munmap(mappedAddress, bufferHandle->size);
+    if (result == -1) {
+        qWarning() << "munmap failed!";
+    }
+#if 0
+    delete[] dirtyRegion->rects;
+    delete dirtyRegion;
+#endif
+}
+
+OH_NativeXComponent *QOpenHarmonyXComponent::nativeComponent() const
+{
+    return m_nativeComponent;
+}
+
+QSize QOpenHarmonyXComponent::surfaceSize() const
+{
+    if (m_window == nullptr || m_window->nativeWindow() == 0 || m_nativeComponent == nullptr)
+        return QSize();
+
+    uint64_t w;
+    uint64_t h;
+    if (void *nativeW = reinterpret_cast<void*>(m_window->nativeWindow())) {
+        int32_t ret = OH_NativeXComponent_GetXComponentSize(m_nativeComponent, nativeW, &w, &h);
+        if (ret != OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {
+            LOGE("Get surface size failed");
+            return QSize();
+        }
+        return QSize(w, h);
+    }
+    return QSize();
+}
+
+QSize QOpenHarmonyXComponent::qtWindowSize() const
+{
+    if (m_window == nullptr)
+        return QSize();
+    return m_window->qtGeometry().size();
+}
+
+EGLSurface QOpenHarmonyXComponent::eglSurface(EGLNativeWindowType window)
+{
+    return m_egl->eglSurface(window);
+}
+
+void QOpenHarmonyXComponent::setNativeXComponent(OH_NativeXComponent *component)
+{
+    m_nativeComponent = component;
+    initXComponent(component);
+}
diff --git a/src/plugins/platforms/openharmony/qopenharmonyxcomponent.h b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.h
new file mode 100644
index 0000000000..8c5e196f12
--- /dev/null
+++ b/src/plugins/platforms/openharmony/qopenharmonyxcomponent.h
@@ -0,0 +1,77 @@
+#ifndef QOPENHARMONYXCOMPONENT_H
+#define QOPENHARMONYXCOMPONENT_H
+
+#include <QRect>
+#include <QImage>
+#include <QObject>
+#include <EGL/egl.h>
+#include <QScopedPointer>
+
+#if QT_CONFIG(wheelevent)
+#include <arkui/ui_input_event.h>
+#endif
+
+class QOpenHarmonyEGLCore;
+struct OH_NativeXComponent;
+class QOpenHarmonyJsWindow;
+struct OH_NativeXComponent_Callback;
+struct OH_NativeXComponent_MouseEvent_Callback;
+class RepaintHelper;
+
+class QOpenHarmonyXComponent
+{
+public:
+    QOpenHarmonyXComponent(OH_NativeXComponent *component = nullptr);
+    virtual ~QOpenHarmonyXComponent();
+
+    void setWindow(QOpenHarmonyJsWindow *jsWindow);
+
+    void paint(const QImage &image, const QRegion &region, const QPoint &offset);
+
+    QString name() const;
+
+    EGLSurface eglSurface(EGLNativeWindowType window);
+
+    void setNativeXComponent(OH_NativeXComponent *component);
+    OH_NativeXComponent *nativeComponent() const;
+
+    QSize surfaceSize() const;
+    QSize qtWindowSize() const;
+private:
+
+    static void onSurfaceCreated(OH_NativeXComponent* component, void* window);
+
+    static void onSurfaceChanged(OH_NativeXComponent* component, void* window);
+
+    static void onSurfaceDestroyed(OH_NativeXComponent* component, void* window);
+
+    static void dispatchKeyEvent(OH_NativeXComponent *component, void *window);
+
+    static void dispatchTouchEvent(OH_NativeXComponent* component, void* window);
+
+    static void dispatchMouseEvent(OH_NativeXComponent* component, void* window);
+
+    static void dispatchHoverEvent(OH_NativeXComponent* component, bool isHover);
+
+#if QT_CONFIG(wheelevent)
+    static void dispatchArkUIInputEvent(OH_NativeXComponent* component, ArkUI_UIInputEvent* event,
+                                        ArkUI_UIInputEvent_Type type);
+#endif
+
+private:
+    void initXComponent(OH_NativeXComponent *component);
+    void repaint();
+private:
+    friend class QOpenHarmonyEGLCore;
+    OH_NativeXComponent *m_nativeComponent = nullptr;
+    QScopedPointer<QOpenHarmonyEGLCore> m_egl;
+    QOpenHarmonyJsWindow *m_window = nullptr;
+    QString m_name;
+    QImage m_image;
+    QRegion m_region;
+    QPoint m_offset;
+    friend class RepaintHelper;
+    RepaintHelper *m_helper = nullptr;
+    bool m_canDraw = false;
+};
+#endif // QOPENHARMONYXCOMPONENT_H
diff --git a/src/plugins/platforms/platforms.pro b/src/plugins/platforms/platforms.pro
index 23f838a7fe..f13ef8b9cd 100644
--- a/src/plugins/platforms/platforms.pro
+++ b/src/plugins/platforms/platforms.pro
@@ -7,6 +7,12 @@ android:!android-embedded: SUBDIRS += android
 
 !wasm:!android:qtConfig(freetype): SUBDIRS += offscreen
 
+openharmony: SUBDIRS += openharmony
+
+!android:!openharmony: SUBDIRS += minimal
+
+!android:!openharmony:qtConfig(freetype): SUBDIRS += offscreen
+
 qtConfig(xcb) {
     SUBDIRS += xcb
 }
diff --git a/src/plugins/styles/harmonyos/harmonyos.pro b/src/plugins/styles/harmonyos/harmonyos.pro
new file mode 100644
index 0000000000..b7abe8a40b
--- /dev/null
+++ b/src/plugins/styles/harmonyos/harmonyos.pro
@@ -0,0 +1,18 @@
+TARGET = qharmonyosstyle
+
+QT += widgets-private
+
+SOURCES += \
+    main.cpp \
+    qharmonyosstyle.cpp
+
+HEADERS += \
+    qharmonyosstyle_p.h
+
+
+DISTFILES += \
+    harmonyosstyle.json
+
+PLUGIN_TYPE = styles
+PLUGIN_CLASS_NAME = QHarmonyOSStylePlugin
+load(qt_plugin)
diff --git a/src/plugins/styles/harmonyos/harmonyosstyle.json b/src/plugins/styles/harmonyos/harmonyosstyle.json
new file mode 100644
index 0000000000..18d97293f2
--- /dev/null
+++ b/src/plugins/styles/harmonyos/harmonyosstyle.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "harmonyos" ]
+}
diff --git a/src/plugins/styles/harmonyos/main.cpp b/src/plugins/styles/harmonyos/main.cpp
new file mode 100644
index 0000000000..65d71c3299
--- /dev/null
+++ b/src/plugins/styles/harmonyos/main.cpp
@@ -0,0 +1,26 @@
+#include <QtWidgets/qstyleplugin.h>
+
+#include "qharmonyosstyle_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QHarmonyOSStylePlugin : public QStylePlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QStyleFactoryInterface" FILE "harmonyosstyle.json")
+public:
+    QStyle *create(const QString &key);
+};
+
+QStyle *QHarmonyOSStylePlugin::create(const QString &key)
+{    
+    if (key.compare(QLatin1String("harmonyos"), Qt::CaseInsensitive) == 0)
+        return new QHarmonyOSStyle();
+
+    return Q_NULLPTR;
+}
+
+QT_END_NAMESPACE
+
+#include "main.moc"
+
diff --git a/src/plugins/styles/harmonyos/qharmonyosstyle.cpp b/src/plugins/styles/harmonyos/qharmonyosstyle.cpp
new file mode 100644
index 0000000000..172d0fd314
--- /dev/null
+++ b/src/plugins/styles/harmonyos/qharmonyosstyle.cpp
@@ -0,0 +1,54 @@
+#include <QDebug>
+#include <qpainter.h>
+#include <qstyleoption.h>
+#include <QtWidgets/qdrawutil.h>
+
+#include "qharmonyosstyle_p.h"
+
+QT_BEGIN_NAMESPACE
+
+QHarmonyOSStyle::QHarmonyOSStyle() : QCommonStyle()
+{
+}
+
+QHarmonyOSStyle::~QHarmonyOSStyle()
+{
+
+}
+
+void QHarmonyOSStyle::drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p, const QWidget *w) const
+{
+    switch (pe) {
+    case PE_FrameFocusRect:
+        break;
+    case PE_FrameButtonBevel:
+        break;
+    case PE_PanelButtonCommand: {
+        p->setRenderHint(QPainter::Antialiasing);
+        QBrush oldBrush = p->brush();
+        if (opt->state.testFlag(QStyle::State_MouseOver))
+            p->setBrush(QColor("#007DFF"));
+
+        p->drawRoundedRect(opt->rect.adjusted(1, 1, -1, -1), 14, 14);
+        p->setBrush(oldBrush);
+    }
+    break;
+    case PE_FrameDefaultButton:
+        break;
+    default:
+        QCommonStyle::drawPrimitive(pe, opt, p, w);
+        break;
+    }
+}
+
+void QHarmonyOSStyle::drawControl(ControlElement element, const QStyleOption *opt, QPainter *p, const QWidget *w) const
+{
+    QCommonStyle::drawControl(element, opt, p, w);
+}
+
+int QHarmonyOSStyle::pixelMetric(PixelMetric m, const QStyleOption *opt, const QWidget *widget) const
+{
+    return QCommonStyle::pixelMetric(m, opt, widget);
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/styles/harmonyos/qharmonyosstyle_p.h b/src/plugins/styles/harmonyos/qharmonyosstyle_p.h
new file mode 100644
index 0000000000..e81d9490cd
--- /dev/null
+++ b/src/plugins/styles/harmonyos/qharmonyosstyle_p.h
@@ -0,0 +1,38 @@
+#ifndef QHARMONYOSSTYLE_P_H
+#define QHARMONYOSSTYLE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of qstylefactory.cpp.  This header may change from version to version
+// without notice, or even be removed.
+//
+// We mean it.
+//
+#include <QtWidgets/qcommonstyle.h>
+
+QT_BEGIN_NAMESPACE
+
+class Q_WIDGETS_EXPORT QHarmonyOSStyle : public QCommonStyle
+{
+    Q_OBJECT
+
+public:
+    QHarmonyOSStyle();
+    virtual ~QHarmonyOSStyle();
+
+    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt,
+                       QPainter *p, const QWidget *w) const override;
+
+    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
+                     const QWidget *w = nullptr) const override;
+
+    int pixelMetric(PixelMetric m, const QStyleOption *opt = nullptr,
+                    const QWidget *widget = nullptr) const override;
+};
+
+QT_END_NAMESPACE
+
+#endif // QHARMONYOSSTYLE_P_H
diff --git a/src/plugins/styles/styles.pro b/src/plugins/styles/styles.pro
index 542ad1329a..fb8d978d83 100644
--- a/src/plugins/styles/styles.pro
+++ b/src/plugins/styles/styles.pro
@@ -6,3 +6,5 @@ qtConfig(style-android): SUBDIRS += android
 qtConfig(style-mac): SUBDIRS += mac
 
 qtConfig(style-windowsvista): SUBDIRS += windowsvista
+
+# qtConfig(style-harmonyos): SUBDIRS += harmonyos
diff --git a/src/src.pro b/src/src.pro
index 8990109743..ffa3ca0dcc 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -152,6 +152,8 @@ src_plugins.target = sub-plugins
 
 src_android.subdir = $$PWD/android
 
+src_openharmony.subdir = $$PWD/openharmony
+
 # this order is important
 !qtConfig(system-zlib)|cross_compile {
     SUBDIRS += src_qtzlib
@@ -250,6 +252,8 @@ nacl: SUBDIRS -= src_network src_testlib
 
 android:!android-embedded: SUBDIRS += src_android src_3rdparty_gradle
 
+openharmony: SUBDIRS += src_openharmony
+
 qtConfig(private_tests) {
      qtConfig(network):qtConfig(gui) {
         src_network_doc_snippets.subdir = network/doc/snippets
diff --git a/src/testlib/qplaintestlogger.cpp b/src/testlib/qplaintestlogger.cpp
index 851a284678..2154f97ba7 100644
--- a/src/testlib/qplaintestlogger.cpp
+++ b/src/testlib/qplaintestlogger.cpp
@@ -66,6 +66,10 @@
 #  include <android/log.h>
 #endif
 
+#ifdef Q_OS_OPENHARMONY
+#include <QDebug>
+#endif
+
 #ifdef Q_OS_WIN
 #  include <qt_windows.h>
 #endif
@@ -221,6 +225,9 @@ void QPlainTestLogger::outputMessage(const char *str)
     }
 #elif defined(Q_OS_ANDROID)
     __android_log_write(ANDROID_LOG_INFO, "QTestLib", str);
+#elif defined(Q_OS_OPENHARMONY)
+        /* wanghao TODO */
+        qInfo() << str;
 #endif
     outputString(str);
 }
diff --git a/src/testlib/qtestlog.cpp b/src/testlib/qtestlog.cpp
index 8917f0dc0e..7042f00f2d 100644
--- a/src/testlib/qtestlog.cpp
+++ b/src/testlib/qtestlog.cpp
@@ -420,8 +420,10 @@ void QTestLog::startLogging()
     elapsedTotalTime.start();
     elapsedFunctionTime.start();
     FOREACH_TEST_LOGGER
-        logger->startLogging();
+            logger->startLogging();
+#ifndef Q_OS_OPENHARMONY
     QTest::oldMessageHandler = qInstallMessageHandler(QTest::messageHandler);
+#endif
 }
 
 void QTestLog::stopLogging()
diff --git a/src/widgets/configure.json b/src/widgets/configure.json
index 0a68f082a2..b3e6991a50 100644
--- a/src/widgets/configure.json
+++ b/src/widgets/configure.json
@@ -13,7 +13,8 @@
             "style-windowsvista": "boolean",
             "style-fusion": "boolean",
             "style-mac": "boolean",
-            "style-android": "boolean"
+            "style-android": "boolean",
+            "style-harmonyos": "boolean"
         }
     },
 
@@ -64,6 +65,11 @@
             "autoDetect": "config.android",
             "output": [ "privateFeature", "styles" ]
         },
+        "style-harmonyos": {
+            "label": "HarmonyOS",
+            "autoDetect": "config.openharmony",
+            "output": [ "privateFeature", "styles" ]
+        },
         "style-stylesheet": {
             "label": "QStyleSheetStyle",
             "purpose": "Provides a widget style which is configurable via CSS.",
diff --git a/src/widgets/dialogs/qfiledialog.cpp b/src/widgets/dialogs/qfiledialog.cpp
index 711effefe2..23832aa70a 100644
--- a/src/widgets/dialogs/qfiledialog.cpp
+++ b/src/widgets/dialogs/qfiledialog.cpp
@@ -886,7 +886,9 @@ void QFileDialog::setVisible(bool visible)
         if (d->setNativeDialogVisible(visible)){
             // Set WA_DontShowOnScreen so that QDialog::setVisible(visible) below
             // updates the state correctly, but skips showing the non-native version:
+#ifndef Q_OS_OPENHARMONY
             setAttribute(Qt::WA_DontShowOnScreen);
+#endif
 #if QT_CONFIG(fscompleter)
             // So the completer doesn't try to complete and therefore show a popup
             if (!d->nativeDialogInUse)
@@ -1311,6 +1313,9 @@ QStringList QFileDialog::selectedFiles() const
     QStringList files;
     const QList<QUrl> userSelectedFiles = d->userSelectedFiles();
     files.reserve(userSelectedFiles.size());
+
+
+    QString fileName;
     for (const QUrl &file : userSelectedFiles) {
         if (file.isLocalFile() || file.isEmpty())
             files.append(file.toLocalFile());
@@ -1354,6 +1359,22 @@ QList<QUrl> QFileDialog::selectedUrls() const
 */
 QStringList qt_make_filter_list(const QString &filter)
 {
+#ifdef Q_OS_OPENHARMONY
+    QStringList allExtensions;
+    if (filter == QFileDialogOptions::defaultNameFilterString()){
+        allExtensions << "*";
+    } else {
+        int pos = 0;
+        QRegExp regExp("\\*\\.\\w+");
+        while ((pos = regExp.indexIn(filter, pos)) != -1) {
+            QString matchedExtension = regExp.cap(0); /* 获取整个匹配到的字符串 */
+            QString extension = matchedExtension.mid(1); /* 去掉开头的星号 */
+            allExtensions << extension;
+            pos += regExp.matchedLength();
+        }
+    }
+    return allExtensions;
+#else
     QString f(filter);
 
     if (f.isEmpty())
@@ -1369,6 +1390,7 @@ QStringList qt_make_filter_list(const QString &filter)
     }
 
     return f.split(sep);
+#endif
 }
 
 /*!
@@ -2219,7 +2241,11 @@ QString QFileDialog::getOpenFileName(QWidget *parent,
     const QUrl selectedUrl = getOpenFileUrl(parent, caption, QUrl::fromLocalFile(dir), filter,
                                             selectedFilter, options, schemes);
     if (selectedUrl.isLocalFile() || selectedUrl.isEmpty())
+#ifdef Q_OS_OPENHARMONY
+        return selectedUrl.path();
+#else
         return selectedUrl.toLocalFile();
+#endif
     else
         return selectedUrl.toString();
 }
diff --git a/src/widgets/widgets/qtextbrowser.cpp b/src/widgets/widgets/qtextbrowser.cpp
index 122a8529e8..138a6a5b4e 100644
--- a/src/widgets/widgets/qtextbrowser.cpp
+++ b/src/widgets/widgets/qtextbrowser.cpp
@@ -177,6 +177,11 @@ QString QTextBrowserPrivate::findFile(const QUrl &name) const
         if (name.scheme() == QLatin1String("assets"))
             fileName = QLatin1String("assets:") + name.path();
         else
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            if (name.scheme() == QLatin1String("rawfile"))
+                fileName = QLatin1String("rawfile:") + name.path();
+            else
 #endif
             fileName = name.toLocalFile();
     }
@@ -247,6 +252,9 @@ void QTextBrowserPrivate::_q_activateAnchor(const QString &href)
             url.scheme() == QLatin1String("file")
 #if defined(Q_OS_ANDROID)
             || url.scheme() == QLatin1String("assets")
+#endif
+#if defined(Q_OS_OPENHARMONY)
+            || url.scheme() == QLatin1String("rawfile")
 #endif
             || url.scheme() == QLatin1String("qrc");
     if ((openExternalLinks && !isFileScheme && !url.isRelative())
diff --git a/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp b/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp
index 2e2209ac5d..b6b872fc24 100644
--- a/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp
+++ b/tests/auto/corelib/kernel/qmetatype/tst_qmetatype.cpp
@@ -368,7 +368,7 @@ protected:
             const QByteArray name = "Bar" + QByteArray::number(i) + postFix;
             const char *nm = name.constData();
             int tp = qRegisterMetaType<Bar>(nm);
-#if defined(Q_OS_LINUX) && !defined(Q_OS_ANDROID)
+#if defined(Q_OS_LINUX) && !defined(Q_OS_ANDROID) && !defined(Q_OS_OPENHARMONY)
             sched_yield();
 #endif
             QMetaType info(tp);
diff --git a/tests/auto/corelib/text/qlocale/tst_qlocale.cpp b/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
index 4ee6c6df75..552c75b0d1 100644
--- a/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
+++ b/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
@@ -46,7 +46,7 @@
 #include <private/qlocale_tools_p.h>
 #include <qnumeric.h>
 
-#if defined(Q_OS_LINUX) && !defined(__UCLIBC__)
+#if defined(Q_OS_LINUX) && !defined(__UCLIBC__) && !defined(Q_OS_OPENHARMONY)
 #    define QT_USE_FENV
 #endif
 
